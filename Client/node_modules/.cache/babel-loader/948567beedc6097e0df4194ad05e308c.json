{"ast":null,"code":"const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nexport class InvalidCharacterError extends Error {\n  constructor(message) {\n    super(message);\n  }\n\n}\n\nfunction polyfill(input) {\n  const str = String(input).replace(/=+$/, '');\n\n  if (str.length % 4 === 1) {\n    throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  }\n\n  let output = '';\n\n  for (let bc = 0, bs, buffer, idx = 0; buffer = str.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n    buffer = chars.indexOf(buffer);\n  }\n\n  return output;\n}\n\nconst atob = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;\n\nfunction b64DecodeUnicode(str) {\n  return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n\n    return '%' + code;\n  }));\n}\n\nconst base64UrlDecode = str => {\n  let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n  switch (output.length % 4) {\n    case 0:\n      break;\n\n    case 2:\n      output += '==';\n      break;\n\n    case 3:\n      output += '=';\n      break;\n\n    default:\n      throw new Error('Illegal base64url string!');\n  }\n\n  try {\n    return b64DecodeUnicode(output);\n  } catch (err) {\n    return atob(output);\n  }\n};\n\nexport class InvalidTokenError extends Error {\n  constructor(message) {\n    super(message);\n  }\n\n}\nexport const jwtDecode = (token, options = {}) => {\n  const pos = !!options.header ? 0 : 1;\n\n  try {\n    return JSON.parse(base64UrlDecode(token.split('.')[pos]));\n  } catch (e) {\n    throw new InvalidTokenError('Invalid token specified: ' + e.message);\n  }\n};","map":{"version":3,"sources":["/Users/mashapav/Downloads/WEB-CHAT/Client/node_modules/@frontegg/rest-api/jwt.js"],"names":["chars","InvalidCharacterError","Error","constructor","message","polyfill","input","str","String","replace","length","output","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","atob","window","bind","b64DecodeUnicode","decodeURIComponent","m","p","code","charCodeAt","toString","toUpperCase","base64UrlDecode","err","InvalidTokenError","jwtDecode","token","options","pos","header","JSON","parse","split","e"],"mappings":"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","sourcesContent":["const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nexport class InvalidCharacterError extends Error {\n  constructor(message) {\n    super(message);\n  }\n\n}\n\nfunction polyfill(input) {\n  const str = String(input).replace(/=+$/, '');\n\n  if (str.length % 4 === 1) {\n    throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  }\n\n  let output = '';\n\n  for (let bc = 0, bs, buffer, idx = 0; buffer = str.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n    buffer = chars.indexOf(buffer);\n  }\n\n  return output;\n}\n\nconst atob = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;\n\nfunction b64DecodeUnicode(str) {\n  return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n\n    return '%' + code;\n  }));\n}\n\nconst base64UrlDecode = str => {\n  let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n  switch (output.length % 4) {\n    case 0:\n      break;\n\n    case 2:\n      output += '==';\n      break;\n\n    case 3:\n      output += '=';\n      break;\n\n    default:\n      throw new Error('Illegal base64url string!');\n  }\n\n  try {\n    return b64DecodeUnicode(output);\n  } catch (err) {\n    return atob(output);\n  }\n};\n\nexport class InvalidTokenError extends Error {\n  constructor(message) {\n    super(message);\n  }\n\n}\nexport const jwtDecode = (token, options = {}) => {\n  const pos = !!options.header ? 0 : 1;\n\n  try {\n    return JSON.parse(base64UrlDecode(token.split('.')[pos]));\n  } catch (e) {\n    throw new InvalidTokenError('Invalid token specified: ' + e.message);\n  }\n};"]},"metadata":{},"sourceType":"module"}