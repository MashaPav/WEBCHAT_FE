import { createAction, createSlice } from '@reduxjs/toolkit';
import { a as authStoreName, F as FRONTEGG_AFTER_AUTH_REDIRECT_URL, H as HOSTED_LOGIN_VERIFIER_KEY } from '../constants-4d9682b2.js';
export { a as authStoreName } from '../constants-4d9682b2.js';
import { __awaiter, __rest } from 'tslib';
import { takeLeading, put, select, call, takeEvery, delay as delay$1, all, retry, takeLatest } from 'redux-saga/effects';
import { AuthStrategyEnum, api, ContextHolder, fetch } from '@frontegg/rest-api';
export { AuthStrategyEnum } from '@frontegg/rest-api';
import { l as loadVendorPublicInfo } from '../saga-b6529ffb.js';
import { v4 } from 'uuid';

const resetStateByKey = (key, initialState) => (state) => (Object.assign(Object.assign({}, state), { [key]: initialState[key] }));
const typeReducer = (key) => (state, { payload }) => (Object.assign(Object.assign({}, state), { [key]: payload }));
const typeReducerForKey = (key) => ({
    prepare: (payload) => ({ payload }),
    reducer: (state, { payload }) => {
        return Object.assign(Object.assign({}, state), { [key]: Object.assign(Object.assign({}, state[key]), payload) });
    },
});
const typeReducerNestedKey = (key, nestedKey) => ({
    prepare: (payload) => ({ payload }),
    reducer: (state, { payload }) => {
        var _a;
        return Object.assign(Object.assign({}, state), { [key]: Object.assign(Object.assign({}, state[key]), { [nestedKey]: Object.assign(Object.assign({}, (_a = state === null || state === void 0 ? void 0 : state[key]) === null || _a === void 0 ? void 0 : _a[nestedKey]), payload) }) });
    },
});
const loadersReducerForKey = (key) => ({
    prepare: (payload) => ({ payload }),
    reducer: (state, { payload }) => {
        var _a;
        return (Object.assign(Object.assign({}, state), { [key]: Object.assign(Object.assign({}, state[key]), { loaders: Object.assign(Object.assign({}, state[key].loaders), { [payload.key]: (_a = payload.value) !== null && _a !== void 0 ? _a : true }) }) }));
    },
});
const errorsReducerForKey = (key) => ({
    prepare: (payload) => ({ payload }),
    reducer: (state, { payload }) => {
        var _a;
        return (Object.assign(Object.assign({}, state), { [key]: Object.assign(Object.assign({}, state[key]), { errors: Object.assign(Object.assign({}, state[key].errors), { [payload.key]: (_a = payload.value) !== null && _a !== void 0 ? _a : true }) }) }));
    },
});
const delay = (delayTime = 500) => new Promise((resolve) => setTimeout(resolve, delayTime));
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
const lookup = new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const base64urlEncode = (arraybuffer) => {
    const bytes = new Uint8Array(arraybuffer);
    const len = bytes.length;
    let i;
    let base64url = '';
    for (i = 0; i < len; i += 3) {
        base64url += chars[bytes[i] >> 2];
        base64url += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64url += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64url += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64url = base64url.substring(0, base64url.length - 1);
    }
    else if (len % 3 === 1) {
        base64url = base64url.substring(0, base64url.length - 2);
    }
    return base64url;
};
const base64urlDecode = (base64string) => {
    const bufferLength = base64string.length * 0.75;
    let len = base64string.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    const bytes = new Uint8Array(bufferLength);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64string.charCodeAt(i)];
        encoded2 = lookup[base64string.charCodeAt(i + 1)];
        encoded3 = lookup[base64string.charCodeAt(i + 2)];
        encoded4 = lookup[base64string.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return bytes.buffer;
};
const publicKeyCredentialToJSON = (pubKeyCred) => {
    if (pubKeyCred instanceof Array) {
        const arr = [];
        for (const i of pubKeyCred) {
            arr.push(publicKeyCredentialToJSON(i));
        }
        return arr;
    }
    else if (pubKeyCred instanceof ArrayBuffer) {
        return base64urlEncode(pubKeyCred);
    }
    else if (pubKeyCred instanceof Object) {
        const obj = {};
        for (const key in pubKeyCred) {
            obj[key] = publicKeyCredentialToJSON(pubKeyCred[key]);
        }
        return obj;
    }
    return pubKeyCred;
};

var LoginStep;
(function (LoginStep) {
    LoginStep["preLogin"] = "preLogin";
    LoginStep["magicLinkPreLoginSuccess"] = "magicLinkPreLoginSuccess";
    LoginStep["loginWithSmsOtc"] = "loginWithSmsOtc";
    LoginStep["loginWithQuickSmsOtc"] = "loginWithQuickSmsOtc";
    LoginStep["loginWithOtc"] = "loginWithOtc";
    LoginStep["loginWithPassword"] = "loginWithPassword";
    LoginStep["loginWithTwoFactor"] = "loginWithTwoFactor";
    LoginStep["redirectToSSO"] = "redirectToSSO";
    LoginStep["loginWithSSOFailed"] = "loginWithSSOFailed";
    LoginStep["success"] = "success";
    LoginStep["forceTwoFactor"] = "forceTwoFactor";
    LoginStep["recoverTwoFactor"] = "recoverTwoFactor";
})(LoginStep || (LoginStep = {}));
var LoginFlow;
(function (LoginFlow) {
    LoginFlow["Login"] = "login";
    LoginFlow["RegisterQuickLogin"] = "registerQuickLogin";
})(LoginFlow || (LoginFlow = {}));
var QuickLoginStrategy;
(function (QuickLoginStrategy) {
    QuickLoginStrategy["Internal"] = "internal";
    QuickLoginStrategy["UsbKey"] = "usb-key";
    QuickLoginStrategy["Android"] = "android";
    QuickLoginStrategy["Sms"] = "sms";
})(QuickLoginStrategy || (QuickLoginStrategy = {}));

const loginState = {
    flow: LoginFlow.Login,
    step: LoginStep.preLogin,
    loading: false,
    email: '',
    tenants: [],
};
const reducers$h = {
    setLoginState: typeReducerForKey('loginState'),
    resetLoginState: resetStateByKey('loginState', { loginState }),
};
const actions$i = {
    requestAuthorize: createAction(`${authStoreName}/requestAuthorize`, (payload = false) => ({ payload })),
    requestAuthorizeSSR: createAction(`${authStoreName}/requestAuthorizeSSR`, (payload) => ({ payload })),
    requestHostedLoginAuthorize: createAction(`${authStoreName}/requestHostedLoginAuthorize`),
    handleHostedLoginCallback: createAction(`${authStoreName}/handleHostedLoginCallback`, (payload) => ({ payload })),
    afterAuthNavigation: createAction(`${authStoreName}/afterAuthNavigation`),
    preLogin: createAction(`${authStoreName}/preLogin`, (payload) => ({ payload })),
    postLogin: createAction(`${authStoreName}/postLogin`, (payload) => ({ payload })),
    login: createAction(`${authStoreName}/login`, (payload) => ({ payload })),
    loginWithMfa: createAction(`${authStoreName}/loginWithMfa`, (payload) => ({ payload })),
    recoverMfa: createAction(`${authStoreName}/recoverMfa`, (payload) => ({ payload })),
    logout: createAction(`${authStoreName}/logout`, (payload) => ({ payload })),
    silentLogout: createAction(`${authStoreName}/silentLogout`, (payload) => ({ payload })),
    checkIfAllowToRememberMfaDevice: createAction(`${authStoreName}/checkIfAllowToRememberMfaDevice`, (payload) => ({ payload })),
    changePhoneNumberWithVerification: createAction(`${authStoreName}/changePhoneNumberWithVerification`, (payload) => ({ payload })),
    verifyChangePhoneNumber: createAction(`${authStoreName}/verifyChangePhoneNumber`, (payload) => ({ payload })),
    quickSmsPasswordlessPreLogin: createAction(`${authStoreName}/quickSmsPasswordlessPreLogin`, (payload) => ({ payload })),
    passwordlessPreLogin: createAction(`${authStoreName}/passwordlessPreLogin`, (payload) => ({ payload })),
    passwordlessPostLogin: createAction(`${authStoreName}/passwordlessPostLogin`, (payload) => ({ payload })),
    verifyInviteToken: createAction(`${authStoreName}/verifyInviteToken`, (payload) => ({ payload })),
    webAuthnPrelogin: createAction(`${authStoreName}/webAuthnPrelogin`, (payload) => ({ payload })),
    webAuthnPostLogin: createAction(`${authStoreName}/webAuthnPostLogin`, (payload) => ({ payload })),
    webAuthnCreateNewDeviceSession: createAction(`${authStoreName}/webAuthnCreateNewDeviceSession`, (payload) => ({ payload })),
    webAuthnVerifyNewDeviceSession: createAction(`${authStoreName}/webAuthnVerifyNewDeviceSession`, (payload) => ({ payload })),
};

var ActivateAccountStep;
(function (ActivateAccountStep) {
    ActivateAccountStep["activating"] = "activating";
    ActivateAccountStep["success"] = "success";
    ActivateAccountStep["resend"] = "resend";
    ActivateAccountStep["activatingForm"] = "activatingForm";
})(ActivateAccountStep || (ActivateAccountStep = {}));

const activateState = {
    step: ActivateAccountStep.activating,
    loading: false,
    resentEmail: false,
    activationStrategy: {
        loading: false,
    },
};
const reducers$g = {
    setActivateState: typeReducerForKey('activateState'),
    resetActivateState: resetStateByKey('activateState', { activateState }),
    setActivateStrategyState: typeReducerNestedKey('activateState', 'activationStrategy'),
};
const actions$h = {
    activateAccount: createAction(`${authStoreName}/activateAccount`, (payload) => ({ payload })),
    preActivateAccount: createAction(`${authStoreName}/preActivateAccount`, (payload) => ({ payload })),
    getActivateAccountStrategy: createAction(`${authStoreName}/getActivateAccountStrategy`, (payload) => ({ payload })),
    resendActivationEmail: createAction(`${authStoreName}/resendActivationEmail`, (payload) => ({
        payload,
    })),
};

var AcceptInvitationStep;
(function (AcceptInvitationStep) {
    AcceptInvitationStep["validate"] = "validate";
    AcceptInvitationStep["invalid"] = "invalid";
    AcceptInvitationStep["pending"] = "pending";
    AcceptInvitationStep["success"] = "success";
    AcceptInvitationStep["failed"] = "failed";
})(AcceptInvitationStep || (AcceptInvitationStep = {}));

const acceptInvitationState = {
    step: AcceptInvitationStep.validate,
};
const reducers$f = {
    setAcceptInvitationState: typeReducerForKey('acceptInvitationState'),
    resetAcceptInvitationState: resetStateByKey('acceptInvitationState', {
        acceptInvitationState,
    }),
};
const actions$g = {
    acceptInvitation: createAction(`${authStoreName}/acceptInvitation`, (payload) => ({ payload })),
};

var ForgotPasswordStep;
(function (ForgotPasswordStep) {
    ForgotPasswordStep["forgotPassword"] = "forgotPassword";
    ForgotPasswordStep["success"] = "success";
})(ForgotPasswordStep || (ForgotPasswordStep = {}));

const forgotPasswordState = {
    step: ForgotPasswordStep.forgotPassword,
    loading: false,
    email: '',
    passwordConfig: null,
};
const reducers$e = {
    setForgotPasswordState: typeReducerForKey('forgotPasswordState'),
    resetForgotPasswordState: resetStateByKey('forgotPasswordState', { forgotPasswordState }),
};
const actions$f = {
    forgotPassword: createAction(`${authStoreName}/forgotPassword`, (payload) => ({ payload })),
    resetPassword: createAction(`${authStoreName}/resetPassword`, (payload) => ({ payload })),
    loadPasswordConfig: createAction(`${authStoreName}/loadPasswordConfig`, (payload) => ({
        payload,
    })),
};

var ResetPhoneNumberStep;
(function (ResetPhoneNumberStep) {
    ResetPhoneNumberStep["ResetPhoneNumber"] = "ResetPhoneNumber";
    ResetPhoneNumberStep["VerifyResetPhoneNumber"] = "VerifyResetPhoneNumber";
    ResetPhoneNumberStep["ChangePhoneNumber"] = "ChangePhoneNumber";
})(ResetPhoneNumberStep || (ResetPhoneNumberStep = {}));

const resetPhoneNumberState = {
    step: ResetPhoneNumberStep.ResetPhoneNumber,
    loading: false,
};
const reducers$d = {
    setResetPhoneNumberState: typeReducerForKey('resetPhoneNumberState'),
    resetResetPhoneNumberState: resetStateByKey('resetPhoneNumberState', { resetPhoneNumberState }),
};
const actions$e = {
    resetPhoneNumber: createAction(`${authStoreName}/resetPhoneNumber`, (payload) => ({ payload })),
    verifyResetPhoneNumber: createAction(`${authStoreName}/verifyResetPhoneNumber`, (payload) => ({ payload })),
    changePhoneNumber: createAction(`${authStoreName}/changePhoneNumber`, (payload) => ({ payload })),
};

const ssoState = {
    firstLoad: true,
    loading: true,
    saving: false,
    errors: {},
    loaders: {},
    ssoConfigurations: []
};
const reducers$c = {
    setSSOLoader: loadersReducerForKey('ssoState'),
    setSSOError: errorsReducerForKey('ssoState'),
    setSSOState: typeReducerForKey('ssoState'),
    resetSSOState: resetStateByKey('ssoState', { ssoState }),
};
const actions$d = {
    loadSSOConfigurationsV2: createAction(`${authStoreName}/loadSSOConfigurationsV2`),
    saveSSOConfigurationV2: createAction(`${authStoreName}/saveSSOConfigurationV2`, (payload) => ({ payload })),
    updateSSOConfiguration: createAction(`${authStoreName}/updateSSOConfiguration`, (payload) => ({ payload })),
    deleteSSOConfiguration: createAction(`${authStoreName}/deleteSSOConfiguration`, (payload) => ({ payload })),
    saveSSODomain: createAction(`${authStoreName}/saveSSODomain`, (payload) => ({ payload })),
    deleteSSODomain: createAction(`${authStoreName}/deleteSSODomain`, (payload) => ({ payload })),
    validateSSODomainV2: createAction(`${authStoreName}/validateSSODomainV2`, (payload) => ({ payload })),
    setSSODefaultRoles: createAction(`${authStoreName}/setSSODefaultRoles`, (payload) => ({ payload })),
    setSSOGroups: createAction(`${authStoreName}/setSSOGroups`, (payload) => ({ payload })),
    updateSSOGroups: createAction(`${authStoreName}/updateSSOGroups`, (payload) => ({ payload })),
    saveSSOConfigurationByMetadata: createAction(`${authStoreName}/saveSSOConfigurationByMetadata`, (payload) => ({ payload })),
    updateSSOConfigurationByMetadata: createAction(`${authStoreName}/updateSSOConfigurationByMetadata`, (payload) => ({ payload })),
    loadSSOConfigurations: createAction(`${authStoreName}/loadSSOConfigurations`),
    loadSSOAuthorizationRoles: createAction(`${authStoreName}/loadSSOAuthorizationRoles`),
    saveSSOConfigurations: createAction(`${authStoreName}/saveSSOConfigurations`, (payload) => ({ payload })),
    // NOTE: use withCallback in case of promise response
    saveSSOConfigurationsFile: createAction(`${authStoreName}/saveSSOConfigurationsFile`, (payload) => ({
        payload,
    })),
    saveSSOConfigurationsFileWithCallback: createAction(`${authStoreName}/saveSSOConfigurationsFileWithCallback`, (payload) => ({ payload })),
    validateSSODomain: createAction(`${authStoreName}/validateSSODomain`, (payload) => ({ payload })),
    updateSSOAuthorizationRoles: createAction(`${authStoreName}/updateSSOAuthorizationRoles`, (payload) => ({ payload })),
    deleteSamlGroup: createAction(`${authStoreName}/deleteSamlGroup`, (payload) => ({ payload })),
    createSamlGroup: createAction(`${authStoreName}/createSamlGroup`, (payload) => ({ payload })),
    oidcPostlogin: createAction(`${authStoreName}/oidcPostlogin`, (payload) => ({
        payload,
    })),
};

const profileState = {
    loading: false,
    error: null,
};
const reducers$b = {
    setProfileState: typeReducerForKey('profileState'),
    resetProfileState: resetStateByKey('profileState', { profileState }),
};
const actions$c = {
    loadProfile: createAction(`${authStoreName}/loadProfile`),
    saveProfile: createAction(`${authStoreName}/saveProfile`, (payload) => ({ payload })),
    changePassword: createAction(`${authStoreName}/changePassword`, (payload) => ({
        payload,
    })),
};

var MFAStep;
(function (MFAStep) {
    MFAStep["verify"] = "verify";
    MFAStep["recoveryCode"] = "recoveryCode";
})(MFAStep || (MFAStep = {}));

const mfaState = {
    step: MFAStep.verify,
    loading: false,
};
const reducers$a = {
    setMfaState: typeReducerForKey('mfaState'),
    resetMfaState: resetStateByKey('mfaState', { mfaState }),
};
const actions$b = {
    enrollMfa: createAction(`${authStoreName}/enrollMfa`),
    verifyMfa: createAction(`${authStoreName}/verifyMfa`, (payload) => ({
        payload,
    })),
    verifyMfaAfterForce: createAction(`${authStoreName}/verifyMfaAfterForce`, (payload) => ({
        payload,
    })),
    disableMfa: createAction(`${authStoreName}/disableMfa`, (payload) => ({ payload })),
};

const teamState = {
    loaders: {},
    pageOffset: 0,
    pageSize: 20,
    errors: {},
    users: [],
    allUsers: [],
    roles: [],
    permissions: [],
    totalPages: 0,
    filter: [],
    sort: [],
    allUsersQueryParams: {
        _filter: null,
        _offset: 0,
        _limit: 20,
        _order: 'DESC',
        _sortBy: 'name',
    },
    addUserDialogState: {
        loading: false,
        open: false,
    },
    deleteUserDialogState: {
        loading: false,
        open: false,
    },
    lockUserDialogState: {
        loading: false,
        open: false,
    },
};
const reducers$9 = {
    setTeamLoader: loadersReducerForKey('teamState'),
    setTeamError: errorsReducerForKey('teamState'),
    setTeamState: typeReducerForKey('teamState'),
    resetTeamState: resetStateByKey('teamState', { teamState }),
};
const actions$a = {
    loadUsers: createAction(`${authStoreName}/loadUsers`, (payload) => ({ payload })),
    loadAllSubTenantsUsers: createAction(`${authStoreName}/loadAllSubTenantsUsers`, (payload) => ({ payload })),
    loadRoles: createAction(`${authStoreName}/loadRoles`, (payload) => ({ payload })),
    addUser: createAction(`${authStoreName}/addUser`, (payload) => ({ payload })),
    addUserToSubTenants: createAction(`${authStoreName}/addUserToSubTenants`, (payload) => ({ payload })),
    updateUser: createAction(`${authStoreName}/updateUser`, (payload) => ({
        payload,
    })),
    deleteUser: createAction(`${authStoreName}/deleteUser`, (payload) => ({ payload })),
    setUserRolesForSubTenants: createAction(`${authStoreName}/setUserRolesForSubTenants`, (payload) => ({ payload })),
    deleteUserFromSubTenants: createAction(`${authStoreName}/deleteUserFromSubTenants`, (payload) => ({ payload })),
    lockUser: createAction(`${authStoreName}/lockUser`, (payload) => ({ payload })),
    resendActivationLink: createAction(`${authStoreName}/resendActivationLink`, (payload) => ({ payload })),
    resendInvitationLink: createAction(`${authStoreName}/resendInvitationLink`, (payload) => ({ payload })),
    resendInvitationLinkToAllSubTenants: createAction(`${authStoreName}/resendInvitationLinkToAllSubTenants`, (payload) => ({ payload })),
    getInvitationLink: createAction(`${authStoreName}/getInvitationLink`),
    createInvitationLink: createAction(`${authStoreName}/createInvitationLink`, (payload) => ({ payload })),
    updateInvitationLink: createAction(`${authStoreName}/updateInvitationLink`, (payload) => ({ payload })),
    deleteInvitationLink: createAction(`${authStoreName}/deleteInvitationLink`, (payload) => ({ payload })),
    openAddUserDialog: createAction(`${authStoreName}/openAddUserDialog`, (payload) => ({ payload })),
    closeAddUserDialog: createAction(`${authStoreName}/closeAddUserDialog`, (payload) => ({ payload })),
    openDeleteUserDialog: createAction(`${authStoreName}/openDeleteUserDialog`, (payload) => ({
        payload,
    })),
    closeDeleteUserDialog: createAction(`${authStoreName}/closeDeleteUserDialog`, (payload) => ({ payload })),
    openLockUserDialog: createAction(`${authStoreName}/openLockUserDialog`, (payload) => ({
        payload,
    })),
    closeLockUserDialog: createAction(`${authStoreName}/closeLockUserDialog`, (payload) => ({ payload })),
};

const socialLoginState = {
    firstLoad: true,
    loading: false,
    error: '',
};
const reducers$8 = {
    setSocialLoginsState: typeReducerForKey('socialLoginState'),
    resetSocialLoginsState: resetStateByKey('socialLoginState', { socialLoginState }),
};
const actions$9 = {
    loadSocialLoginsConfiguration: createAction(`${authStoreName}/loadSocialLoginsConfiguration`),
    loadSocialLoginsConfigurationV2: createAction(`${authStoreName}/loadSocialLoginsConfigurationV2`),
    loginViaSocialLogin: createAction(`${authStoreName}/loginViaSocialLogin`, (payload) => ({
        payload,
    })),
    setSocialLoginError: createAction(`${authStoreName}/setSocialLoginError`, (payload) => ({
        payload,
    })),
};

var SignUpStage;
(function (SignUpStage) {
    SignUpStage["SignUp"] = "SignUp";
    SignUpStage["SignUpSuccess"] = "SignUpSuccess";
})(SignUpStage || (SignUpStage = {}));

const signUpState = {
    loading: false,
    allowSignUps: false,
    allowNotVerifiedUsersLogin: false,
    firstLoad: true,
    stage: SignUpStage.SignUp,
};
const reducers$7 = {
    setSignUpState: typeReducerForKey('signUpState'),
    resetSignUpState: resetStateByKey('signUpState', { signUpState }),
};
const actions$8 = {
    signUpUser: createAction(`${authStoreName}/signUpUser`, (payload) => ({ payload })),
    resetSignUpStateSoft: createAction(`${authStoreName}/resetSignUpStateSoft`),
};

const apiTokensState = {
    apiTokenType: null,
    searchValue: '',
    showAddTokenDialog: false,
    createdByUserIdColumn: 'show',
    deleteTokenDialog: {
        open: false,
        clientId: '',
    },
    successDialog: {
        open: false,
        secret: '',
        clientId: '',
    },
    loaders: {},
    apiTokensDataTenant: [],
    apiTokensDataUser: [],
    roles: [],
    permissions: [],
    errors: {},
};
const reducers$6 = {
    setApiTokensLoader: loadersReducerForKey('apiTokensState'),
    setApiTokensError: errorsReducerForKey('apiTokensState'),
    setApiTokensState: typeReducerForKey('apiTokensState'),
    resetApiTokensState: resetStateByKey('apiTokensState', { apiTokensState }),
};
const actions$7 = {
    loadApiTokens: createAction(`${authStoreName}/loadApiTokens`, (payload) => ({
        payload,
    })),
    initApiTokensData: createAction(`${authStoreName}/initApiTokensData`, (payload) => ({ payload })),
    addTenantApiToken: createAction(`${authStoreName}/addTenantApiToken`, (payload) => ({
        payload,
    })),
    addUserApiToken: createAction(`${authStoreName}/addUserApiToken`, (payload) => ({ payload })),
    deleteUserApiToken: createAction(`${authStoreName}/deleteUserApiToken`, (payload) => ({ payload })),
    deleteTenantApiToken: createAction(`${authStoreName}/deleteTenantApiToken`, (payload) => ({ payload })),
};

const securityPolicyState = {
    globalPolicy: {
        loading: true,
    },
    publicPolicy: {
        loading: false,
    },
    vendorMfaPolicy: {
        loading: true,
    },
    mfaPolicy: {
        loading: true,
    },
    lockoutPolicy: {
        loading: true,
    },
    captchaPolicy: {
        loading: true,
    },
    passwordHistoryPolicy: {
        loading: true,
    },
    passwordPolicy: {
        loading: true,
    },
    publicAuthStrategyPolicy: {
        loading: true,
    },
};
const reducers$5 = {
    setSecurityPolicyState: typeReducerForKey('securityPolicyState'),
    setSecurityPolicyGlobalState: typeReducerNestedKey('securityPolicyState', 'globalPolicy'),
    setSecurityPolicyPublicState: typeReducerNestedKey('securityPolicyState', 'publicPolicy'),
    setSecurityPolicyAuthStrategyPublicState: typeReducerNestedKey('securityPolicyState', 'publicAuthStrategyPolicy'),
    setSecurityPolicyMfaState: typeReducerNestedKey('securityPolicyState', 'mfaPolicy'),
    setSecurityPolicyVendorMfaState: typeReducerNestedKey('securityPolicyState', 'vendorMfaPolicy'),
    setSecurityPolicyLockoutState: typeReducerNestedKey('securityPolicyState', 'lockoutPolicy'),
    setSecurityPolicyCaptchaState: typeReducerNestedKey('securityPolicyState', 'captchaPolicy'),
    setSecurityPolicyPasswordHistoryState: typeReducerNestedKey('securityPolicyState', 'passwordHistoryPolicy'),
    setSecurityPolicyPasswordState: typeReducerNestedKey('securityPolicyState', 'passwordPolicy'),
    resetSecurityPolicyState: resetStateByKey('securityPolicyState', { securityPolicyState }),
};
const actions$6 = {
    loadSecurityPolicy: createAction(`${authStoreName}/loadSecurityPolicy`),
    loadPublicSecurityPolicy: createAction(`${authStoreName}/loadPublicSecurityPolicy`),
    loadSecurityPolicyMfa: createAction(`${authStoreName}/loadSecurityPolicyMfa`),
    loadSecurityPolicyVendorMfa: createAction(`${authStoreName}/loadSecurityPolicyVendorMfa`),
    saveSecurityPolicyMfa: createAction(`${authStoreName}/saveSecurityPolicyMfa`, (payload) => ({ payload })),
    loadSecurityPolicyLockout: createAction(`${authStoreName}/loadSecurityPolicyLockout`),
    saveSecurityPolicyLockout: createAction(`${authStoreName}/saveSecurityPolicyLockout`, (payload) => ({ payload })),
    loadSecurityPolicyCaptcha: createAction(`${authStoreName}/loadSecurityPolicyCaptcha`),
    loadSecurityPolicyPasswordHistory: createAction(`${authStoreName}/loadSecurityPolicyPasswordHistory`),
    saveSecurityPolicyPasswordHistory: createAction(`${authStoreName}/saveSecurityPolicyPasswordHistory`, (payload) => ({ payload })),
    loadVendorPasswordConfig: createAction(`${authStoreName}/loadVendorPasswordConfig`),
    loadPublicAuthStrategiesPolicy: createAction(`${authStoreName}/loadPublicAuthStrategiesPolicy`),
};

const accountSettingsState = {
    loading: false,
};
const reducers$4 = {
    setAccountSettingsState: typeReducerForKey('accountSettingsState'),
    resetAccountSettingsState: resetStateByKey('accountSettingsState', { accountSettingsState }),
};
const actions$5 = {
    loadAccountSettings: createAction(`${authStoreName}/loadAccountSettings`, (payload) => ({ payload })),
    saveAccountSettings: createAction(`${authStoreName}/saveAccountSettings`, (payload) => ({ payload })),
};

const tenantsState = {
    tenants: [],
    subTenants: [],
    loading: true,
    tenantTree: null,
};
const reducers$3 = {
    setTenantsState: typeReducerForKey('tenantsState'),
    resetTenantsState: resetStateByKey('tenantsState', { tenantsState }),
};
const actions$4 = {
    switchTenant: createAction(`${authStoreName}/switchTenant`, (payload) => ({ payload })),
    loadTenants: createAction(`${authStoreName}/loadTenants`, (payload) => ({
        payload,
    })),
    loadSubTenants: createAction(`${authStoreName}/loadSubTenants`, (payload) => ({
        payload,
    })),
    loadSubTenantsTree: createAction(`${authStoreName}/loadSubTenantsTree`, (payload) => ({
        payload,
    })),
};

const rolesState = {
    loading: false,
    roles: [],
    permissions: [],
    permissionCategories: [],
};
const reducers$2 = {
    setRolesState: typeReducerForKey('rolesState'),
    resetRolesState: resetStateByKey('rolesState', { rolesState }),
};
const actions$3 = {
    loadRolesAndPermissions: createAction(`${authStoreName}/loadRoles`, (payload) => ({ payload })),
    addRole: createAction(`${authStoreName}/addRole`, (payload) => ({ payload })),
    updateRole: createAction(`${authStoreName}/updateRole`, (payload) => ({ payload })),
    deleteRole: createAction(`${authStoreName}/deleteRole`, (payload) => ({ payload })),
    attachPermissionsToRole: createAction(`${authStoreName}/attachPermissionsToRole`, (payload) => ({ payload })),
    attachPermissionToRoles: createAction(`${authStoreName}/attachPermissionToRoles`, (payload) => ({ payload })),
};

const sessionsState = {
    loading: false,
    sessions: [],
};
const reducers$1 = {
    setSessionsState: typeReducerForKey('sessionsState'),
    resetSessionsState: resetStateByKey('sessionsState', { sessionsState }),
};
const actions$2 = {
    loadUserSessions: createAction(`${authStoreName}/loadUserSessions`),
    loadCurrentUserSession: createAction(`${authStoreName}/loadCurrentUserSession`),
    deleteUserSession: createAction(`${authStoreName}/deleteUserSession`, (payload) => ({ payload })),
    deleteAllUserSessions: createAction(`${authStoreName}/deleteAllUserSessions`),
    revokeUserSessions: createAction(`${authStoreName}/revokeUserSessions`, (payload) => ({ payload })),
};

const sessionsPolicyState = {
    loading: false,
    configurations: {},
};
const reducers = {
    setSessionsPolicyState: typeReducerForKey('sessionsPolicyState'),
    resetSessionsPolicyState: resetStateByKey('sessionsPolicyState', { sessionsPolicyState }),
};
const actions$1 = {
    loadSessionsPolicy: createAction(`${authStoreName}/loadSessionsPolicy`),
    createOrUpdateSessionsPolicy: createAction(`${authStoreName}/createOrUpdateSessionsPolicy`, (payload) => ({ payload })),
};

const reinitializeState = {
    isAuthenticated: false,
    isLoading: true,
    isSSOAuth: false,
    user: null,
    signUpState,
    loginState,
    activateState,
    acceptInvitationState,
    forgotPasswordState,
    ssoState,
    profileState,
    mfaState,
    teamState,
    socialLoginState,
    apiTokensState,
    securityPolicyState,
    accountSettingsState,
    tenantsState,
    rolesState,
    resetPhoneNumberState,
    sessionsState,
    sessionsPolicyState,
};
const initialState = Object.assign({ routes: {
        authenticatedUrl: '/',
        loginUrl: '/account/login',
        logoutUrl: '/account/logout',
        activateUrl: '/account/activate',
        acceptInvitationUrl: '/account/invitation/accept',
        forgetPasswordUrl: '/account/forget-password',
        resetPhoneNumberUrl: '/account/reset-phone-number',
        resetPasswordUrl: '/account/reset-password',
        socialLoginCallbackUrl: '/account/social/success',
        signUpUrl: '/account/sign-up',
        oidcRedirectUrl: '/account/oidc/callback',
        samlCallbackUrl: '/account/saml/callback',
        magicLinkCallbackUrl: '/account/login/magic-link',
        hostedLoginRedirectUrl: '/oauth/callback'
    }, onRedirectTo: () => { } }, reinitializeState);

const { reducer, actions: sliceActions } = createSlice({
    name: authStoreName,
    initialState,
    reducers: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ resetState: (state) => (Object.assign(Object.assign({}, state), reinitializeState)), setState: (state, { payload }) => (Object.assign(Object.assign({}, state), payload)), setUser: typeReducer('user') }, reducers$h), reducers$8), reducers$g), reducers$f), reducers$e), reducers$d), reducers$7), reducers$b), reducers$c), reducers$a), reducers$9), reducers$6), reducers$5), reducers$4), reducers$3), reducers$2), reducers$1), reducers),
});
const actions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, sliceActions), actions$i), actions$9), actions$h), actions$g), actions$f), actions$e), actions$8), actions$c), actions$d), actions$b), actions$a), actions$7), actions$6), actions$5), actions$4), actions$3), actions$2), actions$1);

var SSOStateKeys;
(function (SSOStateKeys) {
    SSOStateKeys["LOAD_SSO_CONFIGURATIONS"] = "LOAD_SSO_CONFIGURATIONS";
    SSOStateKeys["SAVE_SSO_CONFIGURATION"] = "SAVE_SSO_CONFIGURATION";
    SSOStateKeys["UPDATE_SSO_CONFIGURATION"] = "UPDATE_SSO_CONFIGURATION";
    SSOStateKeys["SAVE_SSO_CONFIGURATION_BY_METADATA"] = "SAVE_SSO_CONFIGURATION_BY_METADATA";
    SSOStateKeys["UPDATE_SSO_CONFIGURATION_BY_METADATA"] = "UPDATE_SSO_CONFIGURATION";
    SSOStateKeys["DELETE_SSO_CONFIGURATION"] = "DELETE_SSO_CONFIGURATION";
    SSOStateKeys["SAVE_SSO_DOMAIN"] = "SAVE_SSO_DOMAIN";
    SSOStateKeys["DELETE_SSO_DOMAIN"] = "DELETE_SSO_DOMAIN";
    SSOStateKeys["VALIDATE_SSO_DOMAIN"] = "VALIDATE_SSO_DOMAIN";
    SSOStateKeys["UPDATE_SSO_DEFAULT_ROLES"] = "UPDATE_SSO_DEFAULT_ROLES";
    SSOStateKeys["DELETE_SSO_GROUPS"] = "DELETE_SSO_GROUPS";
    SSOStateKeys["SAVE_SSO_GROUPS"] = "SAVE_SSO_GROUPS";
    SSOStateKeys["GET_SSO_AUTHORIZATION_ROLES"] = "GET_SSO_AUTHORIZATION_ROLES";
})(SSOStateKeys || (SSOStateKeys = {}));
var SamlVendors;
(function (SamlVendors) {
    SamlVendors["Saml"] = "saml";
    SamlVendors["Okta"] = "okta";
    SamlVendors["Azure"] = "azure";
    SamlVendors["Google"] = "google";
    SamlVendors["Oidc"] = "oidc";
})(SamlVendors || (SamlVendors = {}));

function omitProps(props, keys) {
    const newProps = Object.assign({}, props);
    keys.forEach((key) => {
        delete newProps[key];
    });
    return newProps;
}
function generateCodeChallenge(codeVerifier) {
    return __awaiter(this, void 0, void 0, function* () {
        const digest = yield crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier));
        // @ts-ignore
        return btoa(String.fromCharCode(...new Uint8Array(digest)))
            .replace(/=/g, '')
            .replace(/\+/g, '-')
            .replace(/\//g, '_');
    });
}
function createRandomString(length = 16) {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < length; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
const readFileAsText = (file) => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsText(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
});

const apiTokensDataDemo = {
    clientId: 'CLIENT_ID_16806d3d-8fc3-4450-be97-abdaf66b723e',
    secret: 'SECRET_16806d3d-8fc3-4450-be97-abdaf66b723e',
    createdAt: 'createdAt',
    description: 'Demo API Token (preview only)',
};
const apiTokensDataTenantDemo = Object.assign(Object.assign({}, apiTokensDataDemo), { roleIds: [], tenantId: 'my-tenant-id', createdByUserId: 'createdByUserId' });
const roleDemo = [
    {
        id: 'roleId',
        key: 'admin',
        isDefault: false,
        name: 'Admin',
        description: null,
        permissions: ['adminPermissionId'],
        tenantId: 'tenantId',
        vendorId: 'vendorId',
        createdAt: new Date(),
        updatedAt: new Date(),
    },
];
const rolePermissionDemo = [
    {
        id: 'adminPermissionId',
        key: 'fe.*',
        name: 'General Admin',
        description: undefined,
        categoryId: 'category',
        fePermission: true,
        createdAt: new Date(),
        updatedAt: new Date(),
    },
];
const userProfileDemo = {
    id: 'testId',
    name: 'Demo User Name',
    email: 'demo-user@frontegg.com',
    mfaEnrolled: true,
    profileImage: undefined,
    profilePictureUrl: 'https://www.gravatar.com/avatar/42b2ad2bad6fc9b9db5086dfcf8072ac?d=https://ui-avatars.com/api/fe/128/random?t=1617261890875?t=1617261917434',
    roles: roleDemo,
    permissions: rolePermissionDemo,
    tenantId: 'my-tenant-id',
    tenantIds: ['my-tenant-id'],
    activatedForTenant: true,
    metadata: JSON.stringify({
        phoneNumber: '+972-54123456',
        jobTitle: 'Developer',
        address: {
            city: 'Tel Aviv',
            country: 'Israel',
        },
    }),
    roleIds: undefined,
    verified: undefined,
};
const userDemo = Object.assign(Object.assign({}, userProfileDemo), { accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1MTY5YmY0Zi02YmI5LTQ5NGMtOGNkZS05MDc4NDQ0NWY4MDciLCJuYW1lIjoiRHVtbXkgVXNlciIsImVtYWlsIjoiZHVtbXlAZnJvbnRlZ2cuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsIm1ldGFkYXRhIjp7fSwicm9sZXMiOlsiYWRtaW4iXSwicGVybWlzc2lvbnMiOlsiZmUuKiJdLCJ0ZW5hbnRJZCI6Im15LXRlbmFudC1pZCIsInRlbmFudElkcyI6WyJteS10ZW5hbnQtaWQiXSwicHJvZmlsZVBpY3R1cmVVcmwiOiJodHRwczovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyLzQyYjJhZDJiYWQ2ZmM5YjlkYjUwODZkZmNmODA3MmFjP2Q9aHR0cHM6Ly91aS1hdmF0YXJzLmNvbS9hcGkvZmUvMTI4L3JhbmRvbT90PTE2MTcyNjE4OTA4NzU_dD0xNjE3MjYxOTE3NDM0IiwidHlwZSI6InVzZXJUb2tlbiIsImlhdCI6MTYxNzkwNjMyNCwiZXhwIjoxNjE3OTkyNzI0LCJpc3MiOiJmcm9udGVnZyJ9.paaXLkpWEWbQmUtoK2P8IwXCxK4WJp7XhXonvzF8g1I', expiresIn: 86400, mfaRequired: false, refreshToken: 'refresh-token-dummy-de39dc9c-9d22-4852-b7f5-c3c0aa613b58', type: 'userToken', iat: 1617906324, exp: 1617992724, iss: 'frontegg', email_verified: true });
const profileStateDemo = {
    loading: false,
    error: undefined,
    saving: true,
    profile: userProfileDemo,
};
const policyDemo = {
    id: 'id',
    enforceMFAType: 'DontForce',
    createdAt: new Date(),
    updatedAt: new Date(),
    allowOverrideEnforcePasswordHistory: true,
    allowOverridePasswordComplexity: false,
    allowOverridePasswordExpiration: false,
    allowSignups: true,
    apiTokensEnabled: true,
    cookieSameSite: 'cookieSameSite',
    defaultRefreshTokenExpiration: 0,
    defaultTokenExpiration: 1,
    publicKey: 'publicKey',
};
const publicSecurityPolicy = {
    allowSignups: true,
    allowNotVerifiedUsersLogin: false,
    apiTokensEnabled: true,
    forcePermissions: false,
    authStrategy: AuthStrategyEnum.EmailAndPassword,
};
const policyMfaDemo = {
    id: 'id',
    enforceMFAType: 'DontForce',
    createdAt: new Date(),
    updatedAt: new Date(),
};
const policyLockoutDemo = {
    id: 'id',
    enabled: true,
    maxAttempts: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
};
const policyPasswordHistoryDemo = {
    id: 'id',
    enabled: true,
    historySize: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
};
const samlConfigurationDemo = {
    enabled: true,
    domain: 'domain',
    validated: true,
    generatedVerification: 'generatedVerification',
    ssoEndpoint: 'ssoEndpoint',
    publicCertificate: 'publicCertificate',
    signRequest: true,
    createdAt: new Date(),
    updatedAt: new Date(),
    acsUrl: undefined,
    spEntityId: undefined,
    oidcClientId: undefined,
    oidcSecret: undefined,
    type: undefined,
};
const samlMetadataDemo = {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    properties: [],
    vendorId: 'vendorId',
    entityName: 'saml',
    isActive: true,
    configuration: {
        acsUrl: 'acsUrl',
        spEntityId: 'spEntityId',
    },
};
const rolesDemo = [
    {
        id: 'id',
        description: 'description',
        key: 'key',
        name: 'name',
        permissions: [],
        permissionLevel: 1,
    },
];
const ssoStateDemo = {
    firstLoad: false,
    loading: false,
    error: undefined,
    saving: false,
    samlConfiguration: samlConfigurationDemo,
    roles: rolesDemo,
    authorizationRoles: [],
    errors: {},
    loaders: {},
    ssoConfigurations: [],
};
const permissionsDemo = [
    {
        description: 'string',
        fePermission: true,
        id: 'id',
        key: 'key',
        name: 'name',
        roleIds: [],
        createdAt: new Date(),
        updatedAt: new Date(),
        categoryId: 'categoryId',
    },
];
const userTeamDemo2 = {
    id: 'id2',
    email: 'demo-user2@frontegg.com',
    name: 'Demo User Name2',
    phone: undefined,
    profileImage: undefined,
    profileImageUrl: undefined,
    tenantId: 'tenantId',
    vendorId: 'vendorId',
    roleIds: [],
    activatedForTenant: true,
    verified: false,
    createdAt: new Date().toISOString(),
    customData: undefined,
    lastLogin: undefined,
    mfaEnabled: undefined,
    roles: [],
}; // TODO add verified to ITeamUser
const userTeamDemo = {
    id: 'id',
    email: 'demo-user@frontegg.com',
    name: 'Demo User Name',
    phone: undefined,
    profileImage: undefined,
    profileImageUrl: undefined,
    tenantId: 'tenantId',
    vendorId: 'vendorId',
    roleIds: [],
    activatedForTenant: true,
    createdAt: new Date(2022, 4, 1).toISOString(),
    verified: true,
    customData: undefined,
    lastLogin: new Date(2022, 5, 25).toISOString(),
    mfaEnabled: undefined,
    roles: [],
};
const userSubTenantDemo = {
    metadata: '',
    mfaEnrolled: false,
    provider: '',
    sub: '',
    tenantIds: [],
    tenants: [],
    verified: false,
    id: 'id',
    email: 'email',
    name: 'name',
    tenantId: 'tenantId',
    createdAt: new Date(),
};
const usersDemo = [userTeamDemo, userTeamDemo2];
const allUsersDemo = [userSubTenantDemo];
const tenantsDemo = [
    {
        id: 'my-tenant-id',
        isReseller: false,
        name: 'Frontegg demo',
        deletedAt: null,
        metadata: undefined,
        tenantId: 'my-tenant-id',
        vendorId: 'vendorId',
        createdAt: new Date(),
        updatedAt: new Date(),
        address: undefined,
        timezone: undefined,
        dateFormat: undefined,
        timeFormat: undefined,
        currency: undefined,
        logo: undefined,
    },
];
const sessionsMock = [
    {
        id: `laptop`,
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
        createdAt: new Date(),
        ipAddress: "190.194.88.251",
        current: true,
    },
    {
        id: `iphone`,
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_2_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Mobile/15E148 Safari/604.1",
        createdAt: new Date(Date.now() - 10000),
        ipAddress: "191.49.203.21",
    },
    {
        id: `tablet`,
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; SGP771 Build/32.2.A.0.253; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/52.0.2743.98 Safari/537.36",
        createdAt: new Date(Date.now() - 30000),
        ipAddress: "130.19.196.136",
    },
    {
        id: `anotherlaptop`,
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
        createdAt: new Date(Date.now() - 1002232300),
        ipAddress: "2.228.163.92",
    }
];
const sessionsConfigDummies = {
    sessionConcurrentConfiguration: {
        isActive: true,
        maxSessions: 10,
    },
    sessionIdleTimeoutConfiguration: {
        isActive: true,
        timeout: 300
    },
    sessionTimeoutConfiguration: {
        isActive: true,
        timeout: 86400
    },
};

var UserVeirifedOriginTypes;
(function (UserVeirifedOriginTypes) {
    UserVeirifedOriginTypes["SOCIAL_LOGIN"] = "SOCIAL_LOGIN";
    UserVeirifedOriginTypes["PASSWORDLESS"] = "PASSWORDLESS";
    UserVeirifedOriginTypes["ACTIVATION_LINK"] = "ACTIVATION_LINK";
})(UserVeirifedOriginTypes || (UserVeirifedOriginTypes = {}));
var AuthenticationTypes;
(function (AuthenticationTypes) {
    AuthenticationTypes["SOCIAL_LOGIN"] = "SOCIAL_LOGIN";
    AuthenticationTypes["PASSWORD"] = "PASSWORD";
})(AuthenticationTypes || (AuthenticationTypes = {}));
var AdminPortalPagesForEvents;
(function (AdminPortalPagesForEvents) {
    AdminPortalPagesForEvents["profile"] = "profile";
    AdminPortalPagesForEvents["privacy"] = "privacy";
    AdminPortalPagesForEvents["personalApiTokens"] = "personalApiTokens";
    AdminPortalPagesForEvents["account"] = "account";
    AdminPortalPagesForEvents["users"] = "users";
    AdminPortalPagesForEvents["security"] = "security";
    AdminPortalPagesForEvents["sso"] = "sso";
    AdminPortalPagesForEvents["audits"] = "audits";
    AdminPortalPagesForEvents["webhooks"] = "webhooks";
    AdminPortalPagesForEvents["apiTokens"] = "apiTokens";
    AdminPortalPagesForEvents["roles"] = "roles";
    AdminPortalPagesForEvents["subscriptions"] = "subscription";
})(AdminPortalPagesForEvents || (AdminPortalPagesForEvents = {}));
const AdminPortalPages = {
    profile: AdminPortalPagesForEvents.profile,
    privacy: AdminPortalPagesForEvents.privacy,
    personalApiTokens: AdminPortalPagesForEvents.personalApiTokens,
    account: AdminPortalPagesForEvents.account,
    users: AdminPortalPagesForEvents.users,
    security: AdminPortalPagesForEvents.security,
    sso: AdminPortalPagesForEvents.sso,
    audits: AdminPortalPagesForEvents.audits,
    webhooks: AdminPortalPagesForEvents.webhooks,
    apiTokens: AdminPortalPagesForEvents.apiTokens,
    roles: AdminPortalPagesForEvents.roles,
    subscriptions: AdminPortalPagesForEvents.subscriptions,
};

function* loadAllowSignUps() {
    yield put(actions.setSignUpState({ loading: true }));
    try {
        const policy = yield call(api.auth.getVendorConfig);
        const { allowSignups: allowSignUps, allowNotVerifiedUsersLogin } = policy;
        yield put(actions.setSignUpState({ loading: false, allowSignUps, allowNotVerifiedUsersLogin, firstLoad: false }));
        yield put(actions.setSecurityPolicyPublicState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSignUpState({ loading: false, error: e.message, firstLoad: false }));
    }
}
function* signUpUser(_a) {
    var _b;
    var _c = _a.payload, { events, url } = _c, payload = __rest(_c, ["events", "url"]);
    yield put(actions.setSignUpState({ loading: true }));
    try {
        const { routes, onRedirectTo } = yield select((state) => state.auth);
        const { shouldActivate, user, tenantId, userId } = yield call(api.auth.signUpUser, payload);
        if (!payload.invitationToken) {
            const { email, name, companyName } = payload;
            (_b = events === null || events === void 0 ? void 0 : events.signUpComplete) === null || _b === void 0 ? void 0 : _b.call(events, {
                email,
                name,
                companyName,
                url,
                authenticationType: AuthenticationTypes.PASSWORD,
                id: userId,
                tenantId,
                createdAt: new Date(),
            });
        }
        ContextHolder.setAccessToken(user === null || user === void 0 ? void 0 : user.accessToken);
        ContextHolder.setUser(user);
        if (!shouldActivate && (user === null || user === void 0 ? void 0 : user.mfaRequired) && (user === null || user === void 0 ? void 0 : user.mfaToken)) {
            let step = LoginStep.loginWithTwoFactor;
            if (user.hasOwnProperty('mfaEnrolled') && !user.mfaEnrolled) {
                yield put(actions.setMfaState({
                    step: MFAStep.verify,
                    qrCode: user.qrCode,
                    recoveryCode: user.recoveryCode,
                    mfaToken: user.mfaToken,
                    loading: false,
                }));
                step = LoginStep.forceTwoFactor;
            }
            yield put(actions.setLoginState({ step }));
            onRedirectTo(routes.loginUrl);
        }
        else {
            yield put(actions.setSignUpState({ loading: false, shouldActivate, stage: SignUpStage.SignUpSuccess }));
            yield put(actions.setState({
                user,
                isAuthenticated: !!(user === null || user === void 0 ? void 0 : user.accessToken),
            }));
            if (!shouldActivate) {
                yield put(actions.loadTenants());
            }
        }
    }
    catch (e) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        yield put(actions.setSignUpState({ loading: false, error: e.message }));
    }
    yield put(actions.setSignUpState({ loading: false }));
}
function* resetSignUpStateSoft() {
    const { allowSignUps, allowNotVerifiedUsersLogin } = yield select((state) => state.auth.signUpState);
    yield put(actions.resetSignUpState());
    yield put(actions.setSignUpState({ allowSignUps, allowNotVerifiedUsersLogin }));
}
function* signUpSaga() {
    yield takeLeading(actions.signUpUser, signUpUser);
    yield takeLeading(actions.resetSignUpStateSoft, resetSignUpStateSoft);
}

function* loadSecurityPolicy() {
    yield put(actions.setSecurityPolicyGlobalState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getGlobalSecurityPolicy);
        yield put(actions.setSecurityPolicyGlobalState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyGlobalState({ error: e.message, loading: false }));
    }
    yield put(actions.loadSecurityPolicyMfa());
    yield put(actions.loadSecurityPolicyVendorMfa());
    yield put(actions.loadSecurityPolicyLockout());
    yield put(actions.loadSecurityPolicyCaptcha());
    yield put(actions.loadPublicAuthStrategiesPolicy());
}
function* loadPublicSecurityPolicy() {
    yield put(actions.setSecurityPolicyPublicState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getVendorConfig);
        yield put(actions.setSecurityPolicyPublicState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyPublicState({ error: e.message, loading: false }));
    }
}
function* loadPublicAuthStrategiesPolicy() {
    yield put(actions.setSecurityPolicyAuthStrategyPublicState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getVendorPublicAuthStrategiesConfig);
        yield put(actions.setSecurityPolicyAuthStrategyPublicState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyAuthStrategyPublicState({ error: e.message, loading: false }));
    }
}
function* loadSecurityPolicyMfa() {
    yield put(actions.setSecurityPolicyMfaState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getMfaPolicy);
        yield put(actions.setSecurityPolicyMfaState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyMfaState({ error: e.message, loading: false }));
    }
}
function* loadSecurityPolicyVendorMfa() {
    yield put(actions.setSecurityPolicyMfaState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getVendorMfaPolicy);
        yield put(actions.setSecurityPolicyVendorMfaState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyVendorMfaState({ error: e.message, loading: false }));
    }
}
function* saveSecurityPolicyMfa(_a) {
    var _b = _a.payload, { callback } = _b, newSecurityPolicy = __rest(_b, ["callback"]);
    yield put(actions.setSecurityPolicyMfaState({ saving: true, error: null }));
    try {
        const policy = yield call(api.auth.saveMfaPolicy, newSecurityPolicy);
        yield put(actions.setSecurityPolicyMfaState({ policy, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(policy);
    }
    catch (e) {
        yield put(actions.setSecurityPolicyMfaState({ saving: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* loadSecurityPolicyLockout() {
    yield put(actions.setSecurityPolicyLockoutState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getLockoutPolicy);
        yield put(actions.setSecurityPolicyLockoutState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyLockoutState({ error: e.message, loading: false }));
    }
}
function* saveSecurityPolicyLockout(_a) {
    var _b = _a.payload, { callback } = _b, newSecurityPolicy = __rest(_b, ["callback"]);
    yield put(actions.setSecurityPolicyLockoutState({ saving: true, error: null }));
    try {
        const policy = yield call(api.auth.saveLockoutPolicy, newSecurityPolicy);
        yield put(actions.setSecurityPolicyLockoutState({ policy, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(policy);
    }
    catch (e) {
        yield put(actions.setSecurityPolicyLockoutState({ saving: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* loadSecurityPolicyCaptcha() {
    yield put(actions.setSecurityPolicyLockoutState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getCaptchaPolicy);
        yield put(actions.setSecurityPolicyCaptchaState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyCaptchaState({ error: e.message, loading: false }));
    }
}
function* loadSecurityPolicyPasswordHistory() {
    yield put(actions.setSecurityPolicyPasswordHistoryState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getPasswordHistoryPolicy);
        yield put(actions.setSecurityPolicyPasswordHistoryState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyPasswordHistoryState({ error: e.message, loading: false }));
    }
}
function* saveSecurityPolicyPasswordHistory(_a) {
    var _b = _a.payload, { callback } = _b, newSecurityPolicy = __rest(_b, ["callback"]);
    yield put(actions.setSecurityPolicyPasswordHistoryState({ saving: true, error: null }));
    try {
        const policy = yield call(api.auth.savePasswordHistoryPolicy, newSecurityPolicy);
        yield put(actions.setSecurityPolicyPasswordHistoryState({ policy, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(policy);
    }
    catch (e) {
        yield put(actions.setSecurityPolicyPasswordHistoryState({ saving: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* loadVendorPasswordConfig() {
    yield put(actions.setSecurityPolicyPasswordState({ loading: true, error: null }));
    try {
        const policy = yield call(api.auth.getPasswordConfigPolicy);
        yield put(actions.setSecurityPolicyPasswordState({ policy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyPasswordState({ error: e.message, loading: false }));
    }
}
function* securityPolicySagas() {
    yield takeLeading(actions.loadSecurityPolicy, loadSecurityPolicy);
    yield takeEvery(actions.saveSecurityPolicyMfa, saveSecurityPolicyMfa);
    yield takeEvery(actions.loadSecurityPolicyMfa, loadSecurityPolicyMfa);
    yield takeEvery(actions.loadSecurityPolicyVendorMfa, loadSecurityPolicyVendorMfa);
    yield takeEvery(actions.saveSecurityPolicyLockout, saveSecurityPolicyLockout);
    yield takeEvery(actions.loadSecurityPolicyLockout, loadSecurityPolicyLockout);
    yield takeEvery(actions.loadSecurityPolicyCaptcha, loadSecurityPolicyCaptcha);
    yield takeEvery(actions.saveSecurityPolicyPasswordHistory, saveSecurityPolicyPasswordHistory);
    yield takeEvery(actions.loadSecurityPolicyPasswordHistory, loadSecurityPolicyPasswordHistory);
    yield takeEvery(actions.loadVendorPasswordConfig, loadVendorPasswordConfig);
    yield takeEvery(actions.loadPublicSecurityPolicy, loadPublicSecurityPolicy);
    yield takeEvery(actions.loadPublicAuthStrategiesPolicy, loadPublicAuthStrategiesPolicy);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* loadPublicSecurityPolicyMock() {
    yield put(actions.setSecurityPolicyPublicState({ loading: true, error: null }));
    try {
        yield put(actions.setSecurityPolicyPublicState({ policy: publicSecurityPolicy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSecurityPolicyPublicState({ error: e.message, loading: false }));
    }
}
function* loadSecurityPolicyMock() {
    yield put(actions.setSecurityPolicyGlobalState({ loading: true, error: null }));
    yield delay();
    yield put(actions.setSecurityPolicyGlobalState({ policy: policyDemo, loading: false }));
    yield put(actions.loadSecurityPolicyMfa());
    yield put(actions.loadSecurityPolicyVendorMfa());
    yield put(actions.loadSecurityPolicyLockout());
    yield put(actions.loadSecurityPolicyCaptcha());
}
function* loadSecurityPolicyMfaMock() {
    yield put(actions.setSecurityPolicyMfaState({ loading: true, error: null }));
    yield delay();
    yield put(actions.setSecurityPolicyMfaState({ policy: policyMfaDemo, loading: false }));
}
function* loadSecurityPolicyVendorMfaMock() {
    yield put(actions.setSecurityPolicyVendorMfaState({ loading: true, error: null }));
    yield delay();
    yield put(actions.setSecurityPolicyVendorMfaState({ policy: policyMfaDemo, loading: false }));
}
function* saveSecurityPolicyMfaMock(_a) {
    var _b;
    var _c = _a.payload, { callback } = _c, newSecurityPolicy = __rest(_c, ["callback"]);
    yield put(actions.setSecurityPolicyMfaState({ saving: true, error: null }));
    const policy = Object.assign(Object.assign({}, policyLockoutDemo), { id: (_b = newSecurityPolicy.id) !== null && _b !== void 0 ? _b : policyLockoutDemo.id, enforceMFAType: newSecurityPolicy.enforceMFAType });
    yield delay();
    yield put(actions.setSecurityPolicyMfaState({ policy, saving: false }));
    callback === null || callback === void 0 ? void 0 : callback(policy);
}
function* loadSecurityPolicyLockoutMock() {
    yield put(actions.setSecurityPolicyLockoutState({ loading: true, error: null }));
    yield delay();
    yield put(actions.setSecurityPolicyLockoutState({ policy: policyLockoutDemo, loading: false }));
}
function* saveSecurityPolicyLockoutMock(_a) {
    var _b = _a.payload, { callback } = _b, newSecurityPolicy = __rest(_b, ["callback"]);
    yield put(actions.setSecurityPolicyLockoutState({ saving: true, error: null }));
    yield delay();
    const policy = Object.assign(Object.assign(Object.assign({}, newSecurityPolicy), policyLockoutDemo), { id: newSecurityPolicy.id ? newSecurityPolicy.id : policyLockoutDemo.id });
    callback === null || callback === void 0 ? void 0 : callback(policy);
    yield put(actions.setSecurityPolicyLockoutState({ policy, saving: false }));
}
function* loadSecurityPolicyCaptchaMock() {
    yield put(actions.setSecurityPolicyLockoutState({ loading: true, error: null }));
    yield delay();
    yield put(actions.setSecurityPolicyLockoutState({ policy: policyLockoutDemo, loading: false }));
}
function* loadSecurityPolicyPasswordHistoryMock() {
    yield put(actions.setSecurityPolicyPasswordHistoryState({ loading: true, error: null }));
    yield delay();
    yield put(actions.setSecurityPolicyPasswordHistoryState({ policy: policyPasswordHistoryDemo, loading: false }));
}
function* saveSecurityPolicyPasswordHistoryMock(_a) {
    var _b = _a.payload, { callback } = _b, newSecurityPolicy = __rest(_b, ["callback"]);
    yield put(actions.setSecurityPolicyPasswordHistoryState({ saving: true, error: null }));
    yield delay();
    const policy = Object.assign(Object.assign(Object.assign({}, newSecurityPolicy), policyPasswordHistoryDemo), { id: newSecurityPolicy.id ? newSecurityPolicy.id : policyPasswordHistoryDemo.id });
    callback === null || callback === void 0 ? void 0 : callback(policy);
    yield put(actions.setSecurityPolicyPasswordHistoryState({ policy, saving: false }));
}
function* securityPolicySagasMock() {
    yield takeLeading(actions.loadSecurityPolicy, loadSecurityPolicyMock);
    yield takeEvery(actions.loadPublicSecurityPolicy, loadPublicSecurityPolicyMock);
    yield takeEvery(actions.saveSecurityPolicyMfa, saveSecurityPolicyMfaMock);
    yield takeEvery(actions.loadSecurityPolicyMfa, loadSecurityPolicyMfaMock);
    yield takeEvery(actions.loadSecurityPolicyVendorMfa, loadSecurityPolicyVendorMfaMock);
    yield takeEvery(actions.saveSecurityPolicyLockout, saveSecurityPolicyLockoutMock);
    yield takeEvery(actions.loadSecurityPolicyLockout, loadSecurityPolicyLockoutMock);
    yield takeEvery(actions.loadSecurityPolicyCaptcha, loadSecurityPolicyCaptchaMock);
    yield takeEvery(actions.saveSecurityPolicyPasswordHistory, saveSecurityPolicyPasswordHistoryMock);
    yield takeEvery(actions.loadSecurityPolicyPasswordHistory, loadSecurityPolicyPasswordHistoryMock);
}

const authStrategyLoginStepMap = {
    [AuthStrategyEnum.Code]: LoginStep.loginWithOtc,
    [AuthStrategyEnum.EmailAndPassword]: LoginStep.loginWithPassword,
    [AuthStrategyEnum.MagicLink]: LoginStep.magicLinkPreLoginSuccess,
    [AuthStrategyEnum.SmsCode]: LoginStep.loginWithSmsOtc,
};
function* afterAuthNavigation() {
    var _a;
    const onRedirectTo = ContextHolder.onRedirectTo;
    const { routes, includeQueryParam } = yield select((state) => state.auth);
    const { loginUrl, logoutUrl, socialLoginCallbackUrl, activateUrl } = routes;
    let { authenticatedUrl } = routes;
    const afterAuthRedirect = window.localStorage.getItem(FRONTEGG_AFTER_AUTH_REDIRECT_URL);
    if (afterAuthRedirect && ![loginUrl, logoutUrl, socialLoginCallbackUrl, activateUrl].includes(afterAuthRedirect)) {
        authenticatedUrl = afterAuthRedirect;
    }
    window.localStorage.removeItem(FRONTEGG_AFTER_AUTH_REDIRECT_URL);
    yield delay$1(200);
    put(actions.resetLoginState());
    const url = new URL(window === null || window === void 0 ? void 0 : window.location.href);
    let redirectUrl = authenticatedUrl;
    if (url.searchParams.get('redirectUrl')) {
        redirectUrl = (_a = url.searchParams.get('redirectUrl')) !== null && _a !== void 0 ? _a : authenticatedUrl;
    }
    else if (includeQueryParam) {
        redirectUrl += window.location.search;
    }
    onRedirectTo(redirectUrl, { refresh: redirectUrl.startsWith('http') });
}
function* refreshMetadata() {
    var _a;
    let ssoACS;
    try {
        const metadata = yield call(api.metadata.getSamlMetadata);
        ssoACS = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.configuration) === null || _a === void 0 ? void 0 : _a.acsUrl;
    }
    catch (e) {
        console.error(e);
    }
    yield put(actions.setState({ ssoACS }));
}
function* loadSSOPublicConfigurationFunction() {
    try {
        const { isActive } = yield call(api.auth.getSSOPublicConfiguration);
        yield put(actions.setState({ isSSOAuth: isActive }));
    }
    catch (e) {
        console.error(e);
    }
}
const isMfaRequired = (user) => {
    if (user.mfaRequired && user.mfaToken) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        return true;
    }
    else {
        ContextHolder.setAccessToken(user.accessToken);
        ContextHolder.setUser(user);
        return false;
    }
};
function* getMfaRequiredState(user) {
    let setMfaState = {};
    let step = LoginStep.loginWithTwoFactor;
    const { loginState } = yield select((state) => state.auth);
    const { isAllowedToRemember, mfaDeviceExpiration } = yield call(api.auth.checkIfAllowToRememberMfaDevice, user.mfaToken);
    if (user.hasOwnProperty('mfaEnrolled') && !user.mfaEnrolled) {
        setMfaState = {
            mfaState: {
                step: MFAStep.verify,
                qrCode: user.qrCode,
                recoveryCode: user.recoveryCode,
                loading: false,
                mfaToken: user.mfaToken,
            },
        };
        step = LoginStep.forceTwoFactor;
    }
    let quickLoginState = {};
    const quickLoginToRegister = localStorage.getItem('register-quick-login');
    if (quickLoginToRegister) {
        quickLoginState = {
            quickLoginToRegister,
            flow: LoginFlow.RegisterQuickLogin
        };
    }
    return Object.assign(Object.assign({ user: undefined, isAuthenticated: false }, setMfaState), { loginState: Object.assign(Object.assign(Object.assign({}, loginState), quickLoginState), { mfaToken: user.mfaToken, mfaRequired: user.mfaRequired, loading: false, error: undefined, step, tenantsLoading: true, email: user.userEmail, tenants: [], allowRememberMfaDevice: isAllowedToRemember, mfaDeviceExpiration }) });
}
function* refreshToken() {
    const { hostedLoginBox } = yield select((state) => state.auth);
    if (hostedLoginBox) {
        yield call(refreshTokenHosted);
    }
    else {
        yield call(refreshTokenEmbedded);
    }
}
function* refreshTokenHosted() {
    const { user } = yield select((state) => state.auth);
    if (!(user === null || user === void 0 ? void 0 : user.refreshToken)) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        yield put(actions.setState({ isAuthenticated: false }));
        return;
    }
    try {
        const body = {
            grant_type: 'refresh_token',
            refresh_token: user === null || user === void 0 ? void 0 : user.refreshToken
        };
        const authenticatedUser = yield call(api.auth.exchangeOAuthTokens, body);
        yield put(actions.setState({ user: authenticatedUser, isAuthenticated: true }));
        yield put(actions.loadTenants());
    }
    catch (e) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        yield put(actions.setState({ isAuthenticated: false }));
    }
}
function* refreshTokenEmbedded() {
    var _a;
    try {
        const onRedirectTo = ContextHolder.onRedirectTo;
        const { routes, loginState } = yield select((state) => state.auth);
        const { user, tenants } = yield call(api.auth.refreshTokenV2);
        if (isMfaRequired(user)) {
            const mfaRequiredState = yield getMfaRequiredState(user);
            yield put(actions.setState(mfaRequiredState));
            onRedirectTo(routes.loginUrl, { preserveQueryParams: true });
        }
        else {
            if (user.email) {
                localStorage.setItem('email', user.email);
                localStorage.setItem('name', user.name);
            }
            const quickLoginToRegister = (_a = localStorage.getItem('register-quick-login')) !== null && _a !== void 0 ? _a : loginState.quickLoginToRegister;
            const shouldNavigateToRegisterQuicKLogin = quickLoginToRegister && localStorage.getItem(`${user.email}-${quickLoginToRegister}`) !== 'true' && !window.location.pathname.endsWith(routes.logoutUrl);
            yield put(actions.setTenantsState({ tenants, loading: false }));
            yield put(actions.setState({
                user,
                isAuthenticated: true,
                loginState: Object.assign(Object.assign({}, loginState), { quickLoginToRegister, flow: shouldNavigateToRegisterQuicKLogin ? LoginFlow.RegisterQuickLogin : LoginFlow.Login })
            }));
            if (shouldNavigateToRegisterQuicKLogin) {
                onRedirectTo(routes.loginUrl);
            }
            else if ([routes.loginUrl, routes.socialLoginCallbackUrl, routes.signUpUrl, routes.oidcRedirectUrl, routes.samlCallbackUrl]
                .some(url => url && window.location.pathname.endsWith(url))) {
                if (loginState.isNewUser && routes.signUpSuccessUrl && routes.socialLoginCallbackUrl === window.location.pathname) {
                    onRedirectTo(routes.signUpSuccessUrl, { refresh: routes.signUpSuccessUrl.startsWith('http') });
                }
                else {
                    yield afterAuthNavigation();
                }
            }
        }
    }
    catch (e) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        yield put(actions.setState({ user: undefined, isAuthenticated: false }));
    }
}
function* requestAuthorize({ payload: firstTime }) {
    const calls = [];
    if (firstTime) {
        yield put(actions.setState({ isLoading: true }));
        yield put(actions.loadSocialLoginsConfigurationV2());
        calls.push(call(loadAllowSignUps));
        calls.push(call(loadPublicAuthStrategiesPolicy));
        calls.push(call(loadSSOPublicConfigurationFunction));
        calls.push(call(loadVendorPublicInfo));
        calls.push(call(refreshMetadata));
    }
    calls.push(call(refreshToken));
    yield all(calls);
    yield put(actions.setState({ isLoading: false }));
}
function* refreshTokenSSR(accessToken) {
    if (!accessToken) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        yield put(actions.setState({ user: undefined, isAuthenticated: false }));
        return;
    }
    try {
        const onRedirectTo = ContextHolder.onRedirectTo;
        const { routes } = yield select((state) => state.auth);
        const { user, tenants } = yield call(api.auth.generateLoginResponseV2, { accessToken });
        if (isMfaRequired(user)) {
            const mfaRequiredState = yield getMfaRequiredState(user);
            yield put(actions.setState(mfaRequiredState));
            onRedirectTo(routes.loginUrl, { preserveQueryParams: true });
        }
        else {
            yield put(actions.setTenantsState({ tenants, loading: false }));
            yield put(actions.setState({ user, isAuthenticated: true }));
        }
    }
    catch (e) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        yield put(actions.setState({ user: undefined, isAuthenticated: false }));
    }
}
function* requestAuthorizeSSR({ payload: accessToken }) {
    const calls = [];
    yield put(actions.setState({ isLoading: true }));
    yield put(actions.loadSocialLoginsConfigurationV2());
    calls.push(call(loadAllowSignUps));
    calls.push(call(loadSSOPublicConfigurationFunction));
    calls.push(call(loadVendorPublicInfo));
    calls.push(call(refreshMetadata));
    calls.push(call(refreshTokenSSR, accessToken));
    yield all(calls);
    yield put(actions.setState({ isLoading: false }));
}
function* requestHostedLoginAuthorize() {
    const { routes, context, onRedirectTo } = yield select((state) => ({
        routes: state.auth.routes,
        onRedirectTo: state.auth.onRedirectTo,
        context: state.root.context,
    }));
    // Generate the relevant params for the redirect
    const nonce = createRandomString();
    const code_verifier = createRandomString();
    const code_challenge = yield call(generateCodeChallenge, code_verifier);
    // We are saving the verifier in session storage to be able to validate the response
    localStorage.setItem(HOSTED_LOGIN_VERIFIER_KEY, code_verifier);
    const redirectUrl = `${window.location.origin}${routes.hostedLoginRedirectUrl}`;
    const baseUrl = fetch.getBaseUrl(context, '/oauth/authorize');
    // Hard coded for now
    const oauthUrl = `${baseUrl}/oauth/authorize`;
    const params = {
        response_type: 'code',
        client_id: context.clientId || 'INVALID-CLIENT-ID',
        scope: 'openid email profile',
        redirect_uri: redirectUrl,
        code_challenge: code_challenge,
        code_challenge_method: 'S256',
        nonce,
    };
    const searchParams = new URLSearchParams(params);
    const url = `${oauthUrl}?${searchParams.toString()}`;
    onRedirectTo(url, { refresh: true });
}
function* handleHostedLoginCallback({ payload }) {
    // Hard coded for now
    const code_verifier = localStorage.getItem(HOSTED_LOGIN_VERIFIER_KEY) || 'INVALID-CODE-VERIFIER';
    const routes = yield select((state) => state.auth.routes);
    const redirectUrl = `${window.location.origin}${routes.hostedLoginRedirectUrl}`;
    const body = {
        code: payload.code,
        redirect_uri: redirectUrl,
        code_verifier,
        grant_type: 'authorization_code',
    };
    const user = yield call(api.auth.exchangeOAuthTokens, body);
    // TODO: Validate nonce and aud
    yield put(actions.setState({ user, isAuthenticated: true }));
    yield put(actions.loadTenants());
    yield afterAuthNavigation();
}
function* changePhoneNumberWithVerification(_a) {
    var _b = _a.payload, { callback } = _b, payload = __rest(_b, ["callback"]);
    try {
        yield put(actions.setLoginState({ loading: true }));
        const changePhoneRes = yield call(api.auth.changePhoneNumberWithVerification, payload);
        yield put(actions.setLoginState({ phoneNumber: payload.phoneNumber, loading: false, changePhoneId: changePhoneRes.changePhoneId, step: LoginStep.loginWithQuickSmsOtc, error: undefined }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message, loading: false }));
    }
}
function* verifyChangePhoneNumber(_a) {
    var _b = _a.payload, { callback } = _b, payload = __rest(_b, ["callback"]);
    try {
        yield put(actions.setLoginState({ loading: true }));
        yield call(api.auth.verifyChangePhoneNumber, payload);
        yield put(actions.setLoginState({ loading: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message, loading: false }));
    }
}
function* quickSmsPasswordlessPreLogin(_a) {
    var _b = _a.payload, { callback } = _b, payload = __rest(_b, ["callback"]);
    try {
        yield put(actions.setLoginState({ loading: true }));
        const preloginRes = yield call(api.auth.passwordlessPreLogin, Object.assign(Object.assign({}, payload), { type: AuthStrategyEnum.SmsCode }));
        yield put(actions.setLoginState({
            step: LoginStep.loginWithQuickSmsOtc,
            loading: false,
            email: payload.email,
            phoneNumber: preloginRes === null || preloginRes === void 0 ? void 0 : preloginRes.phoneNumber,
            error: undefined,
        }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message, loading: false }));
        callback === null || callback === void 0 ? void 0 : callback(e);
    }
}
function* passwordlessPreLogin(_a) {
    var _b = _a.payload, { callback } = _b, payload = __rest(_b, ["callback"]);
    try {
        const { onRedirectTo, routes } = yield select(({ auth: { onRedirectTo, routes } }) => ({ onRedirectTo, routes }));
        yield put(actions.setLoginState({ loading: true }));
        const preloginRes = yield call(api.auth.passwordlessPreLogin, payload);
        const step = authStrategyLoginStepMap[payload.type];
        if (step === LoginStep.loginWithSmsOtc && preloginRes.resetPhoneNumberToken) {
            yield put(actions.setResetPhoneNumberState({
                resetPhoneNumberToken: preloginRes.resetPhoneNumberToken,
                step: ResetPhoneNumberStep.VerifyResetPhoneNumber,
            }));
            onRedirectTo(routes.resetPhoneNumberUrl);
            return;
        }
        yield put(actions.setLoginState({
            step,
            loading: false,
            email: payload.email,
            phoneNumber: preloginRes === null || preloginRes === void 0 ? void 0 : preloginRes.phoneNumber,
            error: undefined
        }));
        callback === null || callback === void 0 ? void 0 : callback();
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message, loading: false }));
        callback === null || callback === void 0 ? void 0 : callback();
    }
}
function* passwordlessPostLogin(_a) {
    var _b, _c;
    var _d = _a.payload, { callback, events } = _d, payload = __rest(_d, ["callback", "events"]);
    try {
        yield put(actions.setLoginState({ loading: true }));
        const data = yield call(api.auth.passwordlessPostLogin, payload);
        const onRedirectTo = ContextHolder.onRedirectTo;
        const { routes } = yield select((state) => state.auth);
        if (isMfaRequired(data)) {
            const mfaRequiredState = yield getMfaRequiredState(data);
            yield put(actions.setState(mfaRequiredState));
            onRedirectTo(routes.loginUrl, { preserveQueryParams: true });
        }
        else {
            const { loginState } = yield select((state) => state.auth);
            const user = yield call(api.auth.generateLoginResponse, data);
            if (data.emailVerified) {
                (_b = events === null || events === void 0 ? void 0 : events.userVerified) === null || _b === void 0 ? void 0 : _b.call(events, {
                    email: user.email,
                    origin: UserVeirifedOriginTypes.PASSWORDLESS,
                    id: user.id,
                    tenantId: user.tenantId,
                    createdAt: new Date(),
                    name: user.name,
                });
            }
            if (user.email) {
                localStorage.setItem('email', user.email);
                localStorage.setItem('name', user.name);
            }
            yield put(actions.setState({ user, isAuthenticated: true }));
            yield put(actions.setLoginState({ error: undefined }));
            yield put(actions.loadTenants());
            if (loginState.flow === LoginFlow.Login) {
                yield afterAuthNavigation();
            }
            else {
                onRedirectTo(routes.loginUrl, { preserveQueryParams: true });
            }
            localStorage.removeItem('register-quick-login');
            callback === null || callback === void 0 ? void 0 : callback(true);
        }
    }
    catch (e) {
        yield put(actions.setLoginState({ error: (_c = e.message) !== null && _c !== void 0 ? _c : 'Failed to authenticate' }));
    }
    finally {
        yield put(actions.setLoginState({ loading: false }));
    }
}
function* verifyInviteToken({ payload }) {
    var _a;
    try {
        yield put(actions.setLoginState({ loading: true }));
        const { name: inviteTokenTenantName } = yield call(api.auth.verifyInviteToken, payload);
        yield put(actions.setLoginState({ inviteTokenTenantName }));
    }
    catch (e) {
        console.error(e);
        yield put(actions.setLoginState({ inviteTokenError: (_a = e.message) !== null && _a !== void 0 ? _a : `We couldn't verify your invitation` }));
    }
    finally {
        yield put(actions.setLoginState({ loading: false }));
    }
}
function* preLogin({ payload: { email, recaptchaToken, invitationToken, callback, }, }) {
    yield put(actions.setLoginState({ loading: true }));
    try {
        const onRedirectTo = yield select(({ auth: { onRedirectTo } }) => onRedirectTo);
        let { address, idpType } = yield call(api.auth.preLoginV2, { email });
        if (address) {
            if (idpType === SamlVendors.Oidc && !address.includes('redirect_uri')) {
                const { routes: { oidcRedirectUrl } } = yield select(({ auth: { routes } }) => ({ routes }));
                address += `&redirect_uri=${window.location.origin}${oidcRedirectUrl}`;
            }
            yield put(actions.setLoginState({ step: LoginStep.redirectToSSO, loading: false, ssoRedirectUrl: address }));
            setTimeout(() => {
                onRedirectTo(address, { refresh: true });
            }, 2000);
        }
        else {
            yield ssoPreloginFailed({ email, recaptchaToken, callback, invitationToken });
        }
    }
    catch (e) {
        yield ssoPreloginFailed({ email, recaptchaToken, callback, invitationToken });
    }
}
function* ssoPreloginFailed(_a) {
    var { callback } = _a, body = __rest(_a, ["callback"]);
    const publicPolicy = yield select(({ auth: { securityPolicyState: { publicPolicy: { policy: publicPolicy } } } }) => publicPolicy);
    if (!(publicPolicy === null || publicPolicy === void 0 ? void 0 : publicPolicy.authStrategy)) {
        yield put(actions.setLoginState({ step: LoginStep.loginWithPassword, loading: false }));
        callback === null || callback === void 0 ? void 0 : callback();
        return;
    }
    if ((publicPolicy === null || publicPolicy === void 0 ? void 0 : publicPolicy.authStrategy) === AuthStrategyEnum.EmailAndPassword) {
        yield put(actions.setLoginState({ step: LoginStep.loginWithPassword, loading: false }));
        callback === null || callback === void 0 ? void 0 : callback();
    }
    else if ([AuthStrategyEnum.MagicLink, AuthStrategyEnum.Code, AuthStrategyEnum.SmsCode].includes(publicPolicy === null || publicPolicy === void 0 ? void 0 : publicPolicy.authStrategy)) {
        yield put(actions.passwordlessPreLogin(Object.assign(Object.assign({}, body), { type: publicPolicy === null || publicPolicy === void 0 ? void 0 : publicPolicy.authStrategy, callback })));
    }
    else {
        yield put(actions.setLoginState({ step: LoginStep.loginWithPassword, loading: false }));
        callback === null || callback === void 0 ? void 0 : callback();
    }
}
function* webAuthnCreateNewDeviceSession({ payload: { callback } }) {
    try {
        yield put(actions.setLoginState({ loading: true }));
        const { options } = yield call(api.auth.webAuthnCreateNewDeviceSession);
        options.user.id = base64urlDecode(options.user.id);
        options.challenge = base64urlDecode(options.challenge);
        options.excludeCredentials = [];
        callback === null || callback === void 0 ? void 0 : callback(options);
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null);
    }
    finally {
        yield put(actions.setLoginState({ loading: false }));
    }
}
function* webAuthnVerifyNewDeviceSession(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    try {
        yield put(actions.setLoginState({ loading: true }));
        const publicKey = publicKeyCredentialToJSON(body.publicKey);
        yield call(api.auth.verifyNewDeviceSession, {
            id: publicKey.id,
            response: publicKey.response
        });
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null);
    }
    finally {
        yield put(actions.setLoginState({ loading: false }));
    }
}
function* webAuthnPrelogin(_a) {
    var _b;
    var _c = _a.payload, { callback } = _c, body = __rest(_c, ["callback"]);
    try {
        yield put(actions.setLoginState({ loading: true }));
        const { options } = yield call(api.auth.webAuthnPreLogin, body);
        options.challenge = base64urlDecode(options.challenge);
        options.allowCredentials = (_b = options.allowCredentials) === null || _b === void 0 ? void 0 : _b.map((credentials) => (Object.assign(Object.assign({}, credentials), { id: base64urlDecode(credentials.id) })));
        yield put(actions.setLoginState({ error: undefined }));
        callback === null || callback === void 0 ? void 0 : callback(options);
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null);
    }
    finally {
        yield put(actions.setLoginState({ loading: false }));
    }
}
function* webAuthnPostLogin(_a) {
    var _b;
    var _c = _a.payload, { callback } = _c, body = __rest(_c, ["callback"]);
    try {
        yield put(actions.setLoginState({ loading: true }));
        const publicKey = publicKeyCredentialToJSON(body.publicKey);
        const data = yield call(api.auth.webAuthnPostLogin, Object.assign(Object.assign({}, publicKey), { response: Object.assign(Object.assign({}, publicKey.response), { userHandle: (_b = publicKey.response.userHandle) !== null && _b !== void 0 ? _b : undefined }), recaptchaToken: body.recaptchaToken, invitationToken: body.invitationToken }));
        if (isMfaRequired(data)) {
            const onRedirectTo = ContextHolder.onRedirectTo;
            const { routes } = yield select((state) => state.auth);
            const mfaRequiredState = yield getMfaRequiredState(data);
            yield put(actions.setState(mfaRequiredState));
            onRedirectTo(routes.loginUrl, { preserveQueryParams: true });
        }
        else {
            const user = yield call(api.auth.generateLoginResponse, data);
            if (user.email) {
                localStorage.setItem('email', user.email);
                localStorage.setItem('name', user.name);
            }
            yield put(actions.loadTenants());
            yield put(actions.setState({ user, isAuthenticated: true }));
            yield put(actions.setLoginState({ error: undefined }));
            yield afterAuthNavigation();
            callback === null || callback === void 0 ? void 0 : callback(true);
        }
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null);
    }
    finally {
        yield put(actions.setLoginState({ loading: false }));
    }
}
function* postLogin({ payload }) {
    const { onRedirectTo, routes } = yield select(({ auth: { onRedirectTo, routes } }) => ({ onRedirectTo, routes }));
    yield put(actions.setLoginState({ loading: true }));
    try {
        const user = yield call(api.auth.postLogin, payload);
        ContextHolder.setAccessToken(user.accessToken);
        ContextHolder.setUser(user);
        yield put(actions.setState({
            user: !!user.accessToken ? user : undefined,
            isAuthenticated: !!user.accessToken,
        }));
        yield afterAuthNavigation();
    }
    catch (e) {
        setTimeout(() => {
            onRedirectTo(routes.authenticatedUrl);
        }, 1000);
        yield put(actions.setLoginState({ step: LoginStep.loginWithSSOFailed, loading: false }));
    }
}
function* login({ payload: { email, password, recaptchaToken, invitationToken, callback, }, }) {
    yield put(actions.setLoginState({ loading: true }));
    try {
        const user = yield call(api.auth.login, {
            email,
            password,
            recaptchaToken,
            invitationToken,
        });
        ContextHolder.setAccessToken(user.accessToken);
        ContextHolder.setUser(user);
        let setMfaState = {};
        let step = LoginStep.success;
        if (user.mfaRequired && user.mfaToken) {
            step = LoginStep.loginWithTwoFactor;
            if (user.hasOwnProperty('mfaEnrolled') && !user.mfaEnrolled) {
                setMfaState = {
                    mfaState: {
                        step: MFAStep.verify,
                        qrCode: user.qrCode,
                        recoveryCode: user.recoveryCode,
                        mfaToken: user.mfaToken,
                        loading: false,
                    },
                };
                step = LoginStep.forceTwoFactor;
            }
        }
        const { loginState } = yield select((state) => state.auth);
        const isLoginSucceeded = step === LoginStep.success;
        const isAuthenticated = isLoginSucceeded && !!user.accessToken;
        const loggedInUser = isLoginSucceeded ? user : undefined;
        let allowRememberDevice = { isAllowedToRemember: false, mfaDeviceExpiration: 0 };
        if (user.mfaRequired && user.mfaToken) {
            allowRememberDevice = yield call(api.auth.checkIfAllowToRememberMfaDevice, user.mfaToken);
        }
        const { isAllowedToRemember, mfaDeviceExpiration } = allowRememberDevice;
        if (user.email) {
            localStorage.setItem('email', user.email);
            localStorage.setItem('name', user.name);
        }
        yield put(actions.setState(Object.assign(Object.assign({ user: loggedInUser, isAuthenticated }, setMfaState), { loginState: {
                flow: loginState.flow,
                quickLoginToRegister: loginState.quickLoginToRegister,
                email,
                loading: false,
                error: undefined,
                mfaToken: user.mfaToken,
                step: (!isLoginSucceeded || loginState.flow === LoginFlow.Login) ? step : loginState.step,
                tenants: [],
                tenantsLoading: true,
                allowRememberMfaDevice: isAllowedToRemember,
                mfaDeviceExpiration,
            } })));
        if (isLoginSucceeded) {
            yield put(actions.loadTenants());
        }
        if (isAuthenticated && loginState.flow === LoginFlow.Login) {
            yield afterAuthNavigation();
        }
        localStorage.removeItem('register-quick-login');
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        ContextHolder.setAccessToken(null);
        ContextHolder.setUser(null);
        yield put(actions.setLoginState({
            email,
            error: e.message,
            loading: false,
        }));
    }
}
function* loginWithMfa({ payload: { mfaToken, value, rememberDevice, callback }, }) {
    yield put(actions.setLoginState({ loading: true }));
    try {
        const user = yield call(api.auth.loginWithMfa, { mfaToken, value, rememberDevice });
        const { loginState } = yield select((state) => state.auth);
        const step = loginState.flow === LoginFlow.Login ? LoginStep.success : loginState.step;
        yield put(actions.setState({
            loginState: { flow: loginState.flow, quickLoginToRegister: loginState.quickLoginToRegister, loading: false, step, error: undefined, tenantsLoading: true, tenants: [] },
            user,
            isAuthenticated: true,
        }));
        if (user.email) {
            localStorage.setItem('email', user.email);
            localStorage.setItem('name', user.name);
        }
        yield put(actions.loadTenants());
        yield put(actions.setLoginState({ error: undefined, loading: false }));
        if (loginState.flow === LoginFlow.Login) {
            yield afterAuthNavigation();
        }
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message, loading: false }));
        callback === null || callback === void 0 ? void 0 : callback(false, e);
    }
}
function* recoverMfa({ payload }) {
    yield put(actions.setLoginState({ loading: true }));
    try {
        yield call(api.auth.recoverMfaToken, payload);
        yield put(actions.setLoginState({ loading: false, error: undefined, step: LoginStep.preLogin }));
        yield put(actions.setState({ user: undefined, isAuthenticated: false }));
    }
    catch (e) {
        yield put(actions.setLoginState({ error: e.message, loading: false }));
    }
}
function* logout({ payload }) {
    yield put(actions.setState({ isLoading: true }));
    try {
        yield call(api.auth.logout);
    }
    catch (_a) {
    }
    yield put(actions.resetState());
    yield put(actions.requestAuthorize(true));
    payload === null || payload === void 0 ? void 0 : payload();
}
function* silentLogout({ payload }) {
    try {
        yield call(api.auth.logout);
    }
    catch (_a) {
    }
    setTimeout(() => payload === null || payload === void 0 ? void 0 : payload(), 500);
}
function* loginSagas() {
    yield takeLeading(actions.requestAuthorize, requestAuthorize);
    yield takeLeading(actions.requestAuthorizeSSR, requestAuthorizeSSR);
    yield takeLeading(actions.requestHostedLoginAuthorize, requestHostedLoginAuthorize);
    yield takeLeading(actions.handleHostedLoginCallback, handleHostedLoginCallback);
    yield takeLeading(actions.preLogin, preLogin);
    yield takeLeading(actions.postLogin, postLogin);
    yield takeLeading(actions.login, login);
    yield takeLeading(actions.logout, logout);
    yield takeLeading(actions.silentLogout, silentLogout);
    yield takeLeading(actions.loginWithMfa, loginWithMfa);
    yield takeLeading(actions.recoverMfa, recoverMfa);
    yield takeLeading(actions.quickSmsPasswordlessPreLogin, quickSmsPasswordlessPreLogin);
    yield takeLeading(actions.changePhoneNumberWithVerification, changePhoneNumberWithVerification);
    yield takeLeading(actions.verifyChangePhoneNumber, verifyChangePhoneNumber);
    yield takeLeading(actions.passwordlessPreLogin, passwordlessPreLogin);
    yield takeLeading(actions.passwordlessPostLogin, passwordlessPostLogin);
    yield takeLeading(actions.verifyInviteToken, verifyInviteToken);
    yield takeLeading(actions.webAuthnPrelogin, webAuthnPrelogin);
    yield takeLeading(actions.webAuthnPostLogin, webAuthnPostLogin);
    yield takeLeading(actions.webAuthnCreateNewDeviceSession, webAuthnCreateNewDeviceSession);
    yield takeLeading(actions.webAuthnVerifyNewDeviceSession, webAuthnVerifyNewDeviceSession);
    yield takeLeading(actions.afterAuthNavigation, afterAuthNavigation);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* requestAuthorizeMock({ payload: firstTime }) {
    if (firstTime) {
        yield put(actions.setState({ isLoading: true }));
    }
    const user = userDemo;
    yield put(actions.loadTenants());
    yield put(actions.setState({ user, isAuthenticated: true, isLoading: false }));
}
function* loginSagasMock() {
    yield takeLeading(actions.requestAuthorize, requestAuthorizeMock);
    yield takeLeading(actions.afterAuthNavigation, afterAuthNavigation);
}

function* loadSSOConfigurations() {
    var _a, _b;
    try {
        yield put(actions.setSSOState({ loading: true }));
        const samlConfiguration = yield call(api.auth.getSamlConfiguration);
        const oidcConfiguration = yield call(api.auth.getOidcConfiguration);
        const samlMetadata = yield call(api.metadata.getSamlMetadata);
        samlConfiguration.acsUrl = (_a = samlMetadata === null || samlMetadata === void 0 ? void 0 : samlMetadata.configuration) === null || _a === void 0 ? void 0 : _a.acsUrl;
        samlConfiguration.spEntityId = (_b = samlMetadata === null || samlMetadata === void 0 ? void 0 : samlMetadata.configuration) === null || _b === void 0 ? void 0 : _b.spEntityId;
        samlConfiguration.isSamlActive = samlMetadata === null || samlMetadata === void 0 ? void 0 : samlMetadata.isActive;
        yield put(actions.setSSOState({ samlConfiguration, oidcConfiguration, loading: false, firstLoad: false }));
    }
    catch (e) {
        yield put(actions.setSSOState({ error: e.message, loading: false }));
    }
}
function* saveSSOConfigurationsFile({ payload: configFile }) {
    const oldSamlConfiguration = yield select((state) => state.auth.ssoState.samlConfiguration);
    const loaderKey = 'saving';
    yield put(actions.setSSOState({ error: undefined, [loaderKey]: true }));
    try {
        const metadata = yield readFileAsText(configFile[0]);
        const newSamlConfiguration = yield call(api.auth.updateSamlVendorMetadata, { metadata });
        newSamlConfiguration.isSamlActive = oldSamlConfiguration === null || oldSamlConfiguration === void 0 ? void 0 : oldSamlConfiguration.isSamlActive;
        yield put(actions.setSSOState({ samlConfiguration: newSamlConfiguration, error: undefined, [loaderKey]: false }));
    }
    catch (e) {
        yield put(actions.setSSOState({ samlConfiguration: oldSamlConfiguration, error: e.message, [loaderKey]: false }));
    }
}
function* saveSSOConfigurationsFileWithCallback({ payload }) {
    const { configFile, callback } = payload;
    const oldSamlConfiguration = yield select((state) => state.auth.ssoState.samlConfiguration);
    const loaderKey = 'saving';
    yield put(actions.setSSOState({ error: undefined, [loaderKey]: true }));
    try {
        const metadata = yield readFileAsText(configFile);
        const newSamlConfiguration = yield call(api.auth.updateSamlVendorMetadata, { metadata });
        newSamlConfiguration.isSamlActive = oldSamlConfiguration === null || oldSamlConfiguration === void 0 ? void 0 : oldSamlConfiguration.isSamlActive;
        yield put(actions.setSSOState({ samlConfiguration: newSamlConfiguration, error: undefined, [loaderKey]: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSSOState({ samlConfiguration: oldSamlConfiguration, error: e.message, [loaderKey]: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* saveSSOConfigurations({ payload }) {
    var _a, _b;
    const { callback, samlVendor } = payload, newSamlConfiguration = __rest(payload, ["callback", "samlVendor"]);
    const oldSamlConfiguration = yield select((state) => state.auth.ssoState.samlConfiguration);
    const samlConfiguration = Object.assign(Object.assign({}, oldSamlConfiguration), newSamlConfiguration);
    let loaderKey = 'saving';
    if ((samlConfiguration === null || samlConfiguration === void 0 ? void 0 : samlConfiguration.enabled) !== oldSamlConfiguration.enabled) {
        loaderKey = 'loading';
    }
    try {
        const firstTimeConfigure = !(samlConfiguration === null || samlConfiguration === void 0 ? void 0 : samlConfiguration.domain);
        if (firstTimeConfigure) {
            yield put(actions.setSSOState({ samlConfiguration: Object.assign(Object.assign({}, oldSamlConfiguration), samlConfiguration) }));
            return;
        }
        else {
            yield put(actions.setSSOState({ error: undefined, [loaderKey]: true }));
        }
        if (payload.type === SamlVendors.Saml) {
            const samlMetadata = yield call(api.metadata.getSamlMetadata);
            samlConfiguration.acsUrl = (_a = samlMetadata === null || samlMetadata === void 0 ? void 0 : samlMetadata.configuration) === null || _a === void 0 ? void 0 : _a.acsUrl;
            samlConfiguration.spEntityId = (_b = samlMetadata === null || samlMetadata === void 0 ? void 0 : samlMetadata.configuration) === null || _b === void 0 ? void 0 : _b.spEntityId;
        }
        const updateSamlConfiguration = omitProps(samlConfiguration, [
            'validated',
            'generatedVerification',
            'createdAt',
            'updatedAt',
        ]);
        if ((oldSamlConfiguration === null || oldSamlConfiguration === void 0 ? void 0 : oldSamlConfiguration.domain) !== (updateSamlConfiguration === null || updateSamlConfiguration === void 0 ? void 0 : updateSamlConfiguration.domain)) {
            updateSamlConfiguration.ssoEndpoint = '';
            updateSamlConfiguration.publicCertificate = '';
            updateSamlConfiguration.signRequest = false;
        }
        updateSamlConfiguration.type = samlVendor === null || samlVendor === void 0 ? void 0 : samlVendor.toLowerCase();
        const newSamlConfiguration = yield call(api.auth.updateSamlConfiguration, updateSamlConfiguration);
        newSamlConfiguration.isSamlActive = oldSamlConfiguration === null || oldSamlConfiguration === void 0 ? void 0 : oldSamlConfiguration.isSamlActive;
        yield put(actions.setSSOState({ samlConfiguration: newSamlConfiguration, error: undefined, [loaderKey]: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSSOState({ samlConfiguration: oldSamlConfiguration, error: e.message, [loaderKey]: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* validateSSODomain({ payload: { callback } = {} }) {
    const samlConfiguration = yield select((state) => state.auth.ssoState.samlConfiguration);
    try {
        yield put(actions.setSSOState({ error: undefined, saving: true }));
        yield call(api.auth.validateSamlDomain);
        yield put(actions.setSSOState({
            samlConfiguration: Object.assign(Object.assign({}, samlConfiguration), { validated: true }),
            error: undefined,
            saving: false,
        }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSSOState({
            samlConfiguration: Object.assign(Object.assign({}, samlConfiguration), { validated: false }),
            error: e.message,
            saving: false,
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* getAuthorizationRoles() {
    try {
        const data = yield call(api.auth.getSamlRoles);
        const groupsData = yield call(api.auth.getSamlRolesGroups);
        yield put(actions.setSSOState({
            authorizationRoles: data.roleIds,
            rolesGroups: groupsData,
            error: undefined,
        }));
    }
    catch (e) {
        yield put(actions.setSSOState({
            error: e.message,
        }));
    }
}
function* updateRolesGroups(groups) {
    try {
        yield all(groups.map((group) => call(api.auth.updateSamlGroup, { id: group.id, roleIds: group.roleIds, group: group.group })));
    }
    catch (e) {
        yield put(actions.setSSOState({
            error: e.message,
        }));
    }
}
function* updateAuthorizationRoles({ payload: { callback, authorizationRoles, groups }, }) {
    try {
        yield put(actions.setSSOState({ error: undefined, saving: true }));
        yield call(api.auth.updateSamlRoles, { roleIds: authorizationRoles });
        if (groups) {
            yield updateRolesGroups(groups);
        }
        yield getAuthorizationRoles();
        yield put(actions.setSSOState({ error: undefined, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSSOState({
            error: e.message,
            saving: false,
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* deleteSamlGroupFunction({ payload: { callback, id } }) {
    try {
        yield put(actions.setSSOState({ error: undefined, saving: true }));
        yield call(api.auth.deleteSamlGroup, { id });
        yield getAuthorizationRoles();
        yield put(actions.setSSOState({ error: undefined, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSSOState({
            error: e.message,
            saving: false,
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* createSamlGroupFunction({ payload: { group, roleIds, callback } }) {
    try {
        yield put(actions.setSSOState({ error: undefined, saving: true }));
        yield call(api.auth.createSamlGroup, { group, roleIds });
        yield getAuthorizationRoles();
        yield put(actions.setSSOState({ error: undefined, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSSOState({
            error: e.message,
            saving: false,
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* oidcPostloginFunction({ payload }) {
    var _a;
    const data = { code: payload.code, redirectUri: payload.redirectUri, RelayState: payload.state };
    try {
        yield put(actions.setSSOState({ loading: true }));
        yield call(api.auth.oidcPostLoginV2, data);
        yield refreshToken();
        yield put(actions.setSSOState({ loading: false }));
    }
    catch (e) {
        yield put(actions.setSSOState({ loading: false, error: (_a = e.message) !== null && _a !== void 0 ? _a : 'Failed to authenticate', firstLoad: false }));
    }
}
function* ssoSagas$1() {
    yield takeEvery(actions.loadSSOConfigurations, loadSSOConfigurations);
    yield takeEvery(actions.saveSSOConfigurations, saveSSOConfigurations);
    yield takeEvery(actions.saveSSOConfigurationsFile, saveSSOConfigurationsFile);
    yield takeEvery(actions.saveSSOConfigurationsFileWithCallback, saveSSOConfigurationsFileWithCallback);
    yield takeEvery(actions.validateSSODomain, validateSSODomain);
    yield takeEvery(actions.loadSSOAuthorizationRoles, getAuthorizationRoles);
    yield takeEvery(actions.updateSSOAuthorizationRoles, updateAuthorizationRoles);
    yield takeEvery(actions.deleteSamlGroup, deleteSamlGroupFunction);
    yield takeEvery(actions.createSamlGroup, createSamlGroupFunction);
    yield takeEvery(actions.oidcPostlogin, oidcPostloginFunction);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* loadSSOConfigurationsMock() {
    yield put(actions.setSSOState({ loading: true }));
    yield delay();
    yield put(actions.setSSOState({ samlConfiguration: samlConfigurationDemo, loading: false, firstLoad: false }));
}
function* saveSSOConfigurationsFileMock({ payload: configFile }) {
    const loaderKey = 'saving';
    yield put(actions.setSSOState({ error: undefined, [loaderKey]: true }));
    const oldSamlConfiguration = yield select((state) => state.auth.ssoState.samlConfiguration);
    const newSamlConfiguration = Object.assign(Object.assign(Object.assign({}, oldSamlConfiguration), { enabled: true }), configFile[0]);
    yield put(actions.setSSOState({ samlConfiguration: newSamlConfiguration, error: undefined, [loaderKey]: false }));
}
function* saveSSOConfigurationsMock({ payload }) {
    var _a, _b;
    const { callback, samlVendor } = payload, newSamlConfiguration = __rest(payload, ["callback", "samlVendor"]);
    const oldSamlConfiguration = ssoStateDemo.samlConfiguration;
    const samlConfiguration = Object.assign(Object.assign({}, oldSamlConfiguration), newSamlConfiguration);
    let loaderKey = 'saving';
    if ((samlConfiguration === null || samlConfiguration === void 0 ? void 0 : samlConfiguration.enabled) !== oldSamlConfiguration.enabled) {
        loaderKey = 'loading';
    }
    const firstTimeConfigure = !(samlConfiguration === null || samlConfiguration === void 0 ? void 0 : samlConfiguration.domain);
    if (firstTimeConfigure) {
        yield put(actions.setSSOState({ samlConfiguration: Object.assign(Object.assign({}, oldSamlConfiguration), samlConfiguration) }));
        return;
    }
    else {
        yield put(actions.setSSOState({ error: undefined, [loaderKey]: true }));
    }
    yield delay();
    samlConfiguration.acsUrl = (_a = samlMetadataDemo === null || samlMetadataDemo === void 0 ? void 0 : samlMetadataDemo.configuration) === null || _a === void 0 ? void 0 : _a.acsUrl;
    samlConfiguration.spEntityId = (_b = samlMetadataDemo === null || samlMetadataDemo === void 0 ? void 0 : samlMetadataDemo.configuration) === null || _b === void 0 ? void 0 : _b.spEntityId;
    const updateSamlConfiguration = omitProps(samlConfiguration, [
        'validated',
        'generatedVerification',
        'createdAt',
        'updatedAt',
    ]);
    if ((oldSamlConfiguration === null || oldSamlConfiguration === void 0 ? void 0 : oldSamlConfiguration.domain) !== (updateSamlConfiguration === null || updateSamlConfiguration === void 0 ? void 0 : updateSamlConfiguration.domain)) {
        updateSamlConfiguration.ssoEndpoint = '';
        updateSamlConfiguration.publicCertificate = '';
        updateSamlConfiguration.signRequest = false;
    }
    updateSamlConfiguration.type = samlVendor === null || samlVendor === void 0 ? void 0 : samlVendor.toLowerCase();
    yield delay();
    yield put(actions.setSSOState({ samlConfiguration: updateSamlConfiguration, error: undefined, [loaderKey]: false }));
    callback === null || callback === void 0 ? void 0 : callback(true);
}
function* validateSSODomainMock({ payload: { callback } = {} }) {
    const samlConfiguration = ssoStateDemo.samlConfiguration;
    yield put(actions.setSSOState({ error: undefined, saving: true }));
    yield delay();
    yield put(actions.setSSOState({
        samlConfiguration: Object.assign(Object.assign({}, samlConfiguration), { validated: true }),
        error: undefined,
        saving: false,
    }));
    callback === null || callback === void 0 ? void 0 : callback(true);
}
function* getAuthorizationRolesMock() {
    yield delay();
    const data = { roleIds: ['1', '2', '3'] };
    yield put(actions.setSSOState({
        authorizationRoles: data.roleIds,
        error: undefined,
    }));
}
function* updateAuthorizationRolesMock({ payload: { callback, authorizationRoles }, }) {
    yield put(actions.setSSOState({ error: undefined, saving: true }));
    yield delay();
    yield put(actions.setSSOState({ authorizationRoles, error: undefined, saving: false }));
    callback === null || callback === void 0 ? void 0 : callback(true);
}
function* ssoSagasMock() {
    yield takeEvery(actions.loadSSOConfigurations, loadSSOConfigurationsMock);
    yield takeEvery(actions.saveSSOConfigurations, saveSSOConfigurationsMock);
    yield takeEvery(actions.saveSSOConfigurationsFile, saveSSOConfigurationsFileMock);
    yield takeEvery(actions.validateSSODomain, validateSSODomainMock);
    yield takeEvery(actions.loadSSOAuthorizationRoles, getAuthorizationRolesMock);
    yield takeEvery(actions.updateSSOAuthorizationRoles, updateAuthorizationRolesMock);
}

function* loadOidc() {
    try {
        const oidcConfiguration = yield call(api.auth.getOidcConfiguration);
        return oidcConfiguration;
    }
    catch (e) {
        return null;
    }
}
function* loadSaml() {
    try {
        const samlMetadata = yield call(api.metadata.getSamlMetadata);
        return samlMetadata;
    }
    catch (e) {
        return null;
    }
}
function* loadSSOConfigurationsV2() {
    try {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.LOAD_SSO_CONFIGURATIONS, value: true }));
        const [oidcConfiguration, samlMetadata] = yield all([call(loadOidc), call(loadSaml)]);
        const ssoConfigurations = yield call(api.auth.getSSOConfigurations);
        yield put(actions.setSSOState({
            ssoConfigurations,
            oidcConfiguration,
            samlMetadata
        }));
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.LOAD_SSO_CONFIGURATIONS, value: error.message }));
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.LOAD_SSO_CONFIGURATIONS, value: false }));
    }
}
function* saveSSOConfigurationV2({ payload }) {
    var _a;
    yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_CONFIGURATION, value: true }));
    const { callback } = payload, ssoConfiguration = __rest(payload, ["callback"]);
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        const newSsoConfiguration = yield call(api.auth.createSSOConfiguration, Object.assign(Object.assign({}, ssoConfiguration), { enabled: (_a = ssoConfiguration.enabled) !== null && _a !== void 0 ? _a : false }));
        yield put(actions.setSSOState({ ssoConfigurations: [...ssoConfigurations, newSsoConfiguration] }));
        callback === null || callback === void 0 ? void 0 : callback(newSsoConfiguration);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.SAVE_SSO_CONFIGURATION, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_CONFIGURATION, value: false }));
    }
}
function* saveSSOConfigurationByMetadata({ payload }) {
    yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA, value: true }));
    const { configFile, callback } = payload;
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        const metadata = yield readFileAsText(configFile);
        const newSsoConfiguration = yield call(api.auth.createSSOConfigurationByMetadata, { metadata });
        yield put(actions.setSSOState({ ssoConfigurations: [...ssoConfigurations, newSsoConfiguration] }));
        callback === null || callback === void 0 ? void 0 : callback(newSsoConfiguration);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA, value: false }));
    }
}
function* updateSSOConfiguration({ payload }) {
    yield put(actions.setSSOLoader({ key: SSOStateKeys.UPDATE_SSO_CONFIGURATION, value: true }));
    const { callback, ssoConfigId } = payload, ssoConfiguration = __rest(payload, ["callback", "ssoConfigId"]);
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        const newSsoConfiguration = yield call(api.auth.updateSSOConfiguration, ssoConfigId, ssoConfiguration);
        const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
        yield put(actions.setSSOState({ ssoConfigurations: newSsoConfigurations }));
        callback === null || callback === void 0 ? void 0 : callback(newSsoConfiguration);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.UPDATE_SSO_CONFIGURATION, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.UPDATE_SSO_CONFIGURATION, value: false }));
    }
}
function* updateSSOConfigurationByMetadata({ payload }) {
    yield put(actions.setSSOLoader({ key: SSOStateKeys.UPDATE_SSO_CONFIGURATION_BY_METADATA, value: true }));
    const { callback, ssoConfigId, configFile } = payload;
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        const metadata = yield readFileAsText(configFile);
        const newSsoConfiguration = yield call(api.auth.updateSSOConfigurationByMetadata, ssoConfigId, { metadata });
        const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
        yield put(actions.setSSOState({ ssoConfigurations: newSsoConfigurations }));
        callback === null || callback === void 0 ? void 0 : callback(newSsoConfiguration);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.UPDATE_SSO_CONFIGURATION, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.UPDATE_SSO_CONFIGURATION, value: false }));
    }
}
function* deleteSSOConfiguration({ payload }) {
    yield put(actions.setSSOLoader({ key: SSOStateKeys.DELETE_SSO_CONFIGURATION, value: true }));
    const { ssoConfigId, callback } = payload;
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        yield call(api.auth.deleteSSOConfiguration, ssoConfigId);
        yield put(actions.setSSOState({ ssoConfigurations: ssoConfigurations.filter(({ id }) => id !== ssoConfigId) }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.DELETE_SSO_CONFIGURATION, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.DELETE_SSO_CONFIGURATION, value: false }));
    }
}
function* saveSSODomain({ payload }) {
    const { callback, ssoConfigId } = payload, body = __rest(payload, ["callback", "ssoConfigId"]);
    yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_DOMAIN, value: true }));
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        const domain = yield call(api.auth.createSSODomain, ssoConfigId, body);
        const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
                return Object.assign(Object.assign({}, ssoConfig), { domains: [...ssoConfig.domains, domain] });
            }
            return ssoConfig;
        });
        yield put(actions.setSSOState({ ssoConfigurations: newSsoConfigurations }));
        callback === null || callback === void 0 ? void 0 : callback(domain);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.SAVE_SSO_DOMAIN, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_DOMAIN, value: false }));
    }
}
function* deleteSSODomain({ payload }) {
    const { ssoConfigId, domainId, callback } = payload;
    yield put(actions.setSSOLoader({ key: SSOStateKeys.DELETE_SSO_DOMAIN, value: true }));
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        yield call(api.auth.deleteSSODomain, ssoConfigId, domainId);
        const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
                return Object.assign(Object.assign({}, ssoConfig), { domains: ssoConfig.domains.filter(({ id }) => id !== domainId) });
            }
            return ssoConfig;
        });
        yield put(actions.setSSOState({ ssoConfigurations: newSsoConfigurations }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.DELETE_SSO_DOMAIN, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.DELETE_SSO_DOMAIN, value: false }));
    }
}
function* validateSSODomainV2({ payload }) {
    const { callback, domainId, ssoConfigId } = payload;
    yield put(actions.setSSOLoader({ key: SSOStateKeys.VALIDATE_SSO_DOMAIN, value: true }));
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        yield call(api.auth.validateSSODomain, ssoConfigId, domainId);
        const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
                return Object.assign(Object.assign({}, ssoConfig), { domains: ssoConfig.domains.map((ssoDomain) => ssoDomain.id === domainId ? Object.assign(Object.assign({}, ssoDomain), { validated: true }) : ssoDomain) });
            }
            return ssoConfig;
        });
        yield put(actions.setSSOState({ ssoConfigurations: newSsoConfigurations }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.VALIDATE_SSO_DOMAIN, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.VALIDATE_SSO_DOMAIN, value: false }));
    }
}
function* setSSODefaultRoles({ payload: { callback, ssoConfigId, roleIds }, }) {
    yield put(actions.setSSOLoader({ key: SSOStateKeys.UPDATE_SSO_DEFAULT_ROLES, value: true }));
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        yield call(api.auth.setSSODefaultRoles, ssoConfigId, { roleIds });
        const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
                return Object.assign(Object.assign({}, ssoConfig), { roleIds });
            }
            return ssoConfig;
        });
        yield put(actions.setSSOState({ ssoConfigurations: newSsoConfigurations }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.UPDATE_SSO_DEFAULT_ROLES, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.UPDATE_SSO_DEFAULT_ROLES, value: false }));
    }
}
function* setSSOGroups({ payload: { groupsToAdd, groupsToDelete, ssoConfigId, callback } }) {
    yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_GROUPS, value: true }));
    const ssoConfigurations = yield select((state) => state.auth.ssoState.ssoConfigurations);
    try {
        yield all(groupsToDelete.map((groupId) => call(api.auth.deleteSSOGroup, ssoConfigId, groupId)));
        yield all(groupsToAdd.map((group) => call(api.auth.createSSOGroup, ssoConfigId, group)));
        const groups = yield call(api.auth.getSSOGroups, ssoConfigId);
        const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
                return Object.assign(Object.assign({}, ssoConfig), { groups });
            }
            return ssoConfig;
        });
        yield put(actions.setSSOState({ ssoConfigurations: newSsoConfigurations }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.SAVE_SSO_GROUPS, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_GROUPS, value: false }));
    }
}
function* updateSSOGroups({ payload: { ssoConfigId, changedGroups, callback } }) {
    try {
        yield all(changedGroups.map((group) => call(api.auth.updateSSOGroup, ssoConfigId, group)));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (error) {
        yield put(actions.setSSOError({ key: SSOStateKeys.SAVE_SSO_GROUPS, value: error.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, error);
    }
    finally {
        yield put(actions.setSSOLoader({ key: SSOStateKeys.SAVE_SSO_GROUPS, value: false }));
    }
}
function* ssoSagas() {
    yield takeEvery(actions.loadSSOConfigurationsV2, loadSSOConfigurationsV2);
    yield takeEvery(actions.saveSSOConfigurationV2, saveSSOConfigurationV2);
    yield takeEvery(actions.saveSSODomain, saveSSODomain);
    yield takeEvery(actions.deleteSSODomain, deleteSSODomain);
    yield takeEvery(actions.validateSSODomainV2, validateSSODomainV2);
    yield takeEvery(actions.updateSSOConfiguration, updateSSOConfiguration);
    yield takeEvery(actions.deleteSSOConfiguration, deleteSSOConfiguration);
    yield takeEvery(actions.setSSOGroups, setSSOGroups);
    yield takeEvery(actions.updateSSOGroups, updateSSOGroups);
    yield takeEvery(actions.setSSODefaultRoles, setSSODefaultRoles);
    yield takeEvery(actions.saveSSOConfigurationByMetadata, saveSSOConfigurationByMetadata);
    yield takeEvery(actions.updateSSOConfigurationByMetadata, updateSSOConfigurationByMetadata);
}

function* loadProfile() {
    yield put(actions.setProfileState({ loading: true }));
    try {
        const profile = yield retry(3, 2000, api.teams.getProfile);
        const currentUser = yield select((state) => state.auth.user);
        actions.setUser(Object.assign(Object.assign({}, currentUser), profile));
        yield put(actions.setProfileState({ profile, loading: false }));
    }
    catch (e) {
        yield put(actions.setProfileState({ loading: false, error: e.message }));
    }
}
function b64toBlob(base64, contentType) {
    const sliceSize = 512;
    const byteCharacters = atob(base64);
    const byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        const slice = byteCharacters.slice(offset, offset + sliceSize);
        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }
        byteArrays.push(new Uint8Array(byteNumbers));
    }
    return new Blob(byteArrays, { type: contentType });
}
function base64ToFormData(base64, key = 'file') {
    const matchResult = base64.match(/^data:image\/([A-Za-z-+\/]+);base64,(.+)$/);
    if (matchResult == null) {
        return null;
    }
    // Get the content type of the image
    const contentType = `image/${matchResult[1]}`;
    // get the real base64 content of the file
    const data = matchResult[2];
    // Convert it to a blob to upload
    const blob = b64toBlob(data, contentType);
    // Create a FormData and append the file with "image" as parameter name
    const formDataToUpload = new FormData();
    formDataToUpload.append(key, new File([blob], key, { type: contentType }));
    return formDataToUpload;
}
function* saveProfile(_a) {
    var _b = _a.payload, { callback, profilePictureUrl } = _b, payload = __rest(_b, ["callback", "profilePictureUrl"]);
    yield put(actions.setProfileState({ saving: true, error: null }));
    try {
        const oldProfileData = yield select((state) => state.auth.profileState.profile);
        let newProfilePictureUrl = oldProfileData.profilePictureUrl;
        if (profilePictureUrl !== oldProfileData.profilePictureUrl && profilePictureUrl) {
            const matchResult = (profilePictureUrl || '').match(/^data:image\/([A-Za-z-+\/]+);base64,(.+)$/);
            if (matchResult) {
                const profileImage = base64ToFormData(profilePictureUrl, 'image');
                if (profileImage) {
                    newProfilePictureUrl = yield call(api.teams.updateProfileImage, profileImage);
                    const imageTimeStamp = Date.now().toString();
                    const urlTemplate = new URL(newProfilePictureUrl);
                    urlTemplate.searchParams.set('t', imageTimeStamp);
                    newProfilePictureUrl = urlTemplate.href;
                }
            }
        }
        const newProfileData = Object.assign(Object.assign(Object.assign({}, oldProfileData), payload), { profilePictureUrl: newProfilePictureUrl });
        const profile = yield call(api.teams.updateProfile, newProfileData);
        const currentUser = yield select((state) => state.auth.user);
        yield put(actions.setUser(Object.assign(Object.assign({}, currentUser), profile)));
        yield put(actions.setProfileState({ profile, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(newProfileData);
    }
    catch (e) {
        yield put(actions.setProfileState({ saving: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* changePassword({ payload }) {
    var _a, _b;
    yield put(actions.setProfileState({ loading: true }));
    try {
        yield call(api.teams.changePassword, payload);
        yield put(actions.setProfileState({ loading: false, error: undefined }));
        (_a = payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
    }
    catch (e) {
        yield put(actions.setProfileState({ loading: false, error: e.message }));
        (_b = payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, null, e);
    }
}
function* profileSagas() {
    yield takeLeading(actions.loadProfile, loadProfile);
    yield takeEvery(actions.saveProfile, saveProfile);
    yield takeEvery(actions.changePassword, changePassword);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* loadProfileMock() {
    yield put(actions.setProfileState({ loading: true }));
    yield delay();
    yield put(actions.setUser(Object.assign(Object.assign({}, (userDemo)), userProfileDemo)));
    yield put(actions.setProfileState({ loading: false, profile: userProfileDemo }));
}
function* saveProfileMock(_a) {
    var _b = _a.payload, { callback, profilePictureUrl } = _b, payload = __rest(_b, ["callback", "profilePictureUrl"]);
    yield put(actions.setProfileState({ saving: true, error: null }));
    const oldProfileData = profileStateDemo;
    let newProfilePictureUrl = oldProfileData.profile.profilePictureUrl;
    if (profilePictureUrl !== oldProfileData.profile.profilePictureUrl && profilePictureUrl) {
        const matchResult = (profilePictureUrl || '').match(/^data:image\/([A-Za-z-+\/]+);base64,(.+)$/);
        if (matchResult) {
            newProfilePictureUrl = profilePictureUrl;
        }
    }
    const newProfileData = Object.assign(Object.assign(Object.assign({}, oldProfileData.profile), payload), { profilePictureUrl: newProfilePictureUrl });
    const currentUser = userDemo;
    yield delay();
    yield put(actions.setUser(Object.assign(Object.assign({}, currentUser), newProfileData)));
    yield put(actions.setProfileState({ loading: false, error: null, saving: false, profile: newProfileData }));
    callback === null || callback === void 0 ? void 0 : callback(newProfileData);
}
function* changePasswordMock({ payload }) {
    var _a;
    yield put(actions.setProfileState({ loading: true }));
    yield delay();
    yield put(actions.setProfileState({ loading: false, error: undefined }));
    (_a = payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
}
function* profileSagasMock() {
    yield takeLeading(actions.loadProfile, loadProfileMock);
    yield takeEvery(actions.saveProfile, saveProfileMock);
    yield takeEvery(actions.changePassword, changePasswordMock);
}

function* enrollMfa() {
    yield put(actions.setMfaState({ loading: true }));
    try {
        const { qrCode } = yield call(api.auth.enrollMfa);
        yield put(actions.setMfaState({ loading: false, error: undefined, qrCode }));
    }
    catch (e) {
        yield put(actions.setMfaState({ loading: false, error: e.message }));
    }
}
function* verifyMfa(_a) {
    var _b = _a.payload, { callback } = _b, payload = __rest(_b, ["callback"]);
    yield put(actions.setMfaState({ loading: true }));
    try {
        const user = yield select((state) => state.auth.user);
        const data = yield call(api.auth.verifyMfa, payload);
        const mfaState = {
            step: MFAStep.recoveryCode,
            loading: false,
            error: undefined,
        };
        if (data === null || data === void 0 ? void 0 : data.recoveryCode) {
            mfaState.recoveryCode = data.recoveryCode;
        }
        yield put(actions.setMfaState(mfaState));
        yield put(actions.setUser(Object.assign(Object.assign({}, user), { mfaEnrolled: true })));
        callback === null || callback === void 0 ? void 0 : callback(mfaState.recoveryCode);
    }
    catch (e) {
        yield put(actions.setMfaState({ loading: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* verifyMfaAfterForce(_a) {
    var _b = _a.payload, { callback } = _b, payload = __rest(_b, ["callback"]);
    yield put(actions.setMfaState({ loading: true }));
    try {
        const user = yield call(api.auth.loginWithMfa, payload);
        const mfaState = {
            step: MFAStep.recoveryCode,
            loading: false,
            error: undefined,
        };
        if (user === null || user === void 0 ? void 0 : user.recoveryCode) {
            mfaState.recoveryCode = user.recoveryCode;
        }
        yield put(actions.setMfaState(mfaState));
        yield put(actions.setState({ user }));
        yield put(actions.loadTenants());
        callback === null || callback === void 0 ? void 0 : callback(mfaState.recoveryCode);
    }
    catch (e) {
        yield put(actions.setMfaState({ loading: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* disableMfa({ payload }) {
    var _a, _b;
    yield put(actions.setMfaState({ loading: true }));
    try {
        const user = yield select((state) => state.auth.user);
        yield api.auth.disableMfa(payload);
        yield put(actions.setMfaState({ loading: false, error: undefined }));
        yield put(actions.setUser(Object.assign(Object.assign({}, user), { mfaEnrolled: false })));
        (_a = payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
    }
    catch (e) {
        yield put(actions.setMfaState({ loading: false, error: e.message }));
        (_b = payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, false, e);
    }
}
function* mfaSagas() {
    yield takeEvery(actions.enrollMfa, enrollMfa);
    yield takeEvery(actions.verifyMfa, verifyMfa);
    yield takeEvery(actions.disableMfa, disableMfa);
    yield takeEvery(actions.verifyMfaAfterForce, verifyMfaAfterForce);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* enrollMfaMock() {
    yield put(actions.setMfaState({ loading: true }));
    const qrCode = 'test';
    yield put(actions.setMfaState({ loading: false, error: undefined, qrCode }));
}
function* verifyMfaMock({ payload: { callback }, }) {
    yield put(actions.setMfaState({ loading: true }));
    yield delay();
    const data = { token: 'token', recoveryCode: 'recoveryCode' };
    const mfaState = {
        step: MFAStep.recoveryCode,
        loading: false,
        error: undefined,
    };
    if (data === null || data === void 0 ? void 0 : data.recoveryCode) {
        mfaState.recoveryCode = data.recoveryCode;
    }
    yield put(actions.setMfaState(mfaState));
    yield put(actions.setUser(Object.assign(Object.assign({}, userDemo), { mfaEnrolled: true })));
    callback === null || callback === void 0 ? void 0 : callback(mfaState.recoveryCode);
}
function* verifyMfaAfterForceMock(_a) {
    var _b = _a.payload, { callback } = _b, payload = __rest(_b, ["callback"]);
    yield put(actions.setMfaState({ loading: true }));
    yield delay();
    const data = Object.assign(Object.assign({}, payload), { recoveryCode: 'recoveryCode' });
    const mfaState = {
        step: MFAStep.recoveryCode,
        loading: false,
        error: undefined,
    };
    if (data === null || data === void 0 ? void 0 : data.recoveryCode) {
        mfaState.recoveryCode = data.recoveryCode;
    }
    yield put(actions.setMfaState(mfaState));
    yield delay();
    yield put(actions.setUser(Object.assign(Object.assign({}, userDemo), { mfaEnrolled: true })));
    callback === null || callback === void 0 ? void 0 : callback(mfaState.recoveryCode);
}
function* disableMfaMock({ payload }) {
    var _a;
    yield put(actions.setMfaState({ loading: true }));
    yield delay();
    yield put(actions.setMfaState({ loading: false, error: undefined }));
    yield put(actions.setUser(Object.assign(Object.assign({}, userDemo), { mfaEnrolled: false })));
    (_a = payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
}
function* mfaSagasMock() {
    yield takeEvery(actions.enrollMfa, enrollMfaMock);
    yield takeEvery(actions.verifyMfa, verifyMfaMock);
    yield takeEvery(actions.disableMfa, disableMfaMock);
    yield takeEvery(actions.verifyMfaAfterForce, verifyMfaAfterForceMock);
}

function* forgotPassword({ payload }) {
    yield put(actions.setForgotPasswordState({ loading: true }));
    try {
        yield call(api.auth.forgotPassword, payload);
        yield put(actions.setForgotPasswordState({ loading: false, error: undefined, step: ForgotPasswordStep.success }));
    }
    catch (e) {
        yield put(actions.setForgotPasswordState({ loading: false, error: e.message || 'Unknown error occurred' }));
    }
}
function* resetPassword(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setForgotPasswordState({ loading: true }));
    try {
        yield call(api.auth.resetPassword, body);
        yield put(actions.setForgotPasswordState({ loading: false, error: undefined, step: ForgotPasswordStep.success }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setForgotPasswordState({ loading: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(false);
    }
}
function* loadPasswordConfig({ payload }) {
    yield put(actions.setForgotPasswordState({ loading: true }));
    try {
        const passwordConfig = yield call(api.auth.loadPasswordConfig, payload);
        yield put(actions.setForgotPasswordState({ loading: false, passwordConfig }));
    }
    catch (e) {
        yield put(actions.setForgotPasswordState({ loading: false, error: e.message }));
    }
}
function* forgotPasswordSagas() {
    yield takeLeading(actions.forgotPassword, forgotPassword);
    yield takeLeading(actions.resetPassword, resetPassword);
    yield takeLeading(actions.loadPasswordConfig, loadPasswordConfig);
}

function* preActivateAccount({ payload: { userId, token } }) {
    yield put(actions.setActivateState({ loading: true, step: ActivateAccountStep.activating }));
    try {
        const { isAuthenticated } = yield select((state) => state.auth);
        if (isAuthenticated) {
            yield put(actions.silentLogout());
        }
        const strategy = yield call(api.auth.getActivateAccountStrategy, { userId, token });
        yield put(actions.setActivateStrategyState({ strategy, loading: false, error: undefined }));
        if (strategy.shouldSetPassword) {
            yield put(actions.setActivateState({ loading: false, step: ActivateAccountStep.activatingForm }));
        }
    }
    catch (e) {
        yield put(actions.setActivateState({ loading: false, error: e.message }));
    }
}
function* activateAccount(_a) {
    var _b;
    var _c = _a.payload, { callback, events } = _c, payload = __rest(_c, ["callback", "events"]);
    yield put(actions.setActivateState({ loading: true }));
    try {
        const onRedirectTo = ContextHolder.onRedirectTo;
        const { routes } = yield select((state) => state.auth);
        const data = yield call(api.auth.activateAccount, payload);
        if (data.redirectLocation) {
            window.location.href = data.redirectLocation;
            return;
        }
        if (isMfaRequired(data)) {
            yield put(actions.setActivateState({ step: ActivateAccountStep.success }));
            const mfaRequiredState = yield getMfaRequiredState(data);
            yield put(actions.setState(mfaRequiredState));
            yield delay$1(1000);
            onRedirectTo(routes.loginUrl, { preserveQueryParams: true });
        }
        else {
            yield put(actions.setActivateState({ step: ActivateAccountStep.success }));
            const { user, tenants } = yield call(api.auth.generateLoginResponseV2, data);
            (_b = events === null || events === void 0 ? void 0 : events.userVerified) === null || _b === void 0 ? void 0 : _b.call(events, { email: user.email, origin: UserVeirifedOriginTypes.ACTIVATION_LINK, id: user.id, tenantId: user.tenantId, name: user.name, createdAt: new Date() });
            yield put(actions.setTenantsState({ tenants, loading: false }));
            yield put(actions.setState({ user, isAuthenticated: true }));
            yield delay$1(1000);
            yield afterAuthNavigation();
            yield put(actions.resetActivateState());
        }
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setActivateState({ loading: false, error: e.message }));
    }
}
function* getActivateAccountStrategy({ payload, }) {
    const { callback } = payload, params = __rest(payload, ["callback"]);
    yield put(actions.setActivateStrategyState({ loading: true }));
    try {
        const strategy = yield call(api.auth.getActivateAccountStrategy, params);
        yield put(actions.setActivateStrategyState({ strategy, loading: false, error: undefined }));
        callback === null || callback === void 0 ? void 0 : callback(strategy);
    }
    catch (e) {
        yield put(actions.setActivateStrategyState({ loading: false, error: e.message }));
    }
}
function* resendActivationEmailFunction({ payload }) {
    yield put(actions.setActivateState({ loading: true }));
    try {
        yield call(api.auth.resendActivationEmail, { email: payload.email });
        yield put(actions.setActivateState({ loading: false, error: undefined, resentEmail: true }));
    }
    catch (e) {
        yield put(actions.setActivateState({ loading: false, error: e.message }));
    }
}
function* activateSagas() {
    yield takeLeading(actions.activateAccount, activateAccount);
    yield takeLeading(actions.preActivateAccount, preActivateAccount);
    yield takeLeading(actions.getActivateAccountStrategy, getActivateAccountStrategy);
    yield takeLeading(actions.resendActivationEmail, resendActivationEmailFunction);
}

function* acceptInvitation({ payload }) {
    if (!payload.token || !payload.userId) {
        yield put(actions.setAcceptInvitationState({ error: undefined, step: AcceptInvitationStep.invalid }));
        return;
    }
    try {
        yield put(actions.setAcceptInvitationState({ error: undefined, step: AcceptInvitationStep.pending }));
        yield call(api.auth.acceptInvitation, payload);
        yield put(actions.setState({
            isAuthenticated: false,
            user: null,
            acceptInvitationState: { error: undefined, step: AcceptInvitationStep.success },
        }));
    }
    catch (e) {
        yield put(actions.setAcceptInvitationState({ step: AcceptInvitationStep.failed, error: e.message }));
    }
}
function* acceptInvitationSagas() {
    yield takeLeading(actions.acceptInvitation, acceptInvitation);
}

var TeamStateKeys;
(function (TeamStateKeys) {
    TeamStateKeys["USERS"] = "USERS";
    TeamStateKeys["STATS"] = "STATS";
    TeamStateKeys["UPDATE_USER"] = "UPDATE_USER";
    TeamStateKeys["DELETE_USER"] = "DELETE_USER";
    TeamStateKeys["RESEND_ACTIVATE_LINK"] = "RESEND_ACTIVATE_LINK";
    TeamStateKeys["RESEND_INVITATION_LINK"] = "RESEND_INVITATION_LINK";
    TeamStateKeys["ROLES_AND_PERMISSIONS"] = "ROLES_AND_PERMISSIONS";
    TeamStateKeys["CREATE_TOKEN_LINK"] = "CREATE_TOKEN_LINK";
    TeamStateKeys["GET_TOKEN_LINK"] = "GET_TOKEN_LINK";
    TeamStateKeys["UPDATE_TOKEN_LINK"] = "UPDATE_TOKEN_LINK";
    TeamStateKeys["DELETE_TOKEN_LINK"] = "DELETE_TOKEN_LINK";
    TeamStateKeys["CONFIG_TOKEN_LINK"] = "CONFIG_TOKEN_LINK";
})(TeamStateKeys || (TeamStateKeys = {}));

const selectTeamState = () => select((_) => _[authStoreName].teamState);
function* loadUsers({ payload }) {
    var _a, _b, _c, _d;
    const { silentLoading, callback } = payload;
    const teamState = yield selectTeamState();
    const pageSize = (_a = payload.pageSize) !== null && _a !== void 0 ? _a : teamState.pageSize;
    const pageOffset = (_b = payload.pageOffset) !== null && _b !== void 0 ? _b : teamState.pageOffset;
    const filter = (_c = payload.filter) !== null && _c !== void 0 ? _c : teamState.filter;
    const sort = (_d = payload.sort) !== null && _d !== void 0 ? _d : teamState.sort;
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: !silentLoading }));
    yield put(actions.setTeamState({
        pageSize,
        pageOffset,
        filter,
        sort,
    }));
    try {
        const [{ items: users, totalPages, totalItems }, { items: roles }, { items: permissions }] = yield all([
            call(api.teams.loadUsers, {
                pageSize,
                pageOffset,
                filter,
                sort,
            }),
            call(api.teams.loadAvailableRoles),
            call(api.teams.loadAvailablePermissions),
        ]);
        yield put(actions.setTeamState({ users, totalPages, totalItems, roles, permissions }));
        callback === null || callback === void 0 ? void 0 : callback(users);
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.USERS, value: e.message }));
        yield put(actions.setTeamState({ totalPages: 0, users: [] }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: false }));
}
function* loadAllSubTenantsUsers({ payload, }) {
    var _a, _b, _c, _d, _e;
    const { silentLoading, callback } = payload;
    const teamState = yield selectTeamState();
    const _limit = (_a = payload._limit) !== null && _a !== void 0 ? _a : teamState.allUsersQueryParams._limit;
    const _offset = (_b = payload._offset) !== null && _b !== void 0 ? _b : teamState.allUsersQueryParams._offset;
    const _filter = (_c = payload._filter) !== null && _c !== void 0 ? _c : teamState.allUsersQueryParams._filter;
    const _sortBy = (_d = payload._sortBy) !== null && _d !== void 0 ? _d : teamState.allUsersQueryParams._sortBy;
    const _order = (_e = payload._order) !== null && _e !== void 0 ? _e : teamState.allUsersQueryParams._order;
    const allUsersQueryParams = {
        _limit: _limit || 20,
        _offset: _offset || 0,
        _filter: _filter || '',
        _sortBy: _sortBy || 'name',
        _order: _order || 'DESC',
    };
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: !silentLoading }));
    yield put(actions.setTeamState({
        allUsersQueryParams,
    }));
    try {
        const [{ items: users, _metadata: { totalPages, totalItems }, }, { items: roles }, { items: permissions },] = yield all([
            call(api.subTenants.loadAllUsers, Object.assign({}, allUsersQueryParams)),
            call(api.teams.loadAvailableRoles),
            call(api.teams.loadAvailablePermissions),
        ]);
        yield put(actions.setTeamState({
            allUsers: users,
            totalPages,
            totalItems,
            roles,
            permissions,
        }));
        callback === null || callback === void 0 ? void 0 : callback(users);
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.USERS, value: e.message }));
        yield put(actions.setTeamState({ totalPages: 0, users: [] }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: false }));
}
function* loadRoles({ payload }) {
    var _a, _b;
    yield put(actions.setTeamLoader({ key: TeamStateKeys.ROLES_AND_PERMISSIONS, value: true }));
    try {
        const [{ items: roles }, { items: permissions }] = yield all([
            call(api.teams.loadAvailableRoles),
            call(api.teams.loadAvailablePermissions),
        ]);
        yield put(actions.setTeamState({ roles, permissions }));
        (_a = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, { roles, permissions });
    }
    catch (e) {
        (_b = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, null, e);
        yield put(actions.setTeamError({ key: TeamStateKeys.ROLES_AND_PERMISSIONS, value: e.message }));
    }
    yield put(actions.setTeamLoader({ key: TeamStateKeys.ROLES_AND_PERMISSIONS, value: true }));
}
function* addUser({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }) }));
    try {
        const res = yield call(api.teams.addUser, body);
        const { roles } = res, userWithoutRoleIds = __rest(res, ["roles"]);
        const roleIds = roles.map((role) => role.id);
        const newUser = Object.assign(Object.assign({}, userWithoutRoleIds), { roleIds });
        callback === null || callback === void 0 ? void 0 : callback(newUser);
        yield put(actions.setTeamState({
            users: [newUser, ...teamState.users],
            addUserDialogState: { open: false, loading: false },
        }));
    }
    catch (e) {
        yield put(actions.setTeamState({
            addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: false, error: e.message }),
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* addUserToSubTenants({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }) }));
    try {
        yield call(api.subTenants.addUserToTenantAndSubTenants, body);
        const { items: users, _metadata: { totalPages, totalItems }, } = yield call(api.subTenants.loadAllUsers, {
            _limit: 20,
            _offset: 0,
            _filter: '',
            _sortBy: 'name',
            _order: 'DESC',
        });
        yield put(actions.setTeamState({
            allUsers: users,
            totalPages,
            totalItems,
            addUserDialogState: { open: false, loading: false },
        }));
        callback === null || callback === void 0 ? void 0 : callback(null);
    }
    catch (e) {
        yield put(actions.setTeamState({
            addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: false, error: e.message }),
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* updateUser({ payload }) {
    var _a;
    const { callback, profileImage } = payload, body = __rest(payload, ["callback", "profileImage"]);
    const { id: userId } = body;
    const teamState = yield selectTeamState();
    const oldUserData = teamState.users.find((user) => user.id === body.id);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.UPDATE_USER, value: userId || '' }));
    yield put(actions.setTeamState({ addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }) }));
    yield put(actions.setTeamState({
        addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }),
        users: teamState.users.map((user) => {
            if (user.id === body.id) {
                return Object.assign(Object.assign({}, user), body);
            }
            return user;
        }),
    }));
    try {
        if (oldUserData.roleIds.length > 0 && ((_a = body.roleIds) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            body.roleIds = [''];
        }
        const { item: newUser } = yield call(api.teams.updateUser, body);
        callback === null || callback === void 0 ? void 0 : callback(newUser);
        yield put(actions.setTeamState({
            users: teamState.users.map((user) => user.id === newUser.id
                ? Object.assign(Object.assign(Object.assign({}, user), newUser), { createdAt: user.createdAt, customData: user.customData, lastLogin: user.lastLogin }) : user),
        }));
        yield put(actions.setTeamLoader({ key: TeamStateKeys.UPDATE_USER, value: false }));
    }
    catch (e) {
        yield put(actions.setTeamState({
            addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: false, error: e.message }),
            users: teamState.users.map((user) => (user.id === body.id ? Object.assign(Object.assign({}, user), oldUserData) : user)),
        }));
        yield put(actions.setTeamLoader({ key: TeamStateKeys.UPDATE_USER, value: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* deleteUser({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ deleteUserDialogState: Object.assign(Object.assign({}, teamState.deleteUserDialogState), { loading: true }) }));
    try {
        yield call(api.teams.deleteUser, body);
        callback === null || callback === void 0 ? void 0 : callback(true);
        yield put(actions.setTeamState({
            users: teamState.users.filter((user) => user.id !== body.userId),
            deleteUserDialogState: { open: false, loading: false },
        }));
    }
    catch (e) {
        yield put(actions.setTeamState({
            deleteUserDialogState: Object.assign(Object.assign({}, teamState.deleteUserDialogState), { loading: false, error: e.message }),
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* setUserRolesForSubTenants({ payload, }) {
    const { callback, userId } = payload, body = __rest(payload, ["callback", "userId"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }) }));
    try {
        yield call(api.subTenants.setUserRolesForSubTenants, userId, body);
        const updatedUser = teamState.allUsers.find((user) => user.id === userId);
        let newTenants = [];
        if (updatedUser) {
            newTenants = updatedUser.tenants.map((tenant) => {
                var _a;
                return (Object.assign(Object.assign({}, tenant), { roles: ((_a = body.subTenantsRoles
                        .find((roleUpdate) => roleUpdate.tenantId === tenant.tenantId)) === null || _a === void 0 ? void 0 : _a.roleIds.map((roleId) => {
                        const role = teamState.roles.find(({ id }) => roleId === id);
                        return role;
                    }).filter((role) => role)) || tenant.roles }));
            });
        }
        yield put(actions.setTeamState({
            allUsers: [
                ...teamState.allUsers.filter((user) => user.id !== userId),
                ...(updatedUser ? [Object.assign(Object.assign({}, updatedUser), { tenants: newTenants })] : []),
            ],
            addUserDialogState: { open: false, loading: false },
        }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setTeamState({
            addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: false, error: e.message }),
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* deleteUserFromSubTenants({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ deleteUserDialogState: Object.assign(Object.assign({}, teamState.deleteUserDialogState), { loading: true }) }));
    try {
        yield call(api.subTenants.removeUserFromTenantAndSubTenants, body);
        callback === null || callback === void 0 ? void 0 : callback(true);
        yield put(actions.setTeamState({
            allUsers: teamState.allUsers.filter((user) => user.id !== body.userId && user.tenants.length === body.subTenants.length),
            deleteUserDialogState: { open: false, loading: false },
        }));
    }
    catch (e) {
        yield put(actions.setTeamState({
            deleteUserDialogState: Object.assign(Object.assign({}, teamState.deleteUserDialogState), { loading: false, error: e.message }),
        }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* resendActivationLink({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_ACTIVATE_LINK, value: body.userId }));
    try {
        yield call(api.teams.resendActivationLink, body);
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.RESEND_ACTIVATE_LINK, value: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_ACTIVATE_LINK, value: false }));
}
function* resendInvitationLink({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: body.email }));
    try {
        yield call(api.teams.resendInvitationLink, body);
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: false }));
}
function* resendInvitationLinkToAllSubTenants({ payload, }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: body.email }));
    try {
        yield call(api.teams.resendInvitationLinkToAllTenants, body);
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: false }));
}
function* getInvitationLinkConfig() {
    yield put(actions.setTeamError({ key: TeamStateKeys.CONFIG_TOKEN_LINK, value: false }));
    try {
        const invitationLinkConfig = yield call(api.teams.getInviteLinkConfiguration);
        yield put(actions.setTeamState({ inviteTokenState: Object.assign({}, invitationLinkConfig) }));
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.CONFIG_TOKEN_LINK, value: e.message }));
    }
}
function* getInvitationLink() {
    yield put(actions.setTeamError({ key: TeamStateKeys.GET_TOKEN_LINK, value: false }));
    try {
        yield call(getInvitationLinkConfig);
        const data = yield call(api.teams.getInviteUserLink);
        const { inviteTokenState } = yield selectTeamState();
        yield put(actions.setTeamState({ inviteTokenState: Object.assign(Object.assign({}, inviteTokenState), data) }));
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.GET_TOKEN_LINK, value: e.message }));
    }
}
function* createInvitationLink({ payload: { callback }, }) {
    yield put(actions.setTeamError({ key: TeamStateKeys.CREATE_TOKEN_LINK, value: false }));
    const { inviteTokenState } = yield selectTeamState();
    try {
        const data = yield call(api.teams.createInviteUserLink, { expiresInMinutes: 43200 });
        yield put(actions.setTeamState({ inviteTokenState: Object.assign(Object.assign({}, inviteTokenState), data) }));
        callback === null || callback === void 0 ? void 0 : callback(data.token);
    }
    catch (e) {
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
        yield put(actions.setTeamError({ key: TeamStateKeys.CREATE_TOKEN_LINK, value: e.message }));
    }
}
function* updateInvitationLink({ payload: { callback, expiresInMinutes, shouldSendEmail }, }) {
    const { inviteTokenState } = yield selectTeamState();
    yield put(actions.setTeamError({ key: TeamStateKeys.UPDATE_TOKEN_LINK, value: false }));
    try {
        const data = yield call(api.teams.updateInviteUserLink, { expiresInMinutes, shouldSendEmail });
        yield put(actions.setTeamState({ inviteTokenState: Object.assign(Object.assign({}, inviteTokenState), data) }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
        yield put(actions.setTeamError({ key: TeamStateKeys.UPDATE_TOKEN_LINK, value: e.message }));
    }
}
function* deleteInvitationLink({ payload }) {
    const { callback } = payload !== null && payload !== void 0 ? payload : {};
    yield put(actions.setTeamError({ key: TeamStateKeys.DELETE_TOKEN_LINK, value: false }));
    try {
        yield call(api.teams.deleteInviteUserLink);
        yield put(actions.setTeamState({ inviteTokenState: undefined }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setTeamError({ key: TeamStateKeys.DELETE_TOKEN_LINK, value: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(false, e.message);
    }
}
function* openAddUserDialog({ payload }) {
    yield put(actions.setTeamState({
        addUserDialogState: Object.assign({ open: true, loading: false, error: false }, payload),
    }));
}
function* closeAddUserDialog({ payload }) {
    const teamState = yield selectTeamState();
    const { addUserDialogState: { onClose }, } = teamState;
    onClose === null || onClose === void 0 ? void 0 : onClose(payload);
    yield put(actions.setTeamState({
        addUserDialogState: {
            loading: false,
            error: false,
            open: false,
        },
    }));
}
function* openDeleteUserDialog({ payload }) {
    yield put(actions.setTeamState({
        deleteUserDialogState: Object.assign({ open: true, loading: false, error: false }, payload),
    }));
}
function* closeDeleteUserDialog({ payload }) {
    const teamState = yield selectTeamState();
    const { deleteUserDialogState: { onClose }, } = teamState;
    onClose === null || onClose === void 0 ? void 0 : onClose(payload);
    yield put(actions.setTeamState({
        deleteUserDialogState: {
            loading: false,
            error: false,
            open: false,
        },
    }));
}
function* teamSagas() {
    yield takeLatest(actions.loadUsers, loadUsers);
    yield takeLatest(actions.loadAllSubTenantsUsers, loadAllSubTenantsUsers);
    yield takeLatest(actions.loadRoles, loadRoles);
    yield takeEvery(actions.addUser, addUser);
    yield takeEvery(actions.addUserToSubTenants, addUserToSubTenants);
    yield takeEvery(actions.updateUser, updateUser);
    yield takeEvery(actions.setUserRolesForSubTenants, setUserRolesForSubTenants);
    yield takeEvery(actions.deleteUser, deleteUser);
    yield takeEvery(actions.deleteUserFromSubTenants, deleteUserFromSubTenants);
    yield takeEvery(actions.resendActivationLink, resendActivationLink);
    yield takeEvery(actions.resendInvitationLink, resendInvitationLink);
    yield takeEvery(actions.resendInvitationLinkToAllSubTenants, resendInvitationLinkToAllSubTenants);
    yield takeEvery(actions.getInvitationLink, getInvitationLink);
    yield takeEvery(actions.createInvitationLink, createInvitationLink);
    yield takeEvery(actions.updateInvitationLink, updateInvitationLink);
    yield takeEvery(actions.deleteInvitationLink, deleteInvitationLink);
    yield takeEvery(actions.openAddUserDialog, openAddUserDialog);
    yield takeEvery(actions.closeAddUserDialog, closeAddUserDialog);
    yield takeEvery(actions.openDeleteUserDialog, openDeleteUserDialog);
    yield takeEvery(actions.closeDeleteUserDialog, closeDeleteUserDialog);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* loadUsersMock({ payload }) {
    var _a, _b, _c, _d;
    const { silentLoading, callback } = payload;
    const teamState = yield selectTeamState();
    const pageSize = (_a = payload.pageSize) !== null && _a !== void 0 ? _a : teamState.pageSize;
    const pageOffset = (_b = payload.pageOffset) !== null && _b !== void 0 ? _b : teamState.pageOffset;
    const filter = (_c = payload.filter) !== null && _c !== void 0 ? _c : teamState.filter;
    const sort = (_d = payload.sort) !== null && _d !== void 0 ? _d : teamState.sort;
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: !silentLoading }));
    yield put(actions.setTeamState({
        pageSize,
        pageOffset,
        filter,
        sort,
    }));
    const totalPages = 2;
    const totalItems = 10;
    yield delay();
    yield put(actions.setTeamState({ users: usersDemo, totalPages, totalItems, roles: rolesDemo, permissions: permissionsDemo }));
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: false }));
    callback === null || callback === void 0 ? void 0 : callback(usersDemo);
}
function* loadAllSubTenantsUsersMock({ payload, }) {
    var _a, _b, _c, _d, _e;
    const { silentLoading, callback } = payload;
    const teamState = yield selectTeamState();
    const _limit = (_a = payload._limit) !== null && _a !== void 0 ? _a : teamState.allUsersQueryParams._limit;
    const _offset = (_b = payload._offset) !== null && _b !== void 0 ? _b : teamState.allUsersQueryParams._offset;
    const _filter = (_c = payload._filter) !== null && _c !== void 0 ? _c : teamState.allUsersQueryParams._filter;
    const _sortBy = (_d = payload._sortBy) !== null && _d !== void 0 ? _d : teamState.allUsersQueryParams._sortBy;
    const _order = (_e = payload._order) !== null && _e !== void 0 ? _e : teamState.allUsersQueryParams._order;
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: !silentLoading }));
    yield put(actions.setTeamState({
        allUsersQueryParams: {
            _limit,
            _offset,
            _filter,
            _sortBy,
            _order,
        },
    }));
    const totalPages = 2;
    const totalItems = 10;
    yield delay();
    yield put(actions.setTeamState({
        allUsers: allUsersDemo,
        totalPages,
        totalItems,
        roles: rolesDemo,
        permissions: permissionsDemo,
    }));
    yield put(actions.setTeamLoader({ key: TeamStateKeys.USERS, value: false }));
    callback === null || callback === void 0 ? void 0 : callback(allUsersDemo);
}
function* loadRolesMock({ payload }) {
    var _a;
    yield put(actions.setTeamLoader({ key: TeamStateKeys.ROLES_AND_PERMISSIONS, value: true }));
    yield delay();
    yield put(actions.setTeamState({ roles: rolesDemo, permissions: permissionsDemo }));
    yield put(actions.setTeamLoader({ key: TeamStateKeys.ROLES_AND_PERMISSIONS, value: true }));
    (_a = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, { roles: rolesDemo, permissions: permissionsDemo });
}
function* addUserMock({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }) }));
    yield delay();
    const newUser = Object.assign(Object.assign(Object.assign({}, userTeamDemo), body), { id: `${v4()}` });
    callback === null || callback === void 0 ? void 0 : callback(newUser);
    yield put(actions.setTeamState({
        users: [newUser, ...teamState.users],
        addUserDialogState: { open: false, loading: false },
    }));
}
function* addUserToSubTenantsMock({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }) }));
    yield delay();
    const newUser = Object.assign(Object.assign(Object.assign({}, userTeamDemo), body), { id: `${v4()}` });
    yield put(actions.setTeamState({
        users: [newUser, ...teamState.users],
        addUserDialogState: { open: false, loading: false },
    }));
    callback === null || callback === void 0 ? void 0 : callback(null);
}
function* updateUserMock({ payload }) {
    var _a;
    const { callback, profileImage } = payload, body = __rest(payload, ["callback", "profileImage"]);
    const { id: userId } = body;
    const teamState = yield selectTeamState();
    const oldUserData = teamState.users.find((user) => user.id === body.id);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.UPDATE_USER, value: userId || '' }));
    yield put(actions.setTeamState({ addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }) }));
    yield put(actions.setTeamState({
        addUserDialogState: Object.assign(Object.assign({}, teamState.addUserDialogState), { loading: true }),
        users: teamState.users.map((user) => {
            if (user.id === body.id) {
                return Object.assign(Object.assign({}, user), body);
            }
            return user;
        }),
    }));
    if (oldUserData.roleIds.length > 0 && ((_a = body.roleIds) === null || _a === void 0 ? void 0 : _a.length) === 0) {
        body.roleIds = [''];
    }
    yield delay();
    const newUser = Object.assign(Object.assign({}, oldUserData), body);
    callback === null || callback === void 0 ? void 0 : callback(newUser);
    yield put(actions.setTeamState({
        users: teamState.users.map((user) => user.id === newUser.id
            ? Object.assign(Object.assign(Object.assign({}, user), newUser), { createdAt: user.createdAt, customData: user.customData, lastLogin: user.lastLogin }) : user),
    }));
    yield put(actions.setTeamLoader({ key: TeamStateKeys.UPDATE_USER, value: false }));
}
function* deleteUserMock({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ deleteUserDialogState: Object.assign(Object.assign({}, teamState.deleteUserDialogState), { loading: true }) }));
    yield delay();
    callback === null || callback === void 0 ? void 0 : callback(true);
    yield put(actions.setTeamState({
        users: teamState.users.filter((user) => user.id !== body.userId),
        deleteUserDialogState: { open: false, loading: false },
    }));
}
function* deleteUserFromSubTenantsMock({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    const teamState = yield selectTeamState();
    yield put(actions.setTeamState({ deleteUserDialogState: Object.assign(Object.assign({}, teamState.deleteUserDialogState), { loading: true }) }));
    yield delay();
    callback === null || callback === void 0 ? void 0 : callback(true);
    yield put(actions.setTeamState({
        allUsers: teamState.allUsers.filter((user) => user.id !== body.userId),
        deleteUserDialogState: { open: false, loading: false },
    }));
}
function* resendActivationLinkMock({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_ACTIVATE_LINK, value: body.userId }));
    yield delay();
    callback === null || callback === void 0 ? void 0 : callback(true);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_ACTIVATE_LINK, value: false }));
}
function* resendInvitationLinkMock({ payload }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: body.email }));
    yield delay();
    callback === null || callback === void 0 ? void 0 : callback(true);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: false }));
}
function* resendInvitationLinkToAllSubTenantsMock({ payload, }) {
    const { callback } = payload, body = __rest(payload, ["callback"]);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: body.email }));
    yield delay();
    callback === null || callback === void 0 ? void 0 : callback(true);
    yield put(actions.setTeamLoader({ key: TeamStateKeys.RESEND_INVITATION_LINK, value: false }));
}
function* teamSagasMock() {
    yield takeLatest(actions.loadUsers, loadUsersMock);
    yield takeLatest(actions.loadAllSubTenantsUsers, loadAllSubTenantsUsersMock);
    yield takeLatest(actions.loadRoles, loadRolesMock);
    yield takeEvery(actions.addUser, addUserMock);
    yield takeEvery(actions.addUserToSubTenants, addUserToSubTenantsMock);
    yield takeEvery(actions.updateUser, updateUserMock);
    yield takeEvery(actions.deleteUser, deleteUserMock);
    yield takeEvery(actions.deleteUserFromSubTenants, deleteUserFromSubTenantsMock);
    yield takeEvery(actions.resendActivationLink, resendActivationLinkMock);
    yield takeEvery(actions.resendInvitationLink, resendInvitationLinkMock);
    yield takeEvery(actions.resendInvitationLinkToAllSubTenants, resendInvitationLinkToAllSubTenantsMock);
    yield takeEvery(actions.openAddUserDialog, openAddUserDialog);
    yield takeEvery(actions.closeAddUserDialog, closeAddUserDialog);
    yield takeEvery(actions.openDeleteUserDialog, openDeleteUserDialog);
    yield takeEvery(actions.closeDeleteUserDialog, closeDeleteUserDialog);
}

function* loadSocialLoginsConfigurations() {
    try {
        yield put(actions.setSocialLoginsState({ loading: true }));
        const socialLoginsConfig = yield call(api.auth.getSocialLoginProviders);
        yield put(actions.setSocialLoginsState({ socialLoginsConfig, loading: false, firstLoad: false }));
    }
    catch (e) {
        yield put(actions.setSocialLoginsState({ error: e.message, loading: false, firstLoad: false }));
    }
}
function* loadSocialLoginsConfigurationsV2() {
    try {
        const context = yield select((state) => state.root.context);
        yield put(actions.setSocialLoginsState({ loading: true }));
        const socialLoginsConfigV2 = yield call(api.auth.getSocialLoginProvidersV2);
        const socialLoginsConfigWithFullUrl = socialLoginsConfigV2.map((_a) => {
            var { authorizationUrl } = _a, config = __rest(_a, ["authorizationUrl"]);
            const baseUrl = fetch.getBaseUrl(context, authorizationUrl !== null && authorizationUrl !== void 0 ? authorizationUrl : '');
            return (Object.assign(Object.assign({}, config), { authorizationUrl: authorizationUrl ? `${baseUrl}${authorizationUrl}` : null }));
        });
        yield put(actions.setSocialLoginsState({ socialLoginsConfigV2: socialLoginsConfigWithFullUrl, loading: false, firstLoad: false }));
    }
    catch (e) {
        yield put(actions.setSocialLoginsState({ error: e.message, loading: false, firstLoad: false }));
    }
}
function* loginViaSocialLogin(_a) {
    var _b, _c, _d;
    var _e = _a.payload, { events, url } = _e, payload = __rest(_e, ["events", "url"]);
    try {
        yield put(actions.setSocialLoginsState({ loading: true }));
        const { email, isNewUser, userId, tenantId, name, } = yield call(api.auth.loginViaSocialLogin, payload);
        if (isNewUser) {
            (_b = events === null || events === void 0 ? void 0 : events.signUpComplete) === null || _b === void 0 ? void 0 : _b.call(events, {
                email,
                url,
                authenticationType: AuthenticationTypes.SOCIAL_LOGIN,
                createdAt: new Date(),
                id: userId,
                socialProvider: payload.provider,
                tenantId,
            });
            (_c = events === null || events === void 0 ? void 0 : events.userVerified) === null || _c === void 0 ? void 0 : _c.call(events, {
                email,
                origin: UserVeirifedOriginTypes.SOCIAL_LOGIN,
                createdAt: new Date(),
                id: userId,
                url,
                tenantId,
                name,
            });
        }
        if (email) {
            localStorage.setItem('email', email);
            localStorage.setItem('name', name);
        }
        yield put(actions.setLoginState({ email, isNewUser }));
        yield refreshToken();
        localStorage.removeItem('register-quick-login');
        yield put(actions.setSocialLoginsState({ loading: false }));
    }
    catch (e) {
        yield put(actions.setSocialLoginsState({ loading: false, error: (_d = e.message) !== null && _d !== void 0 ? _d : 'Failed to authenticate', firstLoad: false }));
    }
}
function* setSocialLoginError({ payload }) {
    yield put(actions.setSocialLoginsState({ error: payload.error, loading: false, firstLoad: false }));
}
function* socialLoginsSaga() {
    yield takeLeading(actions.loadSocialLoginsConfiguration, loadSocialLoginsConfigurations);
    yield takeLeading(actions.loadSocialLoginsConfigurationV2, loadSocialLoginsConfigurationsV2);
    yield takeLeading(actions.loginViaSocialLogin, loginViaSocialLogin);
    yield takeLatest(actions.setSocialLoginError, setSocialLoginError);
}

var ApiStateKeys;
(function (ApiStateKeys) {
    ApiStateKeys["LOAD_API_TOKENS"] = "LOAD_API_TOKENS";
    ApiStateKeys["ADD_API_TOKEN"] = "ADD_API_TOKEN";
    ApiStateKeys["DELETE_API_TOKEN"] = "DELETE_API_TOKEN";
})(ApiStateKeys || (ApiStateKeys = {}));

function* loadApiTokensData({ payload: apiTokenType }) {
    yield put(actions.setApiTokensState({ apiTokenType }));
    try {
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: true }));
        if (apiTokenType === 'user') {
            const apiTokensData = yield call(api.auth.getUserApiTokensData);
            yield put(actions.setApiTokensState({ apiTokensDataUser: apiTokensData !== null && apiTokensData !== void 0 ? apiTokensData : [] }));
        }
        else {
            const apiTenantTokensData = yield call(api.auth.getTenantApiTokensData);
            const { items: roles } = yield call(api.teams.loadAvailableRoles);
            const { items: permissions } = yield call(api.teams.loadAvailablePermissions);
            yield put(actions.setApiTokensState({
                apiTokensDataTenant: apiTenantTokensData !== null && apiTenantTokensData !== void 0 ? apiTenantTokensData : [],
                roles: roles !== null && roles !== void 0 ? roles : [],
                permissions: permissions !== null && permissions !== void 0 ? permissions : [],
            }));
        }
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: false }));
    }
    catch (e) {
        yield put(actions.setApiTokensError({ key: ApiStateKeys.LOAD_API_TOKENS, value: e.message }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: false }));
    }
}
function* addUserApiToken({ payload }) {
    const { description, callback } = payload;
    const { apiTokensDataUser } = yield select((state) => state.auth.apiTokensState);
    try {
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: true }));
        const data = yield call(api.auth.updateUserApiTokensData, { description });
        yield put(actions.setApiTokensState({ showAddTokenDialog: false }));
        yield delay$1(200);
        yield put(actions.setApiTokensState({
            apiTokensDataUser: [data, ...apiTokensDataUser],
            successDialog: { open: true, secret: data.secret, clientId: data.clientId },
        }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: false }));
        callback === null || callback === void 0 ? void 0 : callback(null);
    }
    catch (e) {
        yield put(actions.setApiTokensError({ key: ApiStateKeys.ADD_API_TOKEN, value: e.message }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* addTenantApiToken({ payload }) {
    const { description, roleIds, callback } = payload;
    const { apiTokensDataTenant } = yield select((state) => state.auth.apiTokensState);
    try {
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: true }));
        const data = yield call(api.auth.updateTenantApiTokensData, { description, roleIds });
        yield put(actions.setApiTokensState({ showAddTokenDialog: false }));
        yield delay$1(200);
        yield put(actions.setApiTokensState({
            apiTokensDataTenant: [data, ...apiTokensDataTenant],
            successDialog: { open: true, secret: data.secret, clientId: data.clientId },
        }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: false }));
        callback === null || callback === void 0 ? void 0 : callback(null);
    }
    catch (e) {
        yield put(actions.setApiTokensError({ key: ApiStateKeys.ADD_API_TOKEN, value: e.message }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
}
function* deleteUserApiToken({ payload }) {
    const { apiTokensDataUser } = yield select((state) => state.auth.apiTokensState);
    try {
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: true }));
        yield call(api.auth.deleteUserApiToken, { tokenId: payload });
        yield put(actions.setApiTokensState({
            apiTokensDataUser: apiTokensDataUser.filter((i) => i.clientId !== payload),
            deleteTokenDialog: { open: false, clientId: payload },
        }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: false }));
    }
    catch (e) {
        yield put(actions.setApiTokensError({ key: ApiStateKeys.DELETE_API_TOKEN, value: e.message }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: false }));
    }
}
function* deleteTenantApiToken({ payload }) {
    const { apiTokensDataTenant } = yield select((state) => state.auth.apiTokensState);
    try {
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: true }));
        yield call(api.auth.deleteTenantApiToken, { tokenId: payload });
        yield put(actions.setApiTokensState({
            apiTokensDataTenant: apiTokensDataTenant.filter((i) => i.clientId !== payload),
            deleteTokenDialog: { open: false, clientId: payload },
        }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: false }));
    }
    catch (e) {
        yield put(actions.setApiTokensError({ key: ApiStateKeys.DELETE_API_TOKEN, value: e.message }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: false }));
    }
}
function* loadApiTokens({ payload }) {
    var _a, _b;
    if (!(payload === null || payload === void 0 ? void 0 : payload.silentLoading)) {
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: true }));
    }
    try {
        const [apiTokensDataUser = [], apiTokensDataTenant = []] = yield all([
            call(api.auth.getUserApiTokensData),
            call(api.auth.getTenantApiTokensData),
        ]);
        yield put(actions.setApiTokensState({
            apiTokensDataUser,
            apiTokensDataTenant,
        }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: false }));
        (_a = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
    }
    catch (e) {
        yield put(actions.setApiTokensError({ key: ApiStateKeys.LOAD_API_TOKENS, value: e.message }));
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: false }));
        (_b = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, null, e);
    }
}
function* apiTokensSaga() {
    yield takeLeading(actions.loadApiTokens, loadApiTokens);
    yield takeLeading(actions.initApiTokensData, loadApiTokensData);
    yield takeEvery(actions.addUserApiToken, addUserApiToken);
    yield takeEvery(actions.addTenantApiToken, addTenantApiToken);
    yield takeLatest(actions.deleteTenantApiToken, deleteTenantApiToken);
    yield takeLatest(actions.deleteUserApiToken, deleteUserApiToken);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* loadApiTokensDataMock({ payload: apiTokenType }) {
    var _a;
    yield put(actions.setApiTokensState({ apiTokenType }));
    yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: true }));
    if (apiTokenType === 'user') {
        yield delay$1(200);
        const apiTokensData = [apiTokensDataDemo];
        yield put(actions.setApiTokensState({ apiTokensDataUser: apiTokensData !== null && apiTokensData !== void 0 ? apiTokensData : [] }));
    }
    else {
        yield delay$1(200);
        yield put(actions.setApiTokensState({
            apiTokensDataTenant: (_a = [apiTokensDataTenantDemo]) !== null && _a !== void 0 ? _a : [],
            roles: rolesDemo !== null && rolesDemo !== void 0 ? rolesDemo : [],
            permissions: permissionsDemo !== null && permissionsDemo !== void 0 ? permissionsDemo : [],
        }));
    }
    yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: false }));
}
function* addTenantApiTokenMock({ payload }) {
    const { description, roleIds, callback } = payload;
    yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: true }));
    const { apiTokensDataTenant } = yield select((state) => state.auth.apiTokensState);
    const newToken = Object.assign(Object.assign({}, apiTokensDataTenantDemo), { description,
        roleIds, clientId: `CLIENT_ID_${v4()}` });
    yield put(actions.setApiTokensState({ showAddTokenDialog: false }));
    yield delay$1(200);
    yield put(actions.setApiTokensState({
        apiTokensDataTenant: [...apiTokensDataTenant, newToken],
        successDialog: { open: true, secret: newToken.secret, clientId: newToken.clientId },
    }));
    yield delay$1(200);
    yield put(actions.setApiTokensLoader({ key: ApiStateKeys.ADD_API_TOKEN, value: false }));
    callback === null || callback === void 0 ? void 0 : callback(null);
}
function* deleteTenantApiTokenMock({ payload }) {
    yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: true }));
    yield delay$1(200);
    const apiTokensDataTenant = [apiTokensDataTenantDemo];
    yield put(actions.setApiTokensState({
        apiTokensDataTenant: apiTokensDataTenant.filter((i) => i.clientId !== payload),
        deleteTokenDialog: { open: false, clientId: payload },
    }));
    yield put(actions.setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: false }));
}
function* loadApiTokensMock({ payload }) {
    var _a;
    if (!(payload === null || payload === void 0 ? void 0 : payload.silentLoading)) {
        yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: true }));
    }
    const apiTokensDataUser = [apiTokensDataDemo];
    const apiTokensDataTenant = [apiTokensDataTenantDemo];
    yield put(actions.setApiTokensState({
        apiTokensDataUser,
        apiTokensDataTenant,
    }));
    yield delay$1(200);
    yield put(actions.setApiTokensLoader({ key: ApiStateKeys.LOAD_API_TOKENS, value: false }));
    (_a = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
}
function* apiTokensSagaMock() {
    yield takeLeading(actions.loadApiTokens, loadApiTokensMock);
    yield takeLeading(actions.initApiTokensData, loadApiTokensDataMock);
    yield takeEvery(actions.addTenantApiToken, addTenantApiTokenMock);
    yield takeLatest(actions.deleteTenantApiToken, deleteTenantApiTokenMock);
}

function* saveAccountSettings({ payload }) {
    var _a, _b;
    try {
        yield put(actions.setAccountSettingsState({ loading: true }));
        const { accountSettingsState } = yield select((state) => state.auth);
        const { address, timezone, dateFormat, timeFormat, currency, logo } = accountSettingsState;
        const body = yield call(api.accountSettings.updateSettings, Object.assign({ address,
            timezone,
            dateFormat,
            timeFormat,
            currency,
            logo }, payload));
        yield put(actions.setAccountSettingsState(Object.assign(Object.assign({}, body), { loading: false })));
        (_a = payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, body);
    }
    catch (e) {
        yield put(actions.setAccountSettingsState({ loading: false, error: e.message }));
        (_b = payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, null, e);
    }
}
function* loadAccountSettings({ payload }) {
    yield put(actions.setAccountSettingsState({ loading: !(payload === null || payload === void 0 ? void 0 : payload.silentLoading), error: null }));
    try {
        const body = yield call(api.accountSettings.getSettings);
        yield put(actions.setAccountSettingsState(Object.assign(Object.assign({}, body), { loading: false })));
    }
    catch (e) {
        yield put(actions.setAccountSettingsState({ loading: false, error: e.message }));
    }
}
function* accountSettingsSaga() {
    yield takeLeading(actions.saveAccountSettings, saveAccountSettings);
    yield takeLeading(actions.loadAccountSettings, loadAccountSettings);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* saveAccountSettingsMock({ payload }) {
    var _a;
    yield put(actions.setAccountSettingsState({ loading: true }));
    yield delay();
    const { accountSettingsState } = yield select((state) => state.auth);
    const { address, timezone, dateFormat, timeFormat, currency, logo } = accountSettingsState;
    const body = Object.assign({ address,
        timezone,
        dateFormat,
        timeFormat,
        currency,
        logo }, payload);
    yield put(actions.setAccountSettingsState(Object.assign(Object.assign({}, body), { loading: false })));
    (_a = payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, body);
}
function* loadAccountSettingsMock({ payload }) {
    yield put(actions.setAccountSettingsState({ loading: !(payload === null || payload === void 0 ? void 0 : payload.silentLoading), error: null }));
    yield delay();
    yield put(actions.setAccountSettingsState({
        address: 'Tel-aviv',
        timezone: 'Asia/Jerusalem',
        dateFormat: 'DD/MM/YYYY',
        timeFormat: 'HH:mm',
        currency: 'USD',
        loading: false,
    }));
}
function* accountSettingsSagaMock() {
    yield takeLeading(actions.saveAccountSettings, saveAccountSettingsMock);
    yield takeLeading(actions.loadAccountSettings, loadAccountSettingsMock);
}

function* switchTenant({ payload: { tenantId, callback } }) {
    yield put(actions.setState({ isLoading: true }));
    try {
        yield call(api.tenants.switchTenant, { tenantId });
        yield call(refreshToken);
        const callbackConsumed = callback === null || callback === void 0 ? void 0 : callback(true);
        if (!callbackConsumed) {
            yield put(actions.setState({ isLoading: false }));
        }
    }
    catch (e) {
        yield put(actions.setState({ isLoading: false }));
        callback === null || callback === void 0 ? void 0 : callback(false, e);
    }
}
function* loadTenants({ payload }) {
    var _a, _b;
    yield put(actions.setTenantsState({ loading: true }));
    try {
        const tenants = yield call(api.tenants.getTenants);
        yield put(actions.setTenantsState({ tenants, loading: false }));
        (_a = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, []);
    }
    catch (e) {
        (_b = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, [], e);
        yield put(actions.setTenantsState({ loading: false }));
    }
}
function* loadSubTenants({ payload }) {
    var _a, _b;
    yield put(actions.setTenantsState({ loading: true }));
    try {
        const subTenants = yield call(api.tenants.getSubTenants);
        yield put(actions.setTenantsState({ subTenants, loading: false }));
        (_a = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
    }
    catch (e) {
        yield put(actions.setTenantsState({ loading: false }));
        (_b = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, null, e);
    }
}
function* loadSubTenantsTree({ payload }) {
    var _a, _b;
    yield put(actions.setTenantsState({ loading: true }));
    try {
        const tenantTree = yield call(api.tenants.getSubTenantsAsTree);
        yield put(actions.setTenantsState({ tenantTree, loading: false }));
        (_a = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _a === void 0 ? void 0 : _a.call(payload, true);
    }
    catch (e) {
        yield put(actions.setTenantsState({ loading: false }));
        (_b = payload === null || payload === void 0 ? void 0 : payload.callback) === null || _b === void 0 ? void 0 : _b.call(payload, null, e);
    }
}
function* tenantsSagas() {
    yield takeEvery(actions.loadTenants, loadTenants);
    yield takeEvery(actions.loadSubTenants, loadSubTenants);
    yield takeEvery(actions.switchTenant, switchTenant);
    yield takeEvery(actions.loadSubTenantsTree, loadSubTenantsTree);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* loadTenantsMock({}) {
    yield put(actions.setTenantsState({ loading: true }));
    yield delay();
    yield put(actions.setTenantsState({ tenants: tenantsDemo, loading: false }));
}
function* tenantsSagasMock() {
    yield takeEvery(actions.loadTenants, loadTenantsMock);
}

function* loadRolesAndPermissions({ payload }) {
    var _a;
    yield put(actions.setRolesState({ loading: !((_a = payload === null || payload === void 0 ? void 0 : payload.silentLoading) !== null && _a !== void 0 ? _a : false), error: null }));
    try {
        const result = yield all([
            call(api.roles.getRoles),
            call(api.roles.getPermissions),
            call(api.roles.getPermissionCategories),
        ]);
        const [roles, permissions, permissionCategories] = result;
        yield put(actions.setRolesState({ roles, permissions, permissionCategories, loading: false }));
    }
    catch (e) {
        yield put(actions.setRolesState({ error: e.message, loading: false }));
    }
}
function* addRole(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setRolesState({ saving: true }));
    try {
        const role = yield call(api.roles.addRole, body);
        const roles = yield call(api.roles.getRoles);
        yield put(actions.loadRolesAndPermissions({ silentLoading: true }));
        yield put(actions.setRolesState({ roles, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(role);
    }
    catch (e) {
        yield put(actions.setRolesState({ error: e.message, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* deleteRole(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setRolesState({ saving: true }));
    try {
        yield call(api.roles.deleteRole, body);
        yield put(actions.loadRolesAndPermissions({ silentLoading: true }));
        yield put(actions.setRolesState({ saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setRolesState({ error: e.message, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(false, e);
    }
}
function* updateRole(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setRolesState({ saving: true }));
    try {
        const role = yield call(api.roles.updateRole, body);
        yield put(actions.loadRolesAndPermissions({ silentLoading: true }));
        yield put(actions.setRolesState({ saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(role);
    }
    catch (e) {
        yield put(actions.setRolesState({ error: e.message, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* attachPermissionsToRole(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setRolesState({ saving: true }));
    try {
        const role = yield call(api.roles.attachPermissionsToRole, body);
        yield put(actions.loadRolesAndPermissions({ silentLoading: true }));
        yield put(actions.setRolesState({ saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(role);
    }
    catch (e) {
        yield put(actions.setRolesState({ error: e.message, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* attachPermissionToRoles(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setRolesState({ saving: true }));
    try {
        const permission = yield call(api.roles.attachPermissionToRoles, body);
        yield put(actions.loadRolesAndPermissions({ silentLoading: true }));
        yield put(actions.setRolesState({ saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(permission);
    }
    catch (e) {
        yield put(actions.setRolesState({ error: e.message, saving: false }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* rolesSagas() {
    yield takeLeading(actions.loadRolesAndPermissions, loadRolesAndPermissions);
    yield takeEvery(actions.addRole, addRole);
    yield takeEvery(actions.deleteRole, deleteRole);
    yield takeEvery(actions.updateRole, updateRole);
    yield takeEvery(actions.attachPermissionsToRole, attachPermissionsToRole);
    yield takeEvery(actions.attachPermissionToRoles, attachPermissionToRoles);
}

function* resetPhoneNumber(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setResetPhoneNumberState({ loading: true }));
    try {
        const res = yield call(api.auth.resetPhoneNumber, body);
        yield put(actions.setResetPhoneNumberState({ loading: false, error: undefined, resetPhoneNumberToken: res.resetPhoneNumberToken, step: ResetPhoneNumberStep.VerifyResetPhoneNumber }));
        yield put(actions.setLoginState({ email: body.email }));
    }
    catch (e) {
        yield put(actions.setResetPhoneNumberState({ loading: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* verifyResetPhoneNumber(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setResetPhoneNumberState({ loading: true }));
    try {
        const res = yield call(api.auth.verifyResetPhoneNumber, body);
        yield put(actions.setResetPhoneNumberState({ loading: false, error: undefined, changePhoneNumberToken: res.changePhoneNumberToken, step: ResetPhoneNumberStep.ChangePhoneNumber }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setResetPhoneNumberState({ loading: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* changePhoneNumber(_a) {
    var _b = _a.payload, { callback } = _b, body = __rest(_b, ["callback"]);
    yield put(actions.setResetPhoneNumberState({ loading: true }));
    try {
        const { onRedirectTo, routes } = yield select(({ auth: { onRedirectTo, routes } }) => ({ onRedirectTo, routes }));
        yield call(api.auth.changePhoneNumber, { phoneNumber: body.phoneNumber, changePhoneNumberToken: body.changePhoneNumberToken });
        yield put(actions.setLoginState({ step: LoginStep.loginWithSmsOtc }));
        yield put(actions.passwordlessPreLogin({
            type: AuthStrategyEnum.SmsCode,
            email: body.email,
            recaptchaToken: body.recaptchaToken,
        }));
        onRedirectTo(routes.loginUrl);
        yield put(actions.setResetPhoneNumberState({ loading: false }));
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setResetPhoneNumberState({ loading: false, error: e.message }));
        callback === null || callback === void 0 ? void 0 : callback(null, e);
    }
}
function* resetPhoneNumberSagas() {
    yield takeLeading(actions.resetPhoneNumber, resetPhoneNumber);
    yield takeLeading(actions.verifyResetPhoneNumber, verifyResetPhoneNumber);
    yield takeLeading(actions.changePhoneNumber, changePhoneNumber);
}

function* loadCurrentUserSessions() {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    try {
        const sessions = yield call(api.auth.getCurrentUserSessions);
        yield put(actions.setSessionsState({ sessions, loading: false }));
    }
    catch (e) {
        yield put(actions.setSessionsState({ error: e, loading: false }));
    }
}
function* loadCurrentUserSession() {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    try {
        const session = yield call(api.auth.getCurrentUserSession);
        yield put(actions.setSessionsState({ currentSession: session, loading: false }));
    }
    catch (e) {
        yield put(actions.setSessionsState({ error: e, loading: false }));
    }
}
function* deleteUserSession({ payload: { id } }) {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    try {
        yield call(api.auth.deleteSessionForUser, id);
        yield put(actions.loadUserSessions());
    }
    catch (e) {
        yield put(actions.setSessionsState({ error: e, loading: false }));
    }
}
function* revokeUserSessions({ payload: { callback, userId } }) {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    try {
        yield call(api.auth.revokeSessionsForUser, userId);
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSessionsState({ error: e, loading: false }));
        callback === null || callback === void 0 ? void 0 : callback(false);
    }
}
function* deleteAllUserSessions() {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    try {
        yield call(api.auth.deleteAllSessionsForUser);
        yield put(actions.loadUserSessions());
    }
    catch (e) {
        yield put(actions.setSessionsState({ error: e, loading: false }));
    }
}
function* sessionsSaga() {
    yield takeLatest(actions.loadUserSessions, loadCurrentUserSessions);
    yield takeLatest(actions.deleteUserSession, deleteUserSession);
    yield takeLatest(actions.deleteAllUserSessions, deleteAllUserSessions);
    yield takeLatest(actions.loadCurrentUserSession, loadCurrentUserSession);
    yield takeEvery(actions.revokeUserSessions, revokeUserSessions);
}
/*********************************
 *  Preview Sagas
 *********************************/
function* loadCurrentUserSessionsMock() {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    yield put(actions.setSessionsState({ sessions: sessionsMock, loading: false }));
}
function* deleteUserSessionMock({ payload: { id } }) {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    const currentSessions = yield select((state) => { var _a; return (_a = state.auth.sessionsState.sessions) !== null && _a !== void 0 ? _a : []; });
    const newSessions = currentSessions.filter(s => s.id !== id);
    yield put(actions.setSessionsState({ sessions: newSessions, loading: false }));
}
function* deleteAllUserSessionsMock() {
    yield put(actions.setSessionsState({ loading: true, error: null }));
    const newSessions = sessionsMock.filter(s => s.current);
    yield put(actions.setSessionsState({ sessions: newSessions, loading: false }));
}
function* sessionsSagaMock() {
    yield takeLatest(actions.loadUserSessions, loadCurrentUserSessionsMock);
    yield takeLatest(actions.deleteUserSession, deleteUserSessionMock);
    yield takeLatest(actions.deleteAllUserSessions, deleteAllUserSessionsMock);
}

function* loadSessionPolicyState() {
    yield put(actions.setSessionsPolicyState({ loading: true, error: null }));
    try {
        const sessionsPolicy = yield call(api.auth.getSessionConfigurations);
        yield put(actions.setSessionsPolicyState({ configurations: sessionsPolicy, loading: false }));
    }
    catch (e) {
        yield put(actions.setSessionsState({ error: e, loading: false }));
    }
}
function* createOrUpdateSessionsPolicy({ payload }) {
    yield put(actions.setSessionsPolicyState({ loading: true, error: null, }));
    try {
        const { callback } = payload, rest = __rest(payload, ["callback"]);
        yield call(api.auth.createOrUpdateSessionConfigrations, rest);
        yield put(actions.loadSessionsPolicy());
        callback === null || callback === void 0 ? void 0 : callback(true);
    }
    catch (e) {
        yield put(actions.setSessionsPolicyState({ error: e, loading: false }));
    }
}
function* sessionsPolicySaga() {
    yield takeLeading(actions.loadSessionsPolicy, loadSessionPolicyState);
    yield takeLatest(actions.createOrUpdateSessionsPolicy, createOrUpdateSessionsPolicy);
}
function* loadSessionPolicyStateMock() {
    yield put(actions.setSessionsPolicyState({ loading: true, error: null }));
    yield put(actions.setSessionsPolicyState({ configurations: sessionsConfigDummies, loading: false }));
}
function* createOrUpdateSessionsPolicyMock({ payload }) {
    yield put(actions.setSessionsPolicyState({ loading: true, error: null, }));
    const { callback } = payload, rest = __rest(payload, ["callback"]);
    callback === null || callback === void 0 ? void 0 : callback(true);
    yield put(actions.setSessionsPolicyState({ configurations: rest, loading: false }));
}
function* sessionsPolicySagaMock() {
    yield takeLeading(actions.loadSessionsPolicy, loadSessionPolicyStateMock);
    yield takeLatest(actions.createOrUpdateSessionsPolicy, createOrUpdateSessionsPolicyMock);
}

function* sagas() {
    yield all([
        call(loginSagas),
        call(activateSagas),
        call(acceptInvitationSagas),
        call(forgotPasswordSagas),
        call(resetPhoneNumberSagas),
        call(ssoSagas$1),
        call(ssoSagas),
        call(profileSagas),
        call(mfaSagas),
        call(teamSagas),
        call(socialLoginsSaga),
        call(signUpSaga),
        call(apiTokensSaga),
        call(securityPolicySagas),
        call(accountSettingsSaga),
        call(tenantsSagas),
        call(rolesSagas),
        call(sessionsSaga),
        call(sessionsPolicySaga),
    ]);
}
function* mockSagas() {
    yield all([
        call(loginSagasMock),
        // call(activateSagas),
        // call(acceptInvitationSagas),
        // call(forgotPasswordSagas),
        // call(socialLoginsSaga),
        // call(signUpSaga),
        call(ssoSagasMock),
        call(profileSagasMock),
        call(mfaSagasMock),
        call(teamSagasMock),
        call(apiTokensSagaMock),
        call(securityPolicySagasMock),
        call(sessionsSagaMock),
        call(accountSettingsSagaMock),
        call(tenantsSagasMock),
        call(sessionsPolicySagaMock),
    ]);
}

// export store
var authStore = {
    sagas,
    mockSagas,
    storeName: authStoreName,
    initialState,
    reducer,
    actions,
};

export { AcceptInvitationStep, ActivateAccountStep, AdminPortalPages, AdminPortalPagesForEvents, ApiStateKeys, AuthenticationTypes, ForgotPasswordStep, LoginFlow, LoginStep, MFAStep, QuickLoginStrategy, ResetPhoneNumberStep, SSOStateKeys, SamlVendors, SignUpStage, TeamStateKeys, UserVeirifedOriginTypes, actions$g as acceptInvitationActions, reducers$f as acceptInvitationReducers, acceptInvitationState, actions$5 as accountSettingsActions, reducers$4 as accountSettingsReducers, accountSettingsState, actions$h as activateAccountActions, reducers$g as activateAccountReducers, activateState, actions$7 as apiTokensActions, reducers$6 as apiTokensReducers, apiTokensState, actions as authActions, initialState as authInitialState, mockSagas as authMockSagas, reducer as authReducers, sagas as authSagas, authStore as default, actions$f as forgotPasswordActions, reducers$e as forgotPasswordReducers, forgotPasswordState, actions$i as loginActions, reducers$h as loginReducers, loginState, actions$b as mfaActions, reducers$a as mfaReducers, mfaState, actions$c as profileActions, reducers$b as profileReducers, profileState, actions$e as resetPhoneNumberActions, reducers$d as resetPhoneNumberReducers, resetPhoneNumberState, actions$3 as rolesActions, reducers$2 as rolesReducers, rolesState, actions$6 as securityPolicyActions, reducers$5 as securityPolicyReducers, securityPolicyState, actions$2 as sessionsActions, actions$1 as sessionsPolicyActions, reducers as sessionsPolicyReducers, sessionsPolicyState, reducers$1 as sessionsReducers, sessionsState, actions$8 as signUpActions, reducers$7 as signUpReducers, signUpState, socialLoginState, actions$9 as socialLoginsActions, reducers$8 as socialLoginsReducer, actions$d as ssoActions, reducers$c as ssoReducers, ssoState, actions$a as teamActions, reducers$9 as teamReducers, teamState, actions$4 as tenantsActions, reducers$3 as tenantsReducers, tenantsState };
