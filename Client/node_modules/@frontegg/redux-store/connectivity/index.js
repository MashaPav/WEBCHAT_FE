import { c as connectivityStoreName } from '../constants-4d9682b2.js';
export { c as connectivityStoreName } from '../constants-4d9682b2.js';
import { createAction, createSlice } from '@reduxjs/toolkit';
import { __rest } from 'tslib';
import { takeEvery, takeLatest, put, all, call, select } from 'redux-saga/effects';
import { api } from '@frontegg/rest-api';

const initialState$1 = {
    isLoading: false,
    isSaving: false,
    list: [],
    processIds: [],
    slackChannels: {
        isLoading: false,
    },
};
const reducers = {
    initData: () => (Object.assign({}, initialState$1)),
    // Deprecated: use initData instead;
    // cleanData: () => ({ ...initialState }),
    setConnectivityState: (state, { payload }) => (Object.assign(Object.assign({}, state), payload)),
    cleanWebhookTestData: (state) => (Object.assign(Object.assign({}, state), { testResult: undefined })),
    cleanWebhookLogsData: (state) => (Object.assign(Object.assign({}, state), { webhookLogs: undefined })),
    cleanWebhookTestMessage: (state) => {
        var _a;
        return (Object.assign(Object.assign({}, state), { testResult: { status: (_a = state.testResult) === null || _a === void 0 ? void 0 : _a.status, message: undefined } }));
    },
    cleanError: (state) => (Object.assign(Object.assign({}, state), { error: undefined })),
    cleanSlackData: (state) => (Object.assign(Object.assign({}, state), { slackChannels: { isLoading: false } })),
    postWebhookRetryAction: {
        prepare: (logId) => ({ payload: logId }),
        reducer: (state, { payload }) => (Object.assign(Object.assign({}, state), { retryResult: Object.assign(Object.assign({}, state.retryResult), { [payload]: { isProcess: true, success: false } }) })),
    },
    postWebhookRetryResult: {
        prepare: (payload) => ({ payload }),
        reducer: (state, { payload }) => (Object.assign(Object.assign({}, state), { retryResult: Object.assign(Object.assign({}, state.retryResult), payload) })),
    },
};
const actions$1 = {
    loadSlackActions: createAction(`${connectivityStoreName}/loadSlackActions`),
    loadDataAction: createAction(`${connectivityStoreName}/loadDataAction`, (payload) => ({
        payload,
    })),
    postDataAction: createAction(`${connectivityStoreName}/postDataAction`, (payload) => ({
        payload,
    })),
    postCodeAction: createAction(`${connectivityStoreName}/postCodeAction`, (payload) => ({ payload })),
    loadScope: createAction(`${connectivityStoreName}/loadScope`),
    deleteWebhookConfigAction: createAction(`${connectivityStoreName}/deleteWebhookConfigAction`, (payload) => ({
        payload,
    })),
    postWebhookTestAction: createAction(`${connectivityStoreName}/postWebhookTestAction`, (payload) => ({
        payload,
    })),
    loadWebhookLogsAction: createAction(`${connectivityStoreName}/loadWebhookLogsAction`, (id, offset = 0, limit = 10) => ({ payload: { id, offset, limit } })),
};

const initialState = {
    isLoading: false,
    isSaving: false,
    list: [],
    processIds: [],
    slackChannels: {
        isLoading: false,
    },
};
const { reducer, actions: sliceActions } = createSlice({
    name: connectivityStoreName,
    initialState,
    reducers: Object.assign({}, reducers),
});
const actions = Object.assign(Object.assign({}, sliceActions), actions$1);

const type2ApiGet = {
    slack: api.connectivity.getSlackConfiguration,
    email: api.connectivity.getEmailConfiguration,
    sms: api.connectivity.getSMSConfiguration,
    webhook: api.connectivity.getWebhooksConfigurations,
    categories: api.connectivity.getCategories,
    channelMap: api.connectivity.getChannelMaps,
};
const type2ApiPost = {
    slack: api.connectivity.postSlackConfiguration,
    email: api.connectivity.postEmailConfiguration,
    sms: api.connectivity.postSMSConfiguration,
    webhook: api.connectivity.postWebhooksConfiguration,
};
const channels = ['email', 'slack', 'sms', 'webhook'];
const channels2Platform = {
    sms: {
        title: 'connectivity.sms',
        events: (data) => { var _a; return ((_a = data) === null || _a === void 0 ? void 0 : _a.length) || 0; },
        isActive: (data) => { var _a, _b; return (_b = (_a = data) === null || _a === void 0 ? void 0 : _a.some(({ enabled }) => enabled)) !== null && _b !== void 0 ? _b : false; },
        image: 'sms',
    },
    email: {
        title: 'common.email',
        events: (data) => { var _a; return ((_a = data) === null || _a === void 0 ? void 0 : _a.length) || 0; },
        isActive: (data) => { var _a, _b; return (_b = (_a = data) === null || _a === void 0 ? void 0 : _a.some(({ enabled }) => enabled)) !== null && _b !== void 0 ? _b : false; },
        image: 'email',
    },
    slack: {
        title: 'connectivity.slack',
        events: (data) => { var _a, _b; return ((_b = (_a = data) === null || _a === void 0 ? void 0 : _a.slackSubscriptions) === null || _b === void 0 ? void 0 : _b.length) || 0; },
        isActive: (data) => { var _a, _b; return (_b = !!((_a = data) === null || _a === void 0 ? void 0 : _a.slackSubscriptions.some(({ isActive }) => isActive))) !== null && _b !== void 0 ? _b : false; },
        image: 'slack',
    },
    webhook: {
        title: 'connectivity.webhook',
        events: (data) => { var _a; return ((_a = data) === null || _a === void 0 ? void 0 : _a.length) || 0; },
        isActive: (data) => { var _a, _b; return (_b = (_a = data) === null || _a === void 0 ? void 0 : _a.some(({ isActive }) => isActive)) !== null && _b !== void 0 ? _b : false; },
        image: 'webhook',
    },
};

const addApi = ['categories', 'channelMap'];
function* loadPlatromData(ch) {
    return yield loadFunction({ payload: { api: ch }, type: '' });
}
function* loadDataFunction({ payload = channels }) {
    yield put(actions.setConnectivityState({ isLoading: true }));
    try {
        const values = yield all([
            ...payload.map(loadPlatromData),
            yield loadFunction({ payload: { api: 'categories' }, type: '' }),
            yield (function* () {
                const res = yield all(payload.map(function* (ch) {
                    return yield loadFunction({ payload: { api: 'channelMap', params: ch }, type: '' });
                }));
                return res.reduce((acc, curr, idx) => (Object.assign(Object.assign({}, acc), { [`${payload[idx]}`]: curr })), {});
            })(),
        ]);
        const webhooks = yield loadFunction({ payload: { api: 'webhook' }, type: '' });
        const data = values.reduce((acc, curr, idx) => payload[idx]
            ? values[values.length - 1][payload[idx]].length
                ? Object.assign(Object.assign({}, acc), { [`${payload[idx]}`]: curr, list: [
                        ...acc.list,
                        {
                            id: idx,
                            key: payload[idx],
                            events: channels2Platform[payload[idx]].events(curr),
                            active: channels2Platform[payload[idx]].isActive(curr),
                            platform: channels2Platform[payload[idx]].title,
                            image: channels2Platform[payload[idx]].image,
                        },
                    ] }) : acc
            : Object.assign(Object.assign({}, acc), { [`${addApi[idx - payload.length]}`]: curr }), { list: [], webhook: webhooks });
        yield put(actions.setConnectivityState(Object.assign(Object.assign({}, data), { error: undefined, isSaving: false, isLoading: false })));
    }
    catch (e) {
        yield put(actions.setConnectivityState({ isLoading: false }));
    }
}
function* loadFunction({ payload: { api, params }, }) {
    try {
        return yield call(type2ApiGet[api], params);
    }
    catch (e) {
        return undefined;
    }
}
function* loadSlackFunction() {
    try {
        yield put(actions.setConnectivityState({ slackChannels: { isLoading: true } }));
        const data = yield call(api.connectivity.getSlackChannels);
        yield put(actions.setConnectivityState({ error: undefined, slackChannels: { isLoading: false, data } }));
    }
    catch (e) {
        yield put(actions.setConnectivityState({ error: undefined, slackChannels: { isLoading: false } }));
    }
}
function* checkNewStatus(platform, data) {
    const { connectivity: { list }, } = yield select();
    const currPlatform = list.find(({ key }) => key === platform);
    if (!currPlatform)
        return;
    const newActive = channels2Platform[platform].isActive(data);
    if (newActive === currPlatform.active)
        return;
    //TODO: double check
    yield put(actions.setConnectivityState({
        list: list.map((elm) => (elm.key === platform ? Object.assign(Object.assign({}, elm), { active: newActive }) : elm)),
    }));
}
function* postDataFunction({ payload: { platform, data, callback }, }) {
    var _a;
    const { processIds } = yield select((state) => state.connectivity);
    try {
        yield put(actions.setConnectivityState({
            isSaving: true,
            //@ts-ignore
            processIds: platform === 'webhook' ? [data._id, ...processIds] : processIds,
        }));
        if (platform === 'slack') {
            yield postSlackData({ payload: data, type: '' });
        }
        else if (['sms', 'email'].includes(platform)) {
            yield postEmailSMSData({ payload: data, type: platform });
        }
        else {
            yield call(type2ApiPost[platform], data);
        }
        if (!['sms', 'email'].includes(platform)) {
            const newData = yield loadFunction({ payload: { api: platform }, type: '' });
            if (platform === 'webhook') {
                newData.id = data._id;
            }
            yield put(actions.setConnectivityState({
                error: undefined,
                isSaving: false,
                [`${platform}`]: newData,
                processIds: newData.id ? processIds.filter((el) => el !== newData.id) : processIds,
            }));
            yield checkNewStatus(platform, newData);
            callback === null || callback === void 0 ? void 0 : callback(true);
        }
    }
    catch (e) {
        yield put(actions.setConnectivityState({ error: (_a = e.message) !== null && _a !== void 0 ? _a : e.toString(), isSaving: false, isLoading: false }));
    }
}
function* postSlackData({ payload }) {
    const { connectivity: { slack }, } = yield select();
    if (!slack) {
        return;
    }
    const { slackSubscriptions: stateSlackSubscriptions } = slack;
    const { slackSubscriptions } = payload;
    yield all([
        ...slackSubscriptions
            .reduce((acc, curr) => {
            var _a, _b;
            if (!curr.id && curr.slackEvents && ((_a = curr.slackEvents[0].channelIds) === null || _a === void 0 ? void 0 : _a.length)) {
                return [...acc, curr];
            }
            const el = stateSlackSubscriptions === null || stateSlackSubscriptions === void 0 ? void 0 : stateSlackSubscriptions.find((_a) => {
                var { id } = _a, props = __rest(_a, ["id"]);
                return id === curr.id && JSON.stringify(Object.assign({ id }, props)) !== JSON.stringify(curr);
            });
            if (el && curr.slackEvents && ((_b = curr.slackEvents[0].channelIds) === null || _b === void 0 ? void 0 : _b.length)) {
                return [...acc, curr];
            }
            return acc;
        }, [])
            .map(function* (el) {
            return yield call(type2ApiPost.slack, el);
        }),
        ...slackSubscriptions
            .reduce((acc, curr) => {
            if (curr.id && !curr.slackEvents[0].channelIds.length) {
                return [...acc, curr];
            }
            return acc;
        }, [])
            .map(function* (el) {
            return yield call(api.connectivity.deleteSlackConfiguration, el);
        }),
    ]);
}
function* postEmailSMSData({ payload, type }) {
    const { connectivity } = yield select();
    const { processIds } = yield select((state) => state.connectivity);
    const stateData = connectivity[type];
    if (!stateData)
        return;
    let actionsResult = [];
    try {
        actionsResult = yield all([
            // create new
            ...payload
                .reduce((acc, curr) => {
                const state = stateData.find(({ eventKey }) => eventKey === curr.eventKey);
                if (!state && curr.subscriptions[0].recipients.filter((el) => el).length) {
                    return [...acc, curr];
                }
                return acc;
            }, [])
                .map(function* (data) {
                return yield call(type === 'email' ? api.connectivity.postEmailConfiguration : api.connectivity.postSMSConfiguration, data);
            }),
            // update exists
            ...payload
                .reduce((acc, curr) => {
                const state = stateData.find(({ eventKey }) => eventKey === curr.eventKey);
                if (state && JSON.stringify(state) !== JSON.stringify(curr)) {
                    return [...acc, curr];
                }
                return acc;
            }, [])
                .map(function* (data) {
                const { subscriptions, eventKey } = data;
                const _a = subscriptions[0], { id = '', enabled } = _a, body = __rest(_a, ["id", "enabled"]);
                return yield all([
                    yield call(type === 'email' ? api.connectivity.patchEmailConfiguration : api.connectivity.patchSMSConfiguration, { eventKey, enabled }),
                    yield call(type === 'email' ? api.connectivity.putEmailSubscriptions : api.connectivity.putSMSSubscriptions, id, eventKey, Object.assign(Object.assign({}, body), { enabled })),
                ]);
            }),
            // delete record with empty recipients
            ...payload
                .reduce((acc, curr) => {
                const state = stateData.find(({ eventKey }) => eventKey === curr.eventKey);
                if (state &&
                    state.subscriptions[0].recipients.length &&
                    !curr.subscriptions[0].recipients.filter((el) => !!el).length) {
                    return [...acc, curr];
                }
                return acc;
            }, [])
                .map(function* ({ eventKey, subscriptions }) {
                return call(type === 'email' ? api.connectivity.deleteEmailSubscriptions : api.connectivity.deleteSMSSubscriptions, eventKey, subscriptions[0].id || '');
            }),
        ]);
    }
    catch (_a) {
    }
    if (actionsResult.length) {
        const newData = yield loadFunction({ payload: { api: type }, type: '' });
        // yield put(connectivityActions.postDataSuccess({ platform: type, data: newData }));
        yield put(actions.setConnectivityState({
            error: undefined,
            isSaving: false,
            [`${type}`]: newData,
            processIds: newData.id ? processIds.filter((el) => el !== newData.id) : processIds,
        }));
        yield checkNewStatus(type, newData);
    }
    else {
        // yield put(connectivityActions.postDataSuccess({ platform: type, data: stateData }));
        yield put(actions.setConnectivityState({
            error: undefined,
            isSaving: false,
            [`${type}`]: stateData,
            processIds: processIds,
        }));
    }
}
function* postCodeFunction({ payload }) {
    try {
        yield api.connectivity.postSlackCode(payload);
    }
    catch (_a) {
    }
    // yield put(connectivityActions.postCodeSuccess());
    yield put(actions.setConnectivityState({ error: undefined, isSaving: false }));
}
function* loadSlackPermissions() {
    const { slackChannels } = yield select((state) => state.connectivity);
    try {
        yield put(actions.setConnectivityState({ slackChannels: Object.assign(Object.assign({}, slackChannels), { isLoadingScope: true }) }));
        const { clientId } = yield call(api.connectivity.getSlackScope);
        // yield put(connectivityActions.loadScopeSuccess(clientId));
        yield put(actions.setConnectivityState({
            slackChannels: { error: undefined, clientId, isLoadingScope: false, isLoading: false },
        }));
    }
    catch (_a) {
        // yield put(connectivityActions.loadScopeSuccess(null));
        yield put(actions.setConnectivityState({
            slackChannels: { error: undefined, isLoadingScope: false, isLoading: false },
        }));
    }
}
function* deleteWebhookConfigFunction({ payload }) {
    const { callback, webhookId } = payload;
    const { processIds } = yield select((state) => state.connectivity);
    try {
        yield put(actions.setConnectivityState({ isSaving: true }));
        yield call(api.connectivity.deleteWebhooksConfiguration, webhookId);
    }
    catch (e) {
        callback === null || callback === void 0 ? void 0 : callback(null, e.message);
    }
    const newData = yield loadFunction({ payload: { api: 'webhook' }, type: '' });
    if (newData) {
        yield put(actions.setConnectivityState({
            error: undefined,
            isSaving: false,
            webhook: newData,
            processIds: newData.id ? processIds.filter((el) => el !== newData.id) : processIds,
        }));
    }
    callback === null || callback === void 0 ? void 0 : callback(true);
}
function* postWebhookTestFunction({ payload }) {
    try {
        yield put(actions.setConnectivityState({ isTesting: true }));
        const { statusCode, body } = yield call(api.connectivity.postWebhookTest, payload);
        if ([201, 200].includes(statusCode)) {
            // yield put(connectivityActions.postWebhookTestSuccess('success', JSON.stringify(body, null, 2)));
            const message = JSON.stringify(body, null, 2);
            yield put(actions.setConnectivityState({ isTesting: false, testResult: { status: 'success', message } }));
        }
        else {
            // yield put(connectivityActions.postWebhookTestSuccess('failed', body.toString()));
            yield put(actions.setConnectivityState({ isTesting: false, testResult: { status: 'failed' } }));
        }
    }
    catch (e) {
        // yield put(connectivityActions.postWebhookTestSuccess('failed', e.toString()));
        yield put(actions.setConnectivityState({
            isTesting: false,
            testResult: { status: 'failed', message: e.toString() },
        }));
    }
}
function* postWebhookRetryFunction({ payload }) {
    try {
        const { statusCode } = yield call(api.connectivity.postWebhookRetry, payload);
        yield put(actions.postWebhookRetryResult({
            [payload]: { isProcess: false, success: statusCode === 202 },
        }));
    }
    catch (e) {
        yield put(actions.postWebhookRetryResult({
            [payload]: { isProcess: false, success: false },
        }));
    }
}
function* loadWebhookLogsFunction({ payload: { id, limit, offset }, }) {
    const { webhookLogs } = yield select((state) => state.connectivity);
    try {
        yield put(actions.setConnectivityState({ webhookLogs: Object.assign(Object.assign({}, webhookLogs), { isLoading: true }) }));
        //TODO: Fix types
        //@ts-ignore
        const data = yield call(api.connectivity.getWebhookLog, id, offset, limit);
        // yield put(connectivityActions.loadWebhookLogsSuccess(data));
        yield put(actions.setConnectivityState({ error: undefined, webhookLogs: Object.assign({ isLoading: false }, data) }));
    }
    catch (e) {
        yield put(actions.setConnectivityState({ error: undefined, webhookLogs: { isLoading: false } }));
    }
}
function* sagas() {
    yield takeEvery(actions.loadDataAction, loadDataFunction);
    yield takeLatest(actions.loadSlackActions, loadSlackFunction);
    yield takeEvery(actions.postDataAction, postDataFunction);
    yield takeEvery(actions.postCodeAction, postCodeFunction);
    yield takeEvery(actions.loadScope, loadSlackPermissions);
    yield takeEvery(actions.deleteWebhookConfigAction, deleteWebhookConfigFunction);
    yield takeEvery(actions.postWebhookTestAction, postWebhookTestFunction);
    yield takeEvery(actions.postWebhookRetryAction, postWebhookRetryFunction);
    yield takeLatest(actions.loadWebhookLogsAction, loadWebhookLogsFunction);
}

// export store
var connectivityStore = {
    sagas,
    storeName: connectivityStoreName,
    initialState,
    reducer,
    actions,
};

export { actions as connectivityActions, initialState as connectivityInitialState, reducer as connectivityReducers, sagas as connectivitySagas, connectivityStore as default };
