import { api } from '@frontegg/rest-api';
import { createSlice, createAction } from '@reduxjs/toolkit';
import { takeLatest, select as select$1, call, put, all } from 'redux-saga/effects';

const initialState = {
    total: 0,
    offset: 0,
    filter: '',
    sortBy: 'createdAt',
    context: null,
    filters: [],
    rowsData: [],
    lastUpdated: new Date(),
    isLoading: true,
    isFetchMore: false,
    totalToday: 0,
    currentPage: 0,
    headerProps: [],
    sortDirection: 'desc',
    severeThisWeek: 0,
    predefinedFilters: [],
    isDownloadingCsv: false,
    virtualScroll: false,
};

const defaultItemsPerPage = 20;
const { name: storeName, actions: lifeCycleActions, reducer } = createSlice({
    name: 'audits',
    initialState,
    reducers: {
        setContext: (state, { payload }) => {
            state.context = payload;
        },
        startLoading: (state) => {
            state.isLoading = true;
        },
        setVirtualScroll: (state, { payload }) => {
            state.virtualScroll = payload;
        },
        startRefresh: (state) => {
            state.isLoading = true;
        },
        startFetching: (state) => {
            state.isFetchMore = true;
        },
        finishLoading: (state) => {
            state.isLoading = false;
        },
        startDownloadingCsv: (state) => {
            state.isDownloadingCsv = true;
        },
        stopDownloadingCsv: (state) => {
            state.isDownloadingCsv = false;
        },
        loadStatsSuccess: (state, { payload }) => {
            state.error = undefined;
            state.totalToday = payload.totalToday;
            state.severeThisWeek = payload.severeThisWeek;
        },
        loadItemFailedAction: (state, { payload }) => {
            state.error = Object.assign(Object.assign({}, state.error), { [payload.name]: payload.error });
        },
        loadMetadataSuccess: (state, { payload }) => {
            state.error = {};
            state.headerProps = payload.properties;
            state.themeAudits = payload.theme ? payload.theme.styles : {};
        },
        loadAuditsSuccess: (state, { payload }) => {
            state.error = {};
            state.rowsData = payload.rowsData;
            state.lastUpdated = new Date();
            state.total = payload.total;
        },
        fetchMoreSuccess: (state, { payload }) => {
            state.error = {};
            state.offset = payload.offset;
            state.currentPage = payload.currentPage;
            state.isFetchMore = false;
        },
        setFilterData: (state, { payload }) => {
            state.filters = payload;
            state.currentPage = 0;
            state.offset = 0;
            state.isLoading = true;
        },
        textSearch: (state, { payload }) => {
            state.filter = payload;
            state.currentPage = 0;
            state.offset = 0;
            state.isLoading = true;
        },
        onPageChange: (state, { payload }) => {
            state.currentPage = payload - 1;
            state.offset = state.currentPage * defaultItemsPerPage;
            state.isLoading = true;
        },
        setDataSorting: (state, { payload }) => {
            state.sortBy = payload.sortBy;
            state.currentPage = 0;
            state.sortDirection = payload.sortDirection === 'asc' ? 'desc' : 'asc';
            state.offset = 0;
            state.isLoading = true;
        },
        setPredefinedFilters: (state, { payload }) => {
            state.predefinedFilters = payload;
            state.filters = Object.keys(payload).map((key) => ({ key, value: payload[key] }));
        },
    },
});
const actions = Object.assign(Object.assign({}, lifeCycleActions), { initData: createAction(`${storeName}/initData`), loadAudits: createAction(`${storeName}/loadAudits`), removeFilter: createAction(`${storeName}/removeFilter`), filterData: createAction(`${storeName}/filterData`), exportCSV: createAction(`${storeName}/exportCSV`), deleteAudits: createAction(`${storeName}/deleteAudits`) });

const select = () => select$1((_) => _[storeName]);
function* loadStats() {
    const { sortBy, sortDirection } = yield select();
    try {
        const stats = yield call(api.audits.getAuditsStats, {
            sortBy,
            sortDirection,
            count: defaultItemsPerPage,
        });
        yield put(actions.loadStatsSuccess(stats));
    }
    catch (e) {
        const errorMessage = {
            name: 'stats',
            error: e,
        };
        console.error('failed to load stats - ', e);
        yield put(actions.loadItemFailedAction(errorMessage));
    }
}
function* loadMetadata() {
    try {
        const result = yield call(api.metadata.getAuditsMetadata);
        yield put(actions.loadMetadataSuccess(result));
    }
    catch (e) {
        const errorMessage = {
            name: 'metadata',
            error: e,
        };
        console.error('failed to load metadata - ', e);
        yield put(actions.loadItemFailedAction(errorMessage));
    }
}
const filterToObject = (arr) => arr.reduce((res, curr) => {
    res[curr.key] = curr.value;
    return res;
}, {});
function* loadAuditsFunction({ payload }) {
    const { filters, sortBy, sortDirection, filter, offset, virtualScroll } = yield select();
    const { appendMode = virtualScroll, onlyOneLoad = true, offset: incomeOffset } = payload || {};
    const { rowsData } = appendMode ? yield select() : { rowsData: [] };
    try {
        const f2o = filterToObject(filters);
        const { data, total } = yield call(api.audits.getAudits, Object.assign(Object.assign(Object.assign(Object.assign({}, (virtualScroll && { paginationMode: 'virtual' })), { sortDirection,
            sortBy,
            filter }), f2o), { 
            // TODO: refactor once api become V2 with query field for virtual scroll
            offset: virtualScroll ? rowsData.length + incomeOffset || rowsData.length + offset : incomeOffset || offset, count: defaultItemsPerPage }));
        yield put(actions.loadAuditsSuccess({ rowsData: [...rowsData, ...data], total }));
        onlyOneLoad && (yield put(actions.finishLoading()));
    }
    catch (e) {
        const errorMessage = {
            name: 'audits',
            error: e,
        };
        console.error('failed to load audits - ', e);
        yield put(actions.loadItemFailedAction(errorMessage));
    }
}
function* initDataFunction() {
    yield put(actions.startLoading());
    yield all([loadStats(), loadMetadata(), loadAuditsFunction({ payload: { onlyOneLoad: false }, type: '' })]);
    yield put(actions.finishLoading());
}
function* removeFilterFunction({ payload }) {
    const { filters: allFilters } = yield select();
    const removedFilterIndex = allFilters.findIndex((item) => item.key === payload.key);
    if (removedFilterIndex < 0) {
        return;
    }
    const newFilters = [...allFilters.slice(0, removedFilterIndex), ...allFilters.slice(removedFilterIndex + 1)];
    yield put(actions.setFilterData(newFilters));
}
function* filterDataFunction({ payload }) {
    const { filters: allFilters } = yield select();
    let filterIndex = allFilters.findIndex((item) => item.key === payload.key);
    if (filterIndex < 0) {
        filterIndex = allFilters.length;
    }
    const newFilters = [...allFilters.slice(0, filterIndex), payload, ...allFilters.slice(filterIndex + 1)];
    yield put(actions.setFilterData(newFilters));
}
function* exportCsvFunction() {
    const { filters, sortBy, sortDirection, filter, headerProps } = yield select();
    const f2o = filterToObject(filters);
    yield put(actions.startDownloadingCsv());
    const outputFileName = `audits.csv`;
    try {
        yield api.audits.exportAudits(Object.assign(Object.assign({ endpoint: 'csv/v2', headerProps,
            sortDirection,
            sortBy,
            filter }, f2o), { offset: 0, outputFileName }));
    }
    catch (e) {
        console.error('failed to export audits - ', e);
    }
    finally {
        yield put(actions.stopDownloadingCsv());
    }
}
function* sagas() {
    yield takeLatest(actions.initData, initDataFunction);
    yield takeLatest(actions.removeFilter, removeFilterFunction);
    yield takeLatest(actions.filterData, filterDataFunction);
    yield takeLatest([actions.loadAudits, actions.textSearch, actions.onPageChange], loadAuditsFunction);
    yield takeLatest([actions.setFilterData, actions.setDataSorting, actions.startRefresh], () => loadAuditsFunction({ payload: { appendMode: false }, type: '' }));
    yield takeLatest(actions.exportCSV, exportCsvFunction);
}

export { actions as a, sagas as b, defaultItemsPerPage as d, initialState as i, reducer as r, storeName as s };
