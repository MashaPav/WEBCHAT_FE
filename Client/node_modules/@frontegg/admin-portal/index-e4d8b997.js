import { r as react, R as React, f as __rest, g as __awaiter } from './FronteggApp-3b25e3fb.js';
import { aV as useSelector, aW as shallowEqual, aX as useDispatch, a as createSvgIcon, j as jsxRuntime, aY as easing, aZ as duration, a_ as _objectWithoutPropertiesLoose$3, K as useTheme, a$ as useForkRef, b0 as debounce, b1 as ownerWindow, b2 as _extends$4, b3 as Transition, b4 as getTransitionProps, b5 as reflow, b6 as generateUtilityClass, b7 as generateUtilityClasses, k as styled, b8 as Modal, b9 as rootShouldForwardProp, ba as Paper, bb as capitalize$1, bc as useThemeProps, bd as composeClasses, be as clsx, bf as InputBaseRoot, bg as rootOverridesResolver, bh as InputBaseComponent, bi as inputOverridesResolver, bj as deepmerge, bk as InputBase, bl as isMuiElement, bm as isAdornedStart, bn as isFilled, bo as FormControlContext, bp as useFormControl, bq as formControlState, br as slotShouldForwardProp, bs as useControlled, bt as ownerDocument, bu as formatMuiErrorMessage, bv as MuiMenu, bw as MuiOutlinedInput, aq as SvgIcon, aR as FormHelperText, bx as BaseSchema, by as ValidationError, bz as runTests, bA as isSchema, bB as printValue, bC as array, bD as isAbsent, bE as PropTypes, B as Box, bF as UI, bG as VisaCardIcon, bH as AmericanExpressIcon, bI as MasterCardIcon, bJ as DinersCardIcon, bK as GenericCardIcon, G as Grid, S as ShadowDomContext, bL as enhanceAdminBoxTheme, bM as useMediaQuery, P as useTranslation, x as useShadowDom, bN as Dialog$1, y as initGlobalTheme, z as I18nProvider$1, E as GlobalThemeProvider, H as ThemeContext, J as InnerThemeProvider, U as Provider, V as FronteggStoreContext, N as useAuth, bO as usePublicPolicySettings$1, O as useAuthRoutes, A as Alert$1, W as Loader$1, o as Button$1, D as Divider, T as Typography$1, bP as EditIcon, R as RenderAsSlot, bQ as _inheritsLoose$2, i as isobject, bR as createSvgIcon$1, bS as interopRequireDefault, bT as MuiDialog, bU as Skeleton, bV as shallowEqual$1, C as Card, bW as Avatar$1, aN as IconButton, aU as InputCopy$1, $ as useAuthUserOrNull, bX as useAuthTeamState, az as useField, bY as Select$1$1, aA as InputPassword$1, L as Link$1, u as useFormikContext, I as Input$1$1, ax as useMfaActions, ah as validateSchema, aD as validateMinLength, aw as useMfaState, bZ as CheckIcon$1, b_ as LinkIcon, b$ as useRolesState, c0 as useRolesActions, c1 as validateNotEmpty, c2 as RadioList, c3 as DeleteIcon, c4 as DoubleArrowRightIcon, c5 as useAuthUser, c6 as AddIcon, c7 as InfoIcon, c8 as TableUserAvatarCell, c9 as useApiTokensState, ca as useApiTokensActions, cb as Chip, cc as CheckedIcon, cd as Table, ce as TableDateCell, a2 as useSecurityPolicyState, aa as useSecurityPolicyActions, ar as Formik, as as Form, cf as Fade, n as CheckCircleFilledIcon, cg as WarningIcon, a5 as useSSOState, ch as StatusChip, ci as validateWellKnown, F as FronteggModules, ap as useVendorState, cj as useTenantsState, ck as ProfileIcon, cl as PrivacyIcon, cm as PersonalTokensIcon, cn as UsageIcon, co as AccountDetailsIcon, cp as UsersIcon, cq as RolesIcon, cr as SecurityIcon, cs as SSOIcon, ct as AuditLogsIcon, cu as WebhooksIcon, cv as APITokenIcon, cw as SubscriptionIcon, cx as Navigation, cy as PageHeaderProvider, cz as PageHeader, cA as Avatar$1$1, cB as PageHeaderUpdater, X as useOnRedirectTo, Z as useAuthActions, _ as useIsAuthenticated, cC as HelpMessage, cD as Switch$1, cE as SettingsList, cF as getOptions, cG as useAuthTeamActions, cH as useTenantsActions, aJ as Collapse$1, cI as Alert$1$1, cJ as useProfileState, a4 as useForgotPasswordActions, a3 as useForgotPasswordState, cK as reloadProfileIfNeeded, cL as useSessionsActions, cM as useSessionsState, cN as TableUserAgentCell, cO as TableLocationCell, cP as TableTextCell, cQ as TableLogoutCell, cR as SearchIcon, cS as TableAvatarCell, cT as TableChipsCell, cU as ResendIcon, cV as CloseIcon, cW as GroupUsersIcon, cX as SearchBigIcon, cY as TablePlaceholder, cZ as TableSwitchCell, a6 as useSSOActions, c_ as TableSwitchCellLeft, c$ as TableCopyCell, d0 as TableSeverityCell, d1 as TableJsonCell, d2 as TableIpCell, d3 as isValid$2, d4 as format$1, d5 as TableExpandableRow, d6 as CrossBtnIcon, d7 as useProfileActions, d8 as UploadIcon, d9 as PencilIcon, da as Menu$1, db as UploadPhoto, dc as validationPhoneOptional, ai as validatePasswordUsingOWASP, aj as validateConfirmPassword, dd as validationPostCodeOptional, ak as validateEmail, ao as validationPhone, Y as useLoginActions, de as create$1, df as create$2, dg as validateNumber, dh as create$3, di as validateFile, dj as validateUrl, dk as validateDomain, dl as create$4, dm as Popup$1, dn as validateMinLengthOptional, dp as Chip$1, v as Checkbox$1, dq as Tree, ac as useSessionsPolicyState, ab as useSessionsPolicyActions, aQ as callbackToPromise$1, aB as PasswordStrengthChecker, dr as copy, ds as Switch$1$1, dt as Button$1$1, du as RadioGroup, aP as FormControlLabel, dv as Radio, dw as DropZoneElement, dx as SelectTree$1, dy as validatePositiveNumber, dz as validateHistorySize, dA as PdfIcon } from './formik.esm-3ec4824f.js';
import { auditsStoreName, bindActionCreators, auditsActions, auditLogsActions, auditLogsReducers, connectivityActions, connectivityStoreName, subscriptionsStoreName, subscriptionActions, PaymentProvider, createSelector, AdminPortalPages, MFAStep, ApiStateKeys } from '@frontegg/redux-store';
import { ISubscriptionStatus, api, ContextHolder, fetch, ISubscriptionCancellationPolicy } from '@frontegg/rest-api';
import { Metadata } from '@frontegg/types';
import './utils.js';
import './AppHolder.js';

const useAuditsActions = () => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(auditsActions, dispatch), [auditsActions]);
};
/**
 * hooks helpers
 */
const sliceReducerActionsBy = (reducer) => {
    const reducerKeys = Object.keys(reducer);
    const reducerActions = reducerKeys.map((key) => ({ [key]: auditsActions[key] }));
    return reducerActions.reduce((p, n) => (Object.assign(Object.assign({}, p), n)), {});
};
const stateHookGenerator = (stateMapper, subState) => {
    return useSelector((state) => { var _a; return (_a = stateMapper === null || stateMapper === void 0 ? void 0 : stateMapper(state[auditsStoreName][subState])) !== null && _a !== void 0 ? _a : state[auditsStoreName][subState]; }, shallowEqual);
};
const reducerActionsGenerator = (actions, reducers) => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(Object.assign(Object.assign({}, actions), sliceReducerActionsBy(reducers)), dispatch), [dispatch]);
};

const useAuditLogsState = (stateMapper) => stateHookGenerator(stateMapper, 'auditLogsState');
const useAuditLogsActions = () => reducerActionsGenerator(auditLogsActions, auditLogsReducers);

const useAuditsMetadataState = (stateMapper) => stateHookGenerator(stateMapper, 'auditsMetadataState');

const useConnectivityState = (stateMapper) => {
    return useSelector((state) => { var _a; return (_a = stateMapper === null || stateMapper === void 0 ? void 0 : stateMapper(state[connectivityStoreName])) !== null && _a !== void 0 ? _a : state[connectivityStoreName]; }, shallowEqual);
};
const useConnectivityActions = () => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(connectivityActions, dispatch), [connectivityActions]);
};

function getSubscriptionState(state) {
    return state[subscriptionsStoreName];
}
const usePaymentProvider = () => {
    return useSelector((state) => getSubscriptionState(state).config, shallowEqual);
};
const usePaymentProviderActions = () => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(subscriptionActions.config, dispatch), [dispatch]);
};
const usePlans = () => {
    return useSelector((state) => getSubscriptionState(state).plans, shallowEqual);
};
const usePlansActions = () => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(subscriptionActions.plans, dispatch), [dispatch]);
};
const useCheckout = () => {
    return useSelector((state) => getSubscriptionState(state).checkout, shallowEqual);
};
const useCheckoutActions = () => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(subscriptionActions.checkout, dispatch), [dispatch]);
};
const useBillingActions = (billingKey) => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(subscriptionActions.billing[billingKey], dispatch), [billingKey, dispatch]);
};
const useBillingInformation = () => useSelector((state) => getSubscriptionState(state).billing.information, shallowEqual);
const useBillingInformationActions = () => useBillingActions('information');
const usePaymentMethod = () => useSelector((state) => getSubscriptionState(state).billing.paymentMethod, shallowEqual);
const usePaymentMethodActions = () => useBillingActions('paymentMethod');
const useInvoices = () => useSelector((state) => getSubscriptionState(state).billing.invoices, shallowEqual);
const useInvoicesActions = () => useBillingActions('invoices');
const useStripeState = () => {
    return useSelector((state) => getSubscriptionState(state).stripe, shallowEqual);
};
const useStripeActions = () => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(subscriptionActions.stripe, dispatch), [dispatch]);
};
const useSubscriptionCancellation = () => {
    return useSelector((state) => getSubscriptionState(state).billing.subscription.cancellation, shallowEqual);
};
const useSubscriptionRenewal = () => {
    return useSelector((state) => getSubscriptionState(state).billing.subscription.renewal, shallowEqual);
};
const useSubscription = () => {
    return useSelector((state) => {
        const { billing: { subscription }, } = getSubscriptionState(state);
        return subscription;
    }, shallowEqual);
};
const useVendorPublicConfig = () => {
    return useSelector((state) => {
        const { vendorPublicConfig } = getSubscriptionState(state);
        return vendorPublicConfig;
    }, shallowEqual);
};
const useVendorPublicConfigActions = () => {
    const dispatch = useDispatch();
    return react.exports.useMemo(() => bindActionCreators(subscriptionActions.vendorPublicConfig, dispatch), [dispatch]);
};

var ArrowDropDownIcon = createSvgIcon( /*#__PURE__*/jsxRuntime.exports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), 'ArrowDropDown');

const _excluded$f = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function getTranslateValue(direction, node, resolvedContainer) {
  const rect = node.getBoundingClientRect();
  const containerRect = resolvedContainer && resolvedContainer.getBoundingClientRect();
  const containerWindow = ownerWindow(node);
  let transform;

  if (node.fakeTransform) {
    transform = node.fakeTransform;
  } else {
    const computedStyle = containerWindow.getComputedStyle(node);
    transform = computedStyle.getPropertyValue('-webkit-transform') || computedStyle.getPropertyValue('transform');
  }

  let offsetX = 0;
  let offsetY = 0;

  if (transform && transform !== 'none' && typeof transform === 'string') {
    const transformValues = transform.split('(')[1].split(')')[0].split(',');
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }

  if (direction === 'left') {
    if (containerRect) {
      return `translateX(${containerRect.right + offsetX - rect.left}px)`;
    }

    return `translateX(${containerWindow.innerWidth + offsetX - rect.left}px)`;
  }

  if (direction === 'right') {
    if (containerRect) {
      return `translateX(-${rect.right - containerRect.left - offsetX}px)`;
    }

    return `translateX(-${rect.left + rect.width - offsetX}px)`;
  }

  if (direction === 'up') {
    if (containerRect) {
      return `translateY(${containerRect.bottom + offsetY - rect.top}px)`;
    }

    return `translateY(${containerWindow.innerHeight + offsetY - rect.top}px)`;
  } // direction === 'down'


  if (containerRect) {
    return `translateY(-${rect.top - containerRect.top + rect.height - offsetY}px)`;
  }

  return `translateY(-${rect.top + rect.height - offsetY}px)`;
}

function resolveContainer(containerPropProp) {
  return typeof containerPropProp === 'function' ? containerPropProp() : containerPropProp;
}

function setTranslateValue(direction, node, containerProp) {
  const resolvedContainer = resolveContainer(containerProp);
  const transform = getTranslateValue(direction, node, resolvedContainer);

  if (transform) {
    node.style.webkitTransform = transform;
    node.style.transform = transform;
  }
}
const defaultEasing = {
  enter: easing.easeOut,
  exit: easing.sharp
};
const defaultTimeout = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
/**
 * The Slide transition is used by the [Drawer](/components/drawers/) component.
 * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
 */

const Slide = /*#__PURE__*/react.exports.forwardRef(function Slide(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    container: containerProp,
    direction = 'down',
    easing: easingProp = defaultEasing,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$f);

  const theme = useTheme();
  const childrenRef = react.exports.useRef(null);
  const handleRefIntermediary = useForkRef(children.ref, childrenRef);
  const handleRef = useForkRef(handleRefIntermediary, ref);

  const normalizedTransitionCallback = callback => isAppearing => {
    if (callback) {
      // onEnterXxx and onExitXxx callbacks have a different arguments.length value.
      if (isAppearing === undefined) {
        callback(childrenRef.current);
      } else {
        callback(childrenRef.current, isAppearing);
      }
    }
  };

  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    setTranslateValue(direction, node, containerProp);
    reflow(node);

    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node, isAppearing) => {
    const transitionProps = getTransitionProps({
      timeout,
      style,
      easing: easingProp
    }, {
      mode: 'enter'
    });
    node.style.webkitTransition = theme.transitions.create('-webkit-transform', _extends$4({}, transitionProps));
    node.style.transition = theme.transitions.create('transform', _extends$4({}, transitionProps));
    node.style.webkitTransform = 'none';
    node.style.transform = 'none';

    if (onEntering) {
      onEntering(node, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback(node => {
    const transitionProps = getTransitionProps({
      timeout,
      style,
      easing: easingProp
    }, {
      mode: 'exit'
    });
    node.style.webkitTransition = theme.transitions.create('-webkit-transform', transitionProps);
    node.style.transition = theme.transitions.create('transform', transitionProps);
    setTranslateValue(direction, node, containerProp);

    if (onExit) {
      onExit(node);
    }
  });
  const handleExited = normalizedTransitionCallback(node => {
    // No need for transitions when the component is hidden
    node.style.webkitTransition = '';
    node.style.transition = '';

    if (onExited) {
      onExited(node);
    }
  });

  const handleAddEndListener = next => {
    if (addEndListener) {
      // Old call signature before `react-transition-group` implemented `nodeRef`
      addEndListener(childrenRef.current, next);
    }
  };

  const updatePosition = react.exports.useCallback(() => {
    if (childrenRef.current) {
      setTranslateValue(direction, childrenRef.current, containerProp);
    }
  }, [direction, containerProp]);
  react.exports.useEffect(() => {
    // Skip configuration where the position is screen size invariant.
    if (inProp || direction === 'down' || direction === 'right') {
      return undefined;
    }

    const handleResize = debounce(() => {
      if (childrenRef.current) {
        setTranslateValue(direction, childrenRef.current, containerProp);
      }
    });
    const containerWindow = ownerWindow(childrenRef.current);
    containerWindow.addEventListener('resize', handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener('resize', handleResize);
    };
  }, [direction, inProp, containerProp]);
  react.exports.useEffect(() => {
    if (!inProp) {
      // We need to update the position of the drawer when the direction change and
      // when it's hidden.
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends$4({
    nodeRef: childrenRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    appear: appear,
    in: inProp,
    timeout: timeout
  }, other, {
    children: (state, childProps) => {
      return /*#__PURE__*/react.exports.cloneElement(children, _extends$4({
        ref: handleRef,
        style: _extends$4({
          visibility: state === 'exited' && !inProp ? 'hidden' : undefined
        }, style, children.props.style)
      }, childProps));
    }
  }));
});
var Slide$1 = Slide;

function getDrawerUtilityClass(slot) {
  return generateUtilityClass('MuiDrawer', slot);
}
generateUtilityClasses('MuiDrawer', ['root', 'docked', 'paper', 'paperAnchorLeft', 'paperAnchorRight', 'paperAnchorTop', 'paperAnchorBottom', 'paperAnchorDockedLeft', 'paperAnchorDockedRight', 'paperAnchorDockedTop', 'paperAnchorDockedBottom', 'modal']);

const _excluded$e = ["BackdropProps"],
      _excluded2$1 = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"];

const overridesResolver = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.root, (ownerState.variant === 'permanent' || ownerState.variant === 'persistent') && styles.docked, styles.modal];
};

const useUtilityClasses$e = ownerState => {
  const {
    classes,
    anchor,
    variant
  } = ownerState;
  const slots = {
    root: ['root'],
    docked: [(variant === 'permanent' || variant === 'persistent') && 'docked'],
    modal: ['modal'],
    paper: ['paper', `paperAnchor${capitalize$1(anchor)}`, variant !== 'temporary' && `paperAnchorDocked${capitalize$1(anchor)}`]
  };
  return composeClasses(slots, getDrawerUtilityClass, classes);
};

const DrawerRoot = styled(Modal, {
  name: 'MuiDrawer',
  slot: 'Root',
  overridesResolver
})(({
  theme
}) => ({
  zIndex: theme.zIndex.drawer
}));
const DrawerDockedRoot = styled('div', {
  shouldForwardProp: rootShouldForwardProp,
  name: 'MuiDrawer',
  slot: 'Docked',
  skipVariantsResolver: false,
  overridesResolver
})({
  flex: '0 0 auto'
});
const DrawerPaper = styled(Paper, {
  name: 'MuiDrawer',
  slot: 'Paper',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.paper, styles[`paperAnchor${capitalize$1(ownerState.anchor)}`], ownerState.variant !== 'temporary' && styles[`paperAnchorDocked${capitalize$1(ownerState.anchor)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends$4({
  overflowY: 'auto',
  display: 'flex',
  flexDirection: 'column',
  height: '100%',
  flex: '1 0 auto',
  zIndex: theme.zIndex.drawer,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: 'touch',
  // temporary style
  position: 'fixed',
  top: 0,
  // We disable the focus ring for mouse, touch and keyboard users.
  // At some point, it would be better to keep it for keyboard users.
  // :focus-ring CSS pseudo-class will help.
  outline: 0
}, ownerState.anchor === 'left' && {
  left: 0
}, ownerState.anchor === 'top' && {
  top: 0,
  left: 0,
  right: 0,
  height: 'auto',
  maxHeight: '100%'
}, ownerState.anchor === 'right' && {
  right: 0
}, ownerState.anchor === 'bottom' && {
  top: 'auto',
  left: 0,
  bottom: 0,
  right: 0,
  height: 'auto',
  maxHeight: '100%'
}, ownerState.anchor === 'left' && ownerState.variant !== 'temporary' && {
  borderRight: `1px solid ${theme.palette.divider}`
}, ownerState.anchor === 'top' && ownerState.variant !== 'temporary' && {
  borderBottom: `1px solid ${theme.palette.divider}`
}, ownerState.anchor === 'right' && ownerState.variant !== 'temporary' && {
  borderLeft: `1px solid ${theme.palette.divider}`
}, ownerState.anchor === 'bottom' && ownerState.variant !== 'temporary' && {
  borderTop: `1px solid ${theme.palette.divider}`
}));
const oppositeDirection = {
  left: 'right',
  right: 'left',
  top: 'down',
  bottom: 'up'
};
function isHorizontal(anchor) {
  return ['left', 'right'].indexOf(anchor) !== -1;
}
function getAnchor(theme, anchor) {
  return theme.direction === 'rtl' && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;
}
const defaultTransitionDuration = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
/**
 * The props of the [Modal](/api/modal/) component are available
 * when `variant="temporary"` is set.
 */

const Drawer = /*#__PURE__*/react.exports.forwardRef(function Drawer(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiDrawer'
  });

  const {
    anchor: anchorProp = 'left',
    BackdropProps,
    children,
    className,
    elevation = 16,
    hideBackdrop = false,
    ModalProps: {
      BackdropProps: BackdropPropsProp
    } = {},
    onClose,
    open = false,
    PaperProps = {},
    SlideProps,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Slide$1,
    transitionDuration = defaultTransitionDuration,
    variant = 'temporary'
  } = props,
        ModalProps = _objectWithoutPropertiesLoose$3(props.ModalProps, _excluded$e),
        other = _objectWithoutPropertiesLoose$3(props, _excluded2$1);

  const theme = useTheme(); // Let's assume that the Drawer will always be rendered on user space.
  // We use this state is order to skip the appear transition during the
  // initial mount of the component.

  const mounted = react.exports.useRef(false);
  react.exports.useEffect(() => {
    mounted.current = true;
  }, []);
  const anchorInvariant = getAnchor(theme, anchorProp);
  const anchor = anchorProp;

  const ownerState = _extends$4({}, props, {
    anchor,
    elevation,
    open,
    variant
  }, other);

  const classes = useUtilityClasses$e(ownerState);

  const drawer = /*#__PURE__*/jsxRuntime.exports.jsx(DrawerPaper, _extends$4({
    elevation: variant === 'temporary' ? elevation : 0,
    square: true
  }, PaperProps, {
    className: clsx(classes.paper, PaperProps.className),
    ownerState: ownerState,
    children: children
  }));

  if (variant === 'permanent') {
    return /*#__PURE__*/jsxRuntime.exports.jsx(DrawerDockedRoot, _extends$4({
      className: clsx(classes.root, classes.docked, className),
      ownerState: ownerState,
      ref: ref
    }, other, {
      children: drawer
    }));
  }

  const slidingDrawer = /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends$4({
    in: open,
    direction: oppositeDirection[anchorInvariant],
    timeout: transitionDuration,
    appear: mounted.current
  }, SlideProps, {
    children: drawer
  }));

  if (variant === 'persistent') {
    return /*#__PURE__*/jsxRuntime.exports.jsx(DrawerDockedRoot, _extends$4({
      className: clsx(classes.root, classes.docked, className),
      ownerState: ownerState,
      ref: ref
    }, other, {
      children: slidingDrawer
    }));
  } // variant === temporary


  return /*#__PURE__*/jsxRuntime.exports.jsx(DrawerRoot, _extends$4({
    BackdropProps: _extends$4({}, BackdropProps, BackdropPropsProp, {
      transitionDuration
    }),
    className: clsx(classes.root, classes.modal, className),
    open: open,
    ownerState: ownerState,
    onClose: onClose,
    hideBackdrop: hideBackdrop,
    ref: ref
  }, other, ModalProps, {
    children: slidingDrawer
  }));
});
var Drawer$1 = Drawer;

function getFilledInputUtilityClass(slot) {
  return generateUtilityClass('MuiFilledInput', slot);
}
const filledInputClasses = generateUtilityClasses('MuiFilledInput', ['root', 'colorSecondary', 'underline', 'focused', 'disabled', 'adornedStart', 'adornedEnd', 'error', 'sizeSmall', 'multiline', 'hiddenLabel', 'input', 'inputSizeSmall', 'inputHiddenLabel', 'inputMultiline', 'inputAdornedStart', 'inputAdornedEnd']);
var filledInputClasses$1 = filledInputClasses;

const _excluded$d = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "type"];

const useUtilityClasses$d = ownerState => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ['root', !disableUnderline && 'underline'],
    input: ['input']
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return _extends$4({}, classes, composedClasses);
};

const FilledInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiFilledInput',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles), !ownerState.disableUnderline && styles.underline];
  }
})(({
  theme,
  ownerState
}) => {
  const light = theme.palette.mode === 'light';
  const bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
  const backgroundColor = light ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.09)';
  return _extends$4({
    position: 'relative',
    backgroundColor,
    borderTopLeftRadius: theme.shape.borderRadius,
    borderTopRightRadius: theme.shape.borderRadius,
    transition: theme.transitions.create('background-color', {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    }),
    '&:hover': {
      backgroundColor: light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.13)',
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor
      }
    },
    [`&.${filledInputClasses$1.focused}`]: {
      backgroundColor
    },
    [`&.${filledInputClasses$1.disabled}`]: {
      backgroundColor: light ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
    }
  }, !ownerState.disableUnderline && {
    '&:after': {
      borderBottom: `2px solid ${theme.palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: 'absolute',
      right: 0,
      transform: 'scaleX(0)',
      transition: theme.transitions.create('transform', {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: 'none' // Transparent to the hover style.

    },
    [`&.${filledInputClasses$1.focused}:after`]: {
      transform: 'scaleX(1)'
    },
    [`&.${filledInputClasses$1.error}:after`]: {
      borderBottomColor: theme.palette.error.main,
      transform: 'scaleX(1)' // error is always underlined in red

    },
    '&:before': {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: 'absolute',
      right: 0,
      transition: theme.transitions.create('border-bottom-color', {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: 'none' // Transparent to the hover style.

    },
    [`&:hover:not(.${filledInputClasses$1.disabled}):before`]: {
      borderBottom: `1px solid ${theme.palette.text.primary}`
    },
    [`&.${filledInputClasses$1.disabled}:before`]: {
      borderBottomStyle: 'dotted'
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends$4({
    padding: '25px 12px 8px'
  }, ownerState.size === 'small' && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
});
const FilledInputInput = styled(InputBaseComponent, {
  name: 'MuiFilledInput',
  slot: 'Input',
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => _extends$4({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  '&:-webkit-autofill': {
    WebkitBoxShadow: theme.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
    WebkitTextFillColor: theme.palette.mode === 'light' ? null : '#fff',
    caretColor: theme.palette.mode === 'light' ? null : '#fff',
    borderTopLeftRadius: 'inherit',
    borderTopRightRadius: 'inherit'
  }
}, ownerState.size === 'small' && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === 'small' && {
  paddingTop: 8,
  paddingBottom: 9
}));
const FilledInput = /*#__PURE__*/react.exports.forwardRef(function FilledInput(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiFilledInput'
  });

  const {
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    // declare here to prevent spreading to DOM
    inputComponent = 'input',
    multiline = false,
    type = 'text'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$d);

  const ownerState = _extends$4({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type
  });

  const classes = useUtilityClasses$d(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = componentsPropsProp ? deepmerge(componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
  return /*#__PURE__*/jsxRuntime.exports.jsx(InputBase, _extends$4({
    components: _extends$4({
      Root: FilledInputRoot,
      Input: FilledInputInput
    }, components),
    componentsProps: componentsProps,
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other, {
    classes: classes
  }));
});
FilledInput.muiName = 'Input';
var FilledInput$1 = FilledInput;

function getFormControlUtilityClasses(slot) {
  return generateUtilityClass('MuiFormControl', slot);
}
generateUtilityClasses('MuiFormControl', ['root', 'marginNone', 'marginNormal', 'marginDense', 'fullWidth', 'disabled']);

const _excluded$c = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];

const useUtilityClasses$c = ownerState => {
  const {
    classes,
    margin,
    fullWidth
  } = ownerState;
  const slots = {
    root: ['root', margin !== 'none' && `margin${capitalize$1(margin)}`, fullWidth && 'fullWidth']
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};

const FormControlRoot = styled('div', {
  name: 'MuiFormControl',
  slot: 'Root',
  overridesResolver: ({
    ownerState
  }, styles) => {
    return _extends$4({}, styles.root, styles[`margin${capitalize$1(ownerState.margin)}`], ownerState.fullWidth && styles.fullWidth);
  }
})(({
  ownerState
}) => _extends$4({
  display: 'inline-flex',
  flexDirection: 'column',
  position: 'relative',
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: 'top'
}, ownerState.margin === 'normal' && {
  marginTop: 16,
  marginBottom: 8
}, ownerState.margin === 'dense' && {
  marginTop: 8,
  marginBottom: 4
}, ownerState.fullWidth && {
  width: '100%'
}));
/**
 * Provides context such as filled/focused/error/required for form inputs.
 * Relying on the context provides high flexibility and ensures that the state always stays
 * consistent across the children of the `FormControl`.
 * This context is used by the following components:
 *
 *  - FormLabel
 *  - FormHelperText
 *  - Input
 *  - InputLabel
 *
 * You can find one composition example below and more going to [the demos](/components/text-fields/#components).
 *
 * ```jsx
 * <FormControl>
 *   <InputLabel htmlFor="my-input">Email address</InputLabel>
 *   <Input id="my-input" aria-describedby="my-helper-text" />
 *   <FormHelperText id="my-helper-text">We'll never share your email.</FormHelperText>
 * </FormControl>
 * ```
 *
 * ⚠️ Only one `InputBase` can be used within a FormControl because it create visual inconsistencies.
 * For instance, only one input can be focused at the same time, the state shouldn't be shared.
 */

const FormControl = /*#__PURE__*/react.exports.forwardRef(function FormControl(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiFormControl'
  });

  const {
    children,
    className,
    color = 'primary',
    component = 'div',
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin = 'none',
    required = false,
    size = 'medium',
    variant = 'outlined'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$c);

  const ownerState = _extends$4({}, props, {
    color,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin,
    required,
    size,
    variant
  });

  const classes = useUtilityClasses$c(ownerState);
  const [adornedStart, setAdornedStart] = react.exports.useState(() => {
    // We need to iterate through the children and find the Input in order
    // to fully support server-side rendering.
    let initialAdornedStart = false;

    if (children) {
      react.exports.Children.forEach(children, child => {
        if (!isMuiElement(child, ['Input', 'Select'])) {
          return;
        }

        const input = isMuiElement(child, ['Select']) ? child.props.input : child;

        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }

    return initialAdornedStart;
  });
  const [filled, setFilled] = react.exports.useState(() => {
    // We need to iterate through the children and find the Input in order
    // to fully support server-side rendering.
    let initialFilled = false;

    if (children) {
      react.exports.Children.forEach(children, child => {
        if (!isMuiElement(child, ['Input', 'Select'])) {
          return;
        }

        if (isFilled(child.props, true)) {
          initialFilled = true;
        }
      });
    }

    return initialFilled;
  });
  const [focusedState, setFocused] = react.exports.useState(false);

  if (disabled && focusedState) {
    setFocused(false);
  }

  const focused = visuallyFocused !== undefined && !disabled ? visuallyFocused : focusedState;
  let registerEffect;

  const onFilled = react.exports.useCallback(() => {
    setFilled(true);
  }, []);
  const onEmpty = react.exports.useCallback(() => {
    setFilled(false);
  }, []);
  const childContext = {
    adornedStart,
    setAdornedStart,
    color,
    disabled,
    error,
    filled,
    focused,
    fullWidth,
    hiddenLabel,
    size,
    onBlur: () => {
      setFocused(false);
    },
    onEmpty,
    onFilled,
    onFocus: () => {
      setFocused(true);
    },
    registerEffect,
    required,
    variant
  };
  return /*#__PURE__*/jsxRuntime.exports.jsx(FormControlContext.Provider, {
    value: childContext,
    children: /*#__PURE__*/jsxRuntime.exports.jsx(FormControlRoot, _extends$4({
      as: component,
      ownerState: ownerState,
      className: clsx(classes.root, className),
      ref: ref
    }, other, {
      children: children
    }))
  });
});
var FormControl$1 = FormControl;

function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass('MuiFormLabel', slot);
}
const formLabelClasses = generateUtilityClasses('MuiFormLabel', ['root', 'colorSecondary', 'focused', 'disabled', 'error', 'filled', 'required', 'asterisk']);
var formLabelClasses$1 = formLabelClasses;

const _excluded$b = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];

const useUtilityClasses$b = ownerState => {
  const {
    classes,
    color,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ['root', `color${capitalize$1(color)}`, disabled && 'disabled', error && 'error', filled && 'filled', focused && 'focused', required && 'required'],
    asterisk: ['asterisk', error && 'error']
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};

const FormLabelRoot = styled('label', {
  name: 'MuiFormLabel',
  slot: 'Root',
  overridesResolver: ({
    ownerState
  }, styles) => {
    return _extends$4({}, styles.root, ownerState.color === 'secondary' && styles.colorSecondary, ownerState.filled && styles.filled);
  }
})(({
  theme,
  ownerState
}) => _extends$4({
  color: theme.palette.text.secondary
}, theme.typography.body1, {
  lineHeight: '1.4375em',
  padding: 0,
  position: 'relative',
  [`&.${formLabelClasses$1.focused}`]: {
    color: theme.palette[ownerState.color].main
  },
  [`&.${formLabelClasses$1.disabled}`]: {
    color: theme.palette.text.disabled
  },
  [`&.${formLabelClasses$1.error}`]: {
    color: theme.palette.error.main
  }
}));
const AsteriskComponent = styled('span', {
  name: 'MuiFormLabel',
  slot: 'Asterisk',
  overridesResolver: (props, styles) => styles.asterisk
})(({
  theme
}) => ({
  [`&.${formLabelClasses$1.error}`]: {
    color: theme.palette.error.main
  }
}));
const FormLabel = /*#__PURE__*/react.exports.forwardRef(function FormLabel(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiFormLabel'
  });

  const {
    children,
    className,
    component = 'label'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$b);

  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['color', 'required', 'focused', 'disabled', 'error', 'filled']
  });

  const ownerState = _extends$4({}, props, {
    color: fcs.color || 'primary',
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });

  const classes = useUtilityClasses$b(ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(FormLabelRoot, _extends$4({
    as: component,
    ownerState: ownerState,
    className: clsx(classes.root, className),
    ref: ref
  }, other, {
    children: [children, fcs.required && /*#__PURE__*/jsxRuntime.exports.jsxs(AsteriskComponent, {
      ownerState: ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: ["\u2009", '*']
    })]
  }));
});
var FormLabel$1 = FormLabel;

function getInputUtilityClass(slot) {
  return generateUtilityClass('MuiInput', slot);
}
const inputClasses = generateUtilityClasses('MuiInput', ['root', 'formControl', 'focused', 'disabled', 'colorSecondary', 'underline', 'error', 'sizeSmall', 'multiline', 'fullWidth', 'input', 'inputSizeSmall', 'inputMultiline', 'inputTypeSearch']);
var inputClasses$1 = inputClasses;

const _excluded$a = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "type"];

const useUtilityClasses$a = ownerState => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ['root', !disableUnderline && 'underline'],
    input: ['input']
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return _extends$4({}, classes, composedClasses);
};

const InputRoot = styled(InputBaseRoot, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiInput',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles), !ownerState.disableUnderline && styles.underline];
  }
})(({
  theme,
  ownerState
}) => {
  const light = theme.palette.mode === 'light';
  const bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
  return _extends$4({
    position: 'relative'
  }, ownerState.formControl && {
    'label + &': {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    '&:after': {
      borderBottom: `2px solid ${theme.palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: 'absolute',
      right: 0,
      transform: 'scaleX(0)',
      transition: theme.transitions.create('transform', {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: 'none' // Transparent to the hover style.

    },
    [`&.${inputClasses$1.focused}:after`]: {
      transform: 'scaleX(1)'
    },
    [`&.${inputClasses$1.error}:after`]: {
      borderBottomColor: theme.palette.error.main,
      transform: 'scaleX(1)' // error is always underlined in red

    },
    '&:before': {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: 'absolute',
      right: 0,
      transition: theme.transitions.create('border-bottom-color', {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: 'none' // Transparent to the hover style.

    },
    [`&:hover:not(.${inputClasses$1.disabled}):before`]: {
      borderBottom: `2px solid ${theme.palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses$1.disabled}:before`]: {
      borderBottomStyle: 'dotted'
    }
  });
});
const InputInput = styled(InputBaseComponent, {
  name: 'MuiInput',
  slot: 'Input',
  overridesResolver: inputOverridesResolver
})({});
const Input = /*#__PURE__*/react.exports.forwardRef(function Input(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiInput'
  });

  const {
    disableUnderline,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = 'input',
    multiline = false,
    type = 'text'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$a);

  const classes = useUtilityClasses$a(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = componentsPropsProp ? deepmerge(componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  return /*#__PURE__*/jsxRuntime.exports.jsx(InputBase, _extends$4({
    components: _extends$4({
      Root: InputRoot,
      Input: InputInput
    }, components),
    componentsProps: componentsProps,
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other, {
    classes: classes
  }));
});
Input.muiName = 'Input';
var Input$1 = Input;

function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass('MuiInputLabel', slot);
}
generateUtilityClasses('MuiInputLabel', ['root', 'focused', 'disabled', 'error', 'required', 'asterisk', 'formControl', 'sizeSmall', 'shrink', 'animated', 'standard', 'filled', 'outlined']);

const _excluded$9 = ["disableAnimation", "margin", "shrink", "variant"];

const useUtilityClasses$9 = ownerState => {
  const {
    classes,
    formControl,
    size,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ['root', formControl && 'formControl', !disableAnimation && 'animated', shrink && 'shrink', size === 'small' && 'sizeSmall', variant],
    asterisk: [required && 'asterisk']
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return _extends$4({}, classes, composedClasses);
};

const InputLabelRoot = styled(FormLabel$1, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiInputLabel',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses$1.asterisk}`]: styles.asterisk
    }, styles.root, ownerState.formControl && styles.formControl, ownerState.size === 'small' && styles.sizeSmall, ownerState.shrink && styles.shrink, !ownerState.disableAnimation && styles.animated, styles[ownerState.variant]];
  }
})(({
  theme,
  ownerState
}) => _extends$4({
  display: 'block',
  transformOrigin: 'top left',
  whiteSpace: 'nowrap',
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  maxWidth: '100%'
}, ownerState.formControl && {
  position: 'absolute',
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: 'translate(0, 20px) scale(1)'
}, ownerState.size === 'small' && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: 'translate(0, 17px) scale(1)'
}, ownerState.shrink && {
  transform: 'translate(0, -1.5px) scale(0.75)',
  transformOrigin: 'top left',
  maxWidth: '133%'
}, !ownerState.disableAnimation && {
  transition: theme.transitions.create(['color', 'transform', 'max-width'], {
    duration: theme.transitions.duration.shorter,
    easing: theme.transitions.easing.easeOut
  })
}, ownerState.variant === 'filled' && _extends$4({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: 'none',
  transform: 'translate(12px, 16px) scale(1)',
  maxWidth: 'calc(100% - 24px)'
}, ownerState.size === 'small' && {
  transform: 'translate(12px, 13px) scale(1)'
}, ownerState.shrink && _extends$4({
  transform: 'translate(12px, 7px) scale(0.75)',
  maxWidth: 'calc(133% - 24px)'
}, ownerState.size === 'small' && {
  transform: 'translate(12px, 4px) scale(0.75)'
})), ownerState.variant === 'outlined' && _extends$4({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: 'none',
  transform: 'translate(14px, 16px) scale(1)',
  maxWidth: 'calc(100% - 24px)'
}, ownerState.size === 'small' && {
  transform: 'translate(14px, 9px) scale(1)'
}, ownerState.shrink && {
  maxWidth: 'calc(133% - 24px)',
  transform: 'translate(14px, -9px) scale(0.75)'
})));
const InputLabel = /*#__PURE__*/react.exports.forwardRef(function InputLabel(inProps, ref) {
  const props = useThemeProps({
    name: 'MuiInputLabel',
    props: inProps
  });

  const {
    disableAnimation = false,
    shrink: shrinkProp
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$9);

  const muiFormControl = useFormControl();
  let shrink = shrinkProp;

  if (typeof shrink === 'undefined' && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }

  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['size', 'variant', 'required']
  });

  const ownerState = _extends$4({}, props, {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required
  });

  const classes = useUtilityClasses$9(ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(InputLabelRoot, _extends$4({
    "data-shrink": shrink,
    ownerState: ownerState,
    ref: ref
  }, other, {
    classes: classes
  }));
});
var InputLabel$1 = InputLabel;

function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass('MuiNativeSelect', slot);
}
const nativeSelectClasses = generateUtilityClasses('MuiNativeSelect', ['root', 'select', 'filled', 'outlined', 'standard', 'disabled', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput']);

const _excluded$8 = ["className", "disabled", "IconComponent", "inputRef", "variant"];

const useUtilityClasses$8 = ownerState => {
  const {
    classes,
    variant,
    disabled,
    open
  } = ownerState;
  const slots = {
    select: ['select', variant, disabled && 'disabled'],
    icon: ['icon', `icon${capitalize$1(variant)}`, open && 'iconOpen', disabled && 'disabled']
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};

const nativeSelectSelectStyles = ({
  ownerState,
  theme
}) => _extends$4({
  MozAppearance: 'none',
  // Reset
  WebkitAppearance: 'none',
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: 'none',
  borderRadius: 0,
  // Reset
  cursor: 'pointer',
  '&:focus': {
    // Show that it's not an text input
    backgroundColor: theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',
    borderRadius: 0 // Reset Chrome style

  },
  // Remove IE11 arrow
  '&::-ms-expand': {
    display: 'none'
  },
  [`&.${nativeSelectClasses.disabled}`]: {
    cursor: 'default'
  },
  '&[multiple]': {
    height: 'auto'
  },
  '&:not([multiple]) option, &:not([multiple]) optgroup': {
    backgroundColor: theme.palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  '&&&': {
    paddingRight: 24,
    minWidth: 16 // So it doesn't collapse.

  }
}, ownerState.variant === 'filled' && {
  '&&&': {
    paddingRight: 32
  }
}, ownerState.variant === 'outlined' && {
  borderRadius: theme.shape.borderRadius,
  '&:focus': {
    borderRadius: theme.shape.borderRadius // Reset the reset for Chrome style

  },
  '&&&': {
    paddingRight: 32
  }
});
const NativeSelectSelect = styled('select', {
  name: 'MuiNativeSelect',
  slot: 'Select',
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.select, styles[ownerState.variant]];
  }
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = ({
  ownerState,
  theme
}) => _extends$4({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: 'absolute',
  right: 0,
  top: 'calc(50% - .5em)',
  // Center vertically, height is 1em
  pointerEvents: 'none',
  // Don't block pointer events on the select under the icon.
  color: theme.palette.action.active,
  [`&.${nativeSelectClasses.disabled}`]: {
    color: theme.palette.action.disabled
  }
}, ownerState.open && {
  transform: 'rotate(180deg)'
}, ownerState.variant === 'filled' && {
  right: 7
}, ownerState.variant === 'outlined' && {
  right: 7
});
const NativeSelectIcon = styled('svg', {
  name: 'MuiNativeSelect',
  slot: 'Icon',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.icon, ownerState.variant && styles[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles.iconOpen];
  }
})(nativeSelectIconStyles);
/**
 * @ignore - internal component.
 */

const NativeSelectInput = /*#__PURE__*/react.exports.forwardRef(function NativeSelectInput(props, ref) {
  const {
    className,
    disabled,
    IconComponent,
    inputRef,
    variant = 'standard'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$8);

  const ownerState = _extends$4({}, props, {
    disabled,
    variant
  });

  const classes = useUtilityClasses$8(ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(react.exports.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx(NativeSelectSelect, _extends$4({
      ownerState: ownerState,
      className: clsx(classes.select, className),
      disabled: disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /*#__PURE__*/jsxRuntime.exports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState: ownerState,
      className: classes.icon
    })]
  });
});
var NativeSelectInput$1 = NativeSelectInput;

function getSelectUtilityClasses(slot) {
  return generateUtilityClass('MuiSelect', slot);
}
const selectClasses = generateUtilityClasses('MuiSelect', ['root', 'select', 'filled', 'outlined', 'standard', 'disabled', 'focused', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput']);

const _excluded$7 = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultValue", "disabled", "displayEmpty", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
const SelectSelect = styled('div', {
  name: 'MuiSelect',
  slot: 'Select',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [// Win specificity over the input base
    {
      [`&.${selectClasses.select}`]: styles.select
    }, {
      [`&.${selectClasses.select}`]: styles[ownerState.variant]
    }];
  }
})(nativeSelectSelectStyles, {
  // Win specificity over the input base
  [`&.${selectClasses.select}`]: {
    height: 'auto',
    // Resets for multiple select with chips
    minHeight: '1.4375em',
    // Required for select\text-field height consistency
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    overflow: 'hidden'
  }
});
const SelectIcon = styled('svg', {
  name: 'MuiSelect',
  slot: 'Icon',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.icon, ownerState.variant && styles[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles.iconOpen];
  }
})(nativeSelectIconStyles);
const SelectNativeInput = styled('input', {
  shouldForwardProp: prop => slotShouldForwardProp(prop) && prop !== 'classes',
  name: 'MuiSelect',
  slot: 'NativeInput',
  overridesResolver: (props, styles) => styles.nativeInput
})({
  bottom: 0,
  left: 0,
  position: 'absolute',
  opacity: 0,
  pointerEvents: 'none',
  width: '100%',
  boxSizing: 'border-box'
});

function areEqualValues(a, b) {
  if (typeof b === 'object' && b !== null) {
    return a === b;
  } // The value could be a number, the DOM will stringify it anyway.


  return String(a) === String(b);
}

function isEmpty(display) {
  return display == null || typeof display === 'string' && !display.trim();
}

const useUtilityClasses$7 = ownerState => {
  const {
    classes,
    variant,
    disabled,
    open
  } = ownerState;
  const slots = {
    select: ['select', variant, disabled && 'disabled'],
    icon: ['icon', `icon${capitalize$1(variant)}`, open && 'iconOpen', disabled && 'disabled'],
    nativeInput: ['nativeInput']
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};
/**
 * @ignore - internal component.
 */


const SelectInput = /*#__PURE__*/react.exports.forwardRef(function SelectInput(props, ref) {
  const {
    'aria-describedby': ariaDescribedby,
    'aria-label': ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultValue,
    disabled,
    displayEmpty,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    value: valueProp,
    variant = 'standard'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$7);

  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: 'Select'
  });
  const inputRef = react.exports.useRef(null);
  const displayRef = react.exports.useRef(null);
  const [displayNode, setDisplayNode] = react.exports.useState(null);
  const {
    current: isOpenControlled
  } = react.exports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = react.exports.useState();
  const [openState, setOpenState] = react.exports.useState(false);
  const handleRef = useForkRef(ref, inputRefProp);
  const handleDisplayRef = react.exports.useCallback(node => {
    displayRef.current = node;

    if (node) {
      setDisplayNode(node);
    }
  }, []);
  react.exports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  react.exports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  react.exports.useEffect(() => {
    const label = ownerDocument(displayRef.current).getElementById(labelId);

    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };

      label.addEventListener('click', handler);
      return () => {
        label.removeEventListener('click', handler);
      };
    }

    return undefined;
  }, [labelId]);

  const update = (open, event) => {
    if (open) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }

    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
      setOpenState(open);
    }
  };

  const handleMouseDown = event => {
    // Ignore everything but left-click
    if (event.button !== 0) {
      return;
    } // Hijack the default focus behavior.


    event.preventDefault();
    displayRef.current.focus();
    update(true, event);
  };

  const handleClose = event => {
    update(false, event);
  };

  const childrenArray = react.exports.Children.toArray(children); // Support autofill.

  const handleChange = event => {
    const index = childrenArray.map(child => child.props.value).indexOf(event.target.value);

    if (index === -1) {
      return;
    }

    const child = childrenArray[index];
    setValueState(child.props.value);

    if (onChange) {
      onChange(event, child);
    }
  };

  const handleItemClick = child => event => {
    let newValue; // We use the tabindex attribute to signal the available options.

    if (!event.currentTarget.hasAttribute('tabindex')) {
      return;
    }

    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);

      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }

    if (child.props.onClick) {
      child.props.onClick(event);
    }

    if (value !== newValue) {
      setValueState(newValue);

      if (onChange) {
        // Redefine target to allow name and value to be read.
        // This allows seamless integration with the most popular form libraries.
        // https://github.com/mui-org/material-ui/issues/13485#issuecomment-676048492
        // Clone the event to not override `target` of the original event.
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, 'target', {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }

    if (!multiple) {
      update(false, event);
    }
  };

  const handleKeyDown = event => {
    if (!readOnly) {
      const validKeys = [' ', 'ArrowUp', 'ArrowDown', // The native select doesn't respond to enter on MacOS, but it's recommended by
      // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
      'Enter'];

      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update(true, event);
      }
    }
  };

  const open = displayNode !== null && (isOpenControlled ? openProp : openState);

  const handleBlur = event => {
    // if open event.stopImmediatePropagation
    if (!open && onBlur) {
      // Preact support, target is read only property on a native event.
      Object.defineProperty(event, 'target', {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  };

  delete other['aria-invalid'];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;

  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }

  const items = childrenArray.map(child => {
    if (! /*#__PURE__*/react.exports.isValidElement(child)) {
      return null;
    }

    let selected;

    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }

      selected = value.some(v => areEqualValues(v, child.props.value));

      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);

      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }

    return /*#__PURE__*/react.exports.cloneElement(child, {
      'aria-selected': selected ? 'true' : undefined,
      onClick: handleItemClick(child),
      onKeyUp: event => {
        if (event.key === ' ') {
          // otherwise our MenuItems dispatches a click event
          // it's not behavior of the native <option> and causes
          // the select to close immediately since we open on space keydown
          event.preventDefault();
        }

        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: 'option',
      selected,
      value: undefined,
      // The value is most likely not a valid HTML attribute.
      'data-value': child.props.value // Instead, we provide it as a data attribute.

    });
  });

  if (computeDisplay) {
    display = multiple ? displayMultiple.join(', ') : displaySingle;
  } // Avoid performing a layout computation in the render method.


  let menuMinWidth = menuMinWidthState;

  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = displayNode.clientWidth;
  }

  let tabIndex;

  if (typeof tabIndexProp !== 'undefined') {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }

  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : undefined);

  const ownerState = _extends$4({}, props, {
    variant,
    value,
    open
  });

  const classes = useUtilityClasses$7(ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(react.exports.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx(SelectSelect, _extends$4({
      ref: handleDisplayRef,
      tabIndex: tabIndex,
      role: "button",
      "aria-disabled": disabled ? 'true' : undefined,
      "aria-expanded": open ? 'true' : 'false',
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(' ') || undefined,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus: onFocus
    }, SelectDisplayProps, {
      ownerState: ownerState,
      className: clsx(classes.select, className, SelectDisplayProps.className) // The id is required for proper a11y
      ,
      id: buttonId,
      children: isEmpty(display) ?
      /*#__PURE__*/
      // notranslate needed while Google Translate will not fix zero-width space issue
      // eslint-disable-next-line react/no-danger
      jsxRuntime.exports.jsx("span", {
        className: "notranslate",
        dangerouslySetInnerHTML: {
          __html: '&#8203;'
        }
      }) : display
    })), /*#__PURE__*/jsxRuntime.exports.jsx(SelectNativeInput, _extends$4({
      value: Array.isArray(value) ? value.join(',') : value,
      name: name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled: disabled,
      className: classes.nativeInput,
      autoFocus: autoFocus,
      ownerState: ownerState
    }, other)), /*#__PURE__*/jsxRuntime.exports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState: ownerState
    }), /*#__PURE__*/jsxRuntime.exports.jsx(MuiMenu, _extends$4({
      id: `menu-${name || ''}`,
      anchorEl: displayNode,
      open: open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: 'bottom',
        horizontal: 'center'
      },
      transformOrigin: {
        vertical: 'top',
        horizontal: 'center'
      }
    }, MenuProps, {
      MenuListProps: _extends$4({
        'aria-labelledby': labelId,
        role: 'listbox',
        disableListWrap: true
      }, MenuProps.MenuListProps),
      PaperProps: _extends$4({}, MenuProps.PaperProps, {
        style: _extends$4({
          minWidth: menuMinWidth
        }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
      }),
      children: items
    }))]
  });
});
var SelectInput$1 = SelectInput;

var _Input, _FilledInput;

const _excluded$6 = ["autoWidth", "children", "classes", "className", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"],
      _excluded2 = ["root"];

const useUtilityClasses$6 = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root']
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};

const Select = /*#__PURE__*/react.exports.forwardRef(function Select(inProps, ref) {
  const props = useThemeProps({
    name: 'MuiSelect',
    props: inProps
  });

  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProps = 'outlined'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$6);

  const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['variant']
  });
  const variant = fcs.variant || variantProps;
  const InputComponent = input || {
    standard: _Input || (_Input = /*#__PURE__*/jsxRuntime.exports.jsx(Input$1, {})),
    outlined: /*#__PURE__*/jsxRuntime.exports.jsx(MuiOutlinedInput, {
      label: label
    }),
    filled: _FilledInput || (_FilledInput = /*#__PURE__*/jsxRuntime.exports.jsx(FilledInput$1, {}))
  }[variant];

  const ownerState = _extends$4({}, props, {
    classes: classesProp
  });

  const classes = useUtilityClasses$6(ownerState);

  const otherClasses = _objectWithoutPropertiesLoose$3(classesProp, _excluded2);

  const inputComponentRef = useForkRef(ref, InputComponent.ref);
  return /*#__PURE__*/react.exports.cloneElement(InputComponent, _extends$4({
    // Most of the logic is implemented in `SelectInput`.
    // The `Select` component is a simple API wrapper to expose something better to play with.
    inputComponent,
    inputProps: _extends$4({
      children,
      IconComponent,
      variant,
      type: undefined,
      // We render a select. We can ignore the type provided by the `Input`.
      multiple
    }, native ? {
      id
    } : {
      autoWidth,
      displayEmpty,
      labelId,
      MenuProps,
      onClose,
      onOpen,
      open,
      renderValue,
      SelectDisplayProps: _extends$4({
        id
      }, SelectDisplayProps)
    }, inputProps, {
      classes: inputProps ? deepmerge(otherClasses, inputProps.classes) : otherClasses
    }, input ? input.props.inputProps : {})
  }, multiple && native && variant === 'outlined' ? {
    notched: true
  } : {}, {
    ref: inputComponentRef,
    className: clsx(classes.root, InputComponent.props.className, className)
  }, other));
});
Select.muiName = 'Select';
var Select$1 = Select;

/**
 * @ignore - internal component.
 */

const StepperContext = /*#__PURE__*/react.exports.createContext({});

var StepperContext$1 = StepperContext;

/**
 * @ignore - internal component.
 */

const StepContext = /*#__PURE__*/react.exports.createContext({});

var StepContext$1 = StepContext;

function getStepUtilityClass(slot) {
  return generateUtilityClass('MuiStep', slot);
}
generateUtilityClasses('MuiStep', ['root', 'horizontal', 'vertical', 'alternativeLabel', 'completed']);

const _excluded$5 = ["active", "children", "className", "completed", "disabled", "expanded", "index", "last"];

const useUtilityClasses$5 = ownerState => {
  const {
    classes,
    orientation,
    alternativeLabel,
    completed
  } = ownerState;
  const slots = {
    root: ['root', orientation, alternativeLabel && 'alternativeLabel', completed && 'completed']
  };
  return composeClasses(slots, getStepUtilityClass, classes);
};

const StepRoot = styled('div', {
  name: 'MuiStep',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.orientation], ownerState.alternativeLabel && styles.alternativeLabel, ownerState.completed && styles.completed];
  }
})(({
  ownerState
}) => _extends$4({}, ownerState.orientation === 'horizontal' && {
  paddingLeft: 8,
  paddingRight: 8
}, ownerState.alternativeLabel && {
  flex: 1,
  position: 'relative'
}));
const Step = /*#__PURE__*/react.exports.forwardRef(function Step(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiStep'
  });

  const {
    active: activeProp,
    children,
    className,
    completed: completedProp,
    disabled: disabledProp,
    expanded = false,
    index,
    last
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$5);

  const {
    activeStep,
    connector,
    alternativeLabel,
    orientation,
    nonLinear
  } = react.exports.useContext(StepperContext$1);
  let [active = false, completed = false, disabled = false] = [activeProp, completedProp, disabledProp];

  if (activeStep === index) {
    active = activeProp !== undefined ? activeProp : true;
  } else if (!nonLinear && activeStep > index) {
    completed = completedProp !== undefined ? completedProp : true;
  } else if (!nonLinear && activeStep < index) {
    disabled = disabledProp !== undefined ? disabledProp : true;
  }

  const contextValue = react.exports.useMemo(() => ({
    index,
    last,
    expanded,
    icon: index + 1,
    active,
    completed,
    disabled
  }), [index, last, expanded, active, completed, disabled]);

  const ownerState = _extends$4({}, props, {
    active,
    orientation,
    alternativeLabel,
    completed,
    disabled,
    expanded
  });

  const classes = useUtilityClasses$5(ownerState);

  const newChildren = /*#__PURE__*/jsxRuntime.exports.jsxs(StepRoot, _extends$4({
    className: clsx(classes.root, className),
    ref: ref,
    ownerState: ownerState
  }, other, {
    children: [connector && alternativeLabel && index !== 0 ? connector : null, children]
  }));

  return /*#__PURE__*/jsxRuntime.exports.jsx(StepContext$1.Provider, {
    value: contextValue,
    children: connector && !alternativeLabel && index !== 0 ? /*#__PURE__*/jsxRuntime.exports.jsxs(react.exports.Fragment, {
      children: [connector, newChildren]
    }) : newChildren
  });
});
var Step$1 = Step;

var CheckCircle = createSvgIcon( /*#__PURE__*/jsxRuntime.exports.jsx("path", {
  d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm-2 17l-5-5 1.4-1.4 3.6 3.6 7.6-7.6L19 8l-9 9z"
}), 'CheckCircle');

var Warning = createSvgIcon( /*#__PURE__*/jsxRuntime.exports.jsx("path", {
  d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"
}), 'Warning');

function getStepIconUtilityClass(slot) {
  return generateUtilityClass('MuiStepIcon', slot);
}
const stepIconClasses = generateUtilityClasses('MuiStepIcon', ['root', 'active', 'completed', 'error', 'text']);
var stepIconClasses$1 = stepIconClasses;

var _circle;

const _excluded$4 = ["active", "className", "completed", "error", "icon"];

const useUtilityClasses$4 = ownerState => {
  const {
    classes,
    active,
    completed,
    error
  } = ownerState;
  const slots = {
    root: ['root', active && 'active', completed && 'completed', error && 'error'],
    text: ['text']
  };
  return composeClasses(slots, getStepIconUtilityClass, classes);
};

const StepIconRoot = styled(SvgIcon, {
  name: 'MuiStepIcon',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => ({
  display: 'block',
  transition: theme.transitions.create('color', {
    duration: theme.transitions.duration.shortest
  }),
  color: theme.palette.text.disabled,
  [`&.${stepIconClasses$1.completed}`]: {
    color: theme.palette.primary.main
  },
  [`&.${stepIconClasses$1.active}`]: {
    color: theme.palette.primary.main
  },
  [`&.${stepIconClasses$1.error}`]: {
    color: theme.palette.error.main
  }
}));
const StepIconText = styled('text', {
  name: 'MuiStepIcon',
  slot: 'Text',
  overridesResolver: (props, styles) => styles.text
})(({
  theme
}) => ({
  fill: theme.palette.primary.contrastText,
  fontSize: theme.typography.caption.fontSize,
  fontFamily: theme.typography.fontFamily
}));
const StepIcon = /*#__PURE__*/react.exports.forwardRef(function StepIcon(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiStepIcon'
  });

  const {
    active = false,
    className: classNameProp,
    completed = false,
    error = false,
    icon
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$4);

  const ownerState = _extends$4({}, props, {
    active,
    completed,
    error
  });

  const classes = useUtilityClasses$4(ownerState);

  if (typeof icon === 'number' || typeof icon === 'string') {
    const className = clsx(classNameProp, classes.root);

    if (error) {
      return /*#__PURE__*/jsxRuntime.exports.jsx(StepIconRoot, _extends$4({
        as: Warning,
        className: className,
        ref: ref,
        ownerState: ownerState
      }, other));
    }

    if (completed) {
      return /*#__PURE__*/jsxRuntime.exports.jsx(StepIconRoot, _extends$4({
        as: CheckCircle,
        className: className,
        ref: ref,
        ownerState: ownerState
      }, other));
    }

    return /*#__PURE__*/jsxRuntime.exports.jsxs(StepIconRoot, _extends$4({
      className: className,
      ref: ref,
      ownerState: ownerState
    }, other, {
      children: [_circle || (_circle = /*#__PURE__*/jsxRuntime.exports.jsx("circle", {
        cx: "12",
        cy: "12",
        r: "12"
      })), /*#__PURE__*/jsxRuntime.exports.jsx(StepIconText, {
        className: classes.text,
        x: "12",
        y: "16",
        textAnchor: "middle",
        ownerState: ownerState,
        children: icon
      })]
    }));
  }

  return icon;
});
var StepIcon$1 = StepIcon;

function getStepLabelUtilityClass(slot) {
  return generateUtilityClass('MuiStepLabel', slot);
}
const stepLabelClasses = generateUtilityClasses('MuiStepLabel', ['root', 'horizontal', 'vertical', 'label', 'active', 'completed', 'error', 'disabled', 'iconContainer', 'alternativeLabel', 'labelContainer']);
var stepLabelClasses$1 = stepLabelClasses;

const _excluded$3 = ["children", "className", "componentsProps", "error", "icon", "optional", "StepIconComponent", "StepIconProps"];

const useUtilityClasses$3 = ownerState => {
  const {
    classes,
    orientation,
    active,
    completed,
    error,
    disabled,
    alternativeLabel
  } = ownerState;
  const slots = {
    root: ['root', orientation, error && 'error', disabled && 'disabled', alternativeLabel && 'alternativeLabel'],
    label: ['label', active && 'active', completed && 'completed', error && 'error', disabled && 'disabled', alternativeLabel && 'alternativeLabel'],
    iconContainer: ['iconContainer', alternativeLabel && 'alternativeLabel'],
    labelContainer: ['labelContainer']
  };
  return composeClasses(slots, getStepLabelUtilityClass, classes);
};

const StepLabelRoot = styled('span', {
  name: 'MuiStepLabel',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.orientation]];
  }
})(({
  ownerState
}) => _extends$4({
  display: 'flex',
  alignItems: 'center',
  [`&.${stepLabelClasses$1.alternativeLabel}`]: {
    flexDirection: 'column'
  },
  [`&.${stepLabelClasses$1.disabled}`]: {
    cursor: 'default'
  }
}, ownerState.orientation === 'vertical' && {
  textAlign: 'left',
  padding: '8px 0'
}));
const StepLabelLabel = styled('span', {
  name: 'MuiStepLabel',
  slot: 'Label',
  overridesResolver: (props, styles) => styles.label
})(({
  theme
}) => _extends$4({}, theme.typography.body2, {
  display: 'block',
  transition: theme.transitions.create('color', {
    duration: theme.transitions.duration.shortest
  }),
  [`&.${stepLabelClasses$1.active}`]: {
    color: theme.palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses$1.completed}`]: {
    color: theme.palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses$1.alternativeLabel}`]: {
    textAlign: 'center',
    marginTop: 16
  },
  [`&.${stepLabelClasses$1.error}`]: {
    color: theme.palette.error.main
  }
}));
const StepLabelIconContainer = styled('span', {
  name: 'MuiStepLabel',
  slot: 'IconContainer',
  overridesResolver: (props, styles) => styles.iconContainer
})(() => ({
  flexShrink: 0,
  // Fix IE11 issue
  display: 'flex',
  paddingRight: 8,
  [`&.${stepLabelClasses$1.alternativeLabel}`]: {
    paddingRight: 0
  }
}));
const StepLabelLabelContainer = styled('span', {
  name: 'MuiStepLabel',
  slot: 'LabelContainer',
  overridesResolver: (props, styles) => styles.labelContainer
})(({
  theme
}) => ({
  width: '100%',
  color: theme.palette.text.secondary
}));
const StepLabel = /*#__PURE__*/react.exports.forwardRef(function StepLabel(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiStepLabel'
  });

  const {
    children,
    className,
    componentsProps = {},
    error = false,
    icon: iconProp,
    optional,
    StepIconComponent: StepIconComponentProp,
    StepIconProps
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$3);

  const {
    alternativeLabel,
    orientation
  } = react.exports.useContext(StepperContext$1);
  const {
    active,
    disabled,
    completed,
    icon: iconContext
  } = react.exports.useContext(StepContext$1);
  const icon = iconProp || iconContext;
  let StepIconComponent = StepIconComponentProp;

  if (icon && !StepIconComponent) {
    StepIconComponent = StepIcon$1;
  }

  const ownerState = _extends$4({}, props, {
    active,
    alternativeLabel,
    completed,
    disabled,
    error,
    orientation
  });

  const classes = useUtilityClasses$3(ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(StepLabelRoot, _extends$4({
    className: clsx(classes.root, className),
    ref: ref,
    ownerState: ownerState
  }, other, {
    children: [icon || StepIconComponent ? /*#__PURE__*/jsxRuntime.exports.jsx(StepLabelIconContainer, {
      className: classes.iconContainer,
      ownerState: ownerState,
      children: /*#__PURE__*/jsxRuntime.exports.jsx(StepIconComponent, _extends$4({
        completed: completed,
        active: active,
        error: error,
        icon: icon
      }, StepIconProps))
    }) : null, /*#__PURE__*/jsxRuntime.exports.jsxs(StepLabelLabelContainer, {
      className: classes.labelContainer,
      ownerState: ownerState,
      children: [children ? /*#__PURE__*/jsxRuntime.exports.jsx(StepLabelLabel, _extends$4({
        className: classes.label,
        ownerState: ownerState
      }, componentsProps.label, {
        children: children
      })) : null, optional]
    })]
  }));
});
StepLabel.muiName = 'StepLabel';
var StepLabel$1 = StepLabel;

function getStepConnectorUtilityClass(slot) {
  return generateUtilityClass('MuiStepConnector', slot);
}
generateUtilityClasses('MuiStepConnector', ['root', 'horizontal', 'vertical', 'alternativeLabel', 'active', 'completed', 'disabled', 'line', 'lineHorizontal', 'lineVertical']);

const _excluded$2 = ["className"];

const useUtilityClasses$2 = ownerState => {
  const {
    classes,
    orientation,
    alternativeLabel,
    active,
    completed,
    disabled
  } = ownerState;
  const slots = {
    root: ['root', orientation, alternativeLabel && 'alternativeLabel', active && 'active', completed && 'completed', disabled && 'disabled'],
    line: ['line', `line${capitalize$1(orientation)}`]
  };
  return composeClasses(slots, getStepConnectorUtilityClass, classes);
};

const StepConnectorRoot = styled('div', {
  name: 'MuiStepConnector',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.orientation], ownerState.alternativeLabel && styles.alternativeLabel, ownerState.completed && styles.completed];
  }
})(({
  ownerState
}) => _extends$4({
  flex: '1 1 auto'
}, ownerState.orientation === 'vertical' && {
  marginLeft: 12 // half icon

}, ownerState.alternativeLabel && {
  position: 'absolute',
  top: 8 + 4,
  left: 'calc(-50% + 20px)',
  right: 'calc(50% + 20px)'
}));
const StepConnectorLine = styled('span', {
  name: 'MuiStepConnector',
  slot: 'Line',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.line, styles[`line${capitalize$1(ownerState.orientation)}`]];
  }
})(({
  ownerState,
  theme
}) => _extends$4({
  display: 'block',
  borderColor: theme.palette.mode === 'light' ? theme.palette.grey[400] : theme.palette.grey[600]
}, ownerState.orientation === 'horizontal' && {
  borderTopStyle: 'solid',
  borderTopWidth: 1
}, ownerState.orientation === 'vertical' && {
  borderLeftStyle: 'solid',
  borderLeftWidth: 1,
  minHeight: 24
}));
const StepConnector = /*#__PURE__*/react.exports.forwardRef(function StepConnector(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiStepConnector'
  });

  const {
    className
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$2);

  const {
    alternativeLabel,
    orientation = 'horizontal'
  } = react.exports.useContext(StepperContext$1);
  const {
    active,
    disabled,
    completed
  } = react.exports.useContext(StepContext$1);

  const ownerState = _extends$4({}, props, {
    alternativeLabel,
    orientation,
    active,
    completed,
    disabled
  });

  const classes = useUtilityClasses$2(ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(StepConnectorRoot, _extends$4({
    className: clsx(classes.root, className),
    ref: ref,
    ownerState: ownerState
  }, other, {
    children: /*#__PURE__*/jsxRuntime.exports.jsx(StepConnectorLine, {
      className: classes.line,
      ownerState: ownerState
    })
  }));
});
var StepConnector$1 = StepConnector;

function getStepperUtilityClass(slot) {
  return generateUtilityClass('MuiStepper', slot);
}
generateUtilityClasses('MuiStepper', ['root', 'horizontal', 'vertical', 'alternativeLabel']);

const _excluded$1 = ["activeStep", "alternativeLabel", "children", "className", "connector", "nonLinear", "orientation"];

const useUtilityClasses$1 = ownerState => {
  const {
    orientation,
    alternativeLabel,
    classes
  } = ownerState;
  const slots = {
    root: ['root', orientation, alternativeLabel && 'alternativeLabel']
  };
  return composeClasses(slots, getStepperUtilityClass, classes);
};

const StepperRoot = styled('div', {
  name: 'MuiStepper',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.orientation], ownerState.alternativeLabel && styles.alternativeLabel];
  }
})(({
  ownerState
}) => _extends$4({
  display: 'flex'
}, ownerState.orientation === 'horizontal' && {
  flexDirection: 'row',
  alignItems: 'center'
}, ownerState.orientation === 'vertical' && {
  flexDirection: 'column'
}, ownerState.alternativeLabel && {
  alignItems: 'flex-start'
}));

const defaultConnector = /*#__PURE__*/jsxRuntime.exports.jsx(StepConnector$1, {});

const Stepper = /*#__PURE__*/react.exports.forwardRef(function Stepper(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiStepper'
  });

  const {
    activeStep = 0,
    alternativeLabel = false,
    children,
    className,
    connector = defaultConnector,
    nonLinear = false,
    orientation = 'horizontal'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded$1);

  const ownerState = _extends$4({}, props, {
    alternativeLabel,
    orientation
  });

  const classes = useUtilityClasses$1(ownerState);
  const childrenArray = react.exports.Children.toArray(children).filter(Boolean);
  const steps = childrenArray.map((step, index) => {
    return /*#__PURE__*/react.exports.cloneElement(step, _extends$4({
      index,
      last: index + 1 === childrenArray.length
    }, step.props));
  });
  const contextValue = react.exports.useMemo(() => ({
    activeStep,
    alternativeLabel,
    connector,
    nonLinear,
    orientation
  }), [activeStep, alternativeLabel, connector, nonLinear, orientation]);
  return /*#__PURE__*/jsxRuntime.exports.jsx(StepperContext$1.Provider, {
    value: contextValue,
    children: /*#__PURE__*/jsxRuntime.exports.jsx(StepperRoot, _extends$4({
      ownerState: ownerState,
      className: clsx(classes.root, className),
      ref: ref
    }, other, {
      children: steps
    }))
  });
});
var Stepper$1 = Stepper;

function getTextFieldUtilityClass(slot) {
  return generateUtilityClass('MuiTextField', slot);
}
generateUtilityClasses('MuiTextField', ['root']);

const _excluded = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
const variantComponent = {
  standard: Input$1,
  filled: FilledInput$1,
  outlined: MuiOutlinedInput
};

const useUtilityClasses = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root']
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};

const TextFieldRoot = styled(FormControl$1, {
  name: 'MuiTextField',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({});
/**
 * The `TextField` is a convenience wrapper for the most common cases (80%).
 * It cannot be all things to all people, otherwise the API would grow out of control.
 *
 * ## Advanced Configuration
 *
 * It's important to understand that the text field is a simple abstraction
 * on top of the following components:
 *
 * - [FormControl](/api/form-control/)
 * - [InputLabel](/api/input-label/)
 * - [FilledInput](/api/filled-input/)
 * - [OutlinedInput](/api/outlined-input/)
 * - [Input](/api/input/)
 * - [FormHelperText](/api/form-helper-text/)
 *
 * If you wish to alter the props applied to the `input` element, you can do so as follows:
 *
 * ```jsx
 * const inputProps = {
 *   step: 300,
 * };
 *
 * return <TextField id="time" type="time" inputProps={inputProps} />;
 * ```
 *
 * For advanced cases, please look at the source of TextField by clicking on the
 * "Edit this page" button above. Consider either:
 *
 * - using the upper case props for passing values directly to the components
 * - using the underlying components directly as shown in the demos
 */

const TextField = /*#__PURE__*/react.exports.forwardRef(function TextField(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiTextField'
  });

  const {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color = 'primary',
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps,
    fullWidth = false,
    helperText,
    id,
    InputLabelProps,
    inputProps,
    InputProps,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select = false,
    SelectProps,
    type,
    value,
    variant = 'outlined'
  } = props,
        other = _objectWithoutPropertiesLoose$3(props, _excluded);

  const ownerState = _extends$4({}, props, {
    autoFocus,
    color,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  });

  const classes = useUtilityClasses(ownerState);

  const InputMore = {};

  if (variant === 'outlined') {
    if (InputLabelProps && typeof InputLabelProps.shrink !== 'undefined') {
      InputMore.notched = InputLabelProps.shrink;
    }

    if (label) {
      var _InputLabelProps$requ;

      const displayRequired = (_InputLabelProps$requ = InputLabelProps == null ? void 0 : InputLabelProps.required) != null ? _InputLabelProps$requ : required;
      InputMore.label = /*#__PURE__*/jsxRuntime.exports.jsxs(react.exports.Fragment, {
        children: [label, displayRequired && '\u00a0*']
      });
    }
  }

  if (select) {
    // unset defaults from textbox inputs
    if (!SelectProps || !SelectProps.native) {
      InputMore.id = undefined;
    }

    InputMore['aria-describedby'] = undefined;
  }

  const helperTextId = helperText && id ? `${id}-helper-text` : undefined;
  const inputLabelId = label && id ? `${id}-label` : undefined;
  const InputComponent = variantComponent[variant];

  const InputElement = /*#__PURE__*/jsxRuntime.exports.jsx(InputComponent, _extends$4({
    "aria-describedby": helperTextId,
    autoComplete: autoComplete,
    autoFocus: autoFocus,
    defaultValue: defaultValue,
    fullWidth: fullWidth,
    multiline: multiline,
    name: name,
    rows: rows,
    maxRows: maxRows,
    minRows: minRows,
    type: type,
    value: value,
    id: id,
    inputRef: inputRef,
    onBlur: onBlur,
    onChange: onChange,
    onFocus: onFocus,
    placeholder: placeholder,
    inputProps: inputProps
  }, InputMore, InputProps));

  return /*#__PURE__*/jsxRuntime.exports.jsxs(TextFieldRoot, _extends$4({
    className: clsx(classes.root, className),
    disabled: disabled,
    error: error,
    fullWidth: fullWidth,
    ref: ref,
    required: required,
    color: color,
    variant: variant,
    ownerState: ownerState
  }, other, {
    children: [label && /*#__PURE__*/jsxRuntime.exports.jsx(InputLabel$1, _extends$4({
      htmlFor: id,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), select ? /*#__PURE__*/jsxRuntime.exports.jsx(Select$1, _extends$4({
      "aria-describedby": helperTextId,
      id: id,
      labelId: inputLabelId,
      value: value,
      input: InputElement
    }, SelectProps, {
      children: children
    })) : InputElement, helperText && /*#__PURE__*/jsxRuntime.exports.jsx(FormHelperText, _extends$4({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});
var TextField$1 = TextField;

var ManageAccounts = createSvgIcon([/*#__PURE__*/jsxRuntime.exports.jsx("circle", {
  cx: "10",
  cy: "8",
  r: "4"
}, "0"), /*#__PURE__*/jsxRuntime.exports.jsx("path", {
  d: "M10.67 13.02c-.22-.01-.44-.02-.67-.02-2.42 0-4.68.67-6.61 1.82-.88.52-1.39 1.5-1.39 2.53V20h9.26c-.79-1.13-1.26-2.51-1.26-4 0-1.07.25-2.07.67-2.98zM20.75 16c0-.22-.03-.42-.06-.63l1.14-1.01-1-1.73-1.45.49c-.32-.27-.68-.48-1.08-.63L18 11h-2l-.3 1.49c-.4.15-.76.36-1.08.63l-1.45-.49-1 1.73 1.14 1.01c-.03.21-.06.41-.06.63s.03.42.06.63l-1.14 1.01 1 1.73 1.45-.49c.32.27.68.48 1.08.63L16 21h2l.3-1.49c.4-.15.76-.36 1.08-.63l1.45.49 1-1.73-1.14-1.01c.03-.21.06-.41.06-.63zM17 18c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"
}, "1")], 'ManageAccounts');

var TuneRounded = createSvgIcon( /*#__PURE__*/jsxRuntime.exports.jsx("path", {
  d: "M3 18c0 .55.45 1 1 1h5v-2H4c-.55 0-1 .45-1 1zM3 6c0 .55.45 1 1 1h9V5H4c-.55 0-1 .45-1 1zm10 14v-1h7c.55 0 1-.45 1-1s-.45-1-1-1h-7v-1c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1s1-.45 1-1zM7 10v1H4c-.55 0-1 .45-1 1s.45 1 1 1h3v1c0 .55.45 1 1 1s1-.45 1-1v-4c0-.55-.45-1-1-1s-1 .45-1 1zm14 2c0-.55-.45-1-1-1h-9v2h9c.55 0 1-.45 1-1zm-5-3c.55 0 1-.45 1-1V7h3c.55 0 1-.45 1-1s-.45-1-1-1h-3V4c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1z"
}), 'TuneRounded');

function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
function create(type) {
  return new ArraySchema(type);
}
class ArraySchema extends BaseSchema {
  constructor(type) {
    super({
      type: 'array'
    }); // `undefined` specifically means uninitialized, as opposed to
    // "no subtype"

    this.innerType = type;
    this.withMutation(() => {
      this.transform(function (values) {
        if (typeof values === 'string') try {
          values = JSON.parse(values);
        } catch (err) {
          values = null;
        }
        return this.isType(values) ? values : null;
      });
    });
  }

  _typeCheck(v) {
    return Array.isArray(v);
  }

  get _subType() {
    return this.innerType;
  }

  _cast(_value, _opts) {
    const value = super._cast(_value, _opts); //should ignore nulls here


    if (!this._typeCheck(value) || !this.innerType) return value;
    let isChanged = false;
    const castArray = value.map((v, idx) => {
      const castElement = this.innerType.cast(v, _extends$3({}, _opts, {
        path: `${_opts.path || ''}[${idx}]`
      }));

      if (castElement !== v) {
        isChanged = true;
      }

      return castElement;
    });
    return isChanged ? castArray : value;
  }

  _validate(_value, options = {}, callback) {
    var _options$abortEarly, _options$recursive;

    let errors = [];
    let sync = options.sync;
    let path = options.path;
    let innerType = this.innerType;
    let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    let originalValue = options.originalValue != null ? options.originalValue : _value;

    super._validate(_value, options, (err, value) => {
      if (err) {
        if (!ValidationError.isError(err) || endEarly) {
          return void callback(err, value);
        }

        errors.push(err);
      }

      if (!recursive || !innerType || !this._typeCheck(value)) {
        callback(errors[0] || null, value);
        return;
      }

      originalValue = originalValue || value; // #950 Ensure that sparse array empty slots are validated

      let tests = new Array(value.length);

      for (let idx = 0; idx < value.length; idx++) {
        let item = value[idx];
        let path = `${options.path || ''}[${idx}]`; // object._validate note for isStrict explanation

        let innerOptions = _extends$3({}, options, {
          path,
          strict: true,
          parent: value,
          index: idx,
          originalValue: originalValue[idx]
        });

        tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
      }

      runTests({
        sync,
        path,
        value,
        errors,
        endEarly,
        tests
      }, callback);
    });
  }

  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }

  concat(schema) {
    let next = super.concat(schema);
    next.innerType = this.innerType;
    if (schema.innerType) next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat()
    next.innerType.concat(schema.innerType) : schema.innerType;
    return next;
  }

  of(schema) {
    // FIXME: this should return a new instance of array without the default to be
    let next = this.clone();
    if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema)); // FIXME(ts):

    next.innerType = schema;
    return next;
  }

  length(length, message = array.length) {
    return this.test({
      message,
      name: 'length',
      exclusive: true,
      params: {
        length
      },

      test(value) {
        return isAbsent(value) || value.length === this.resolve(length);
      }

    });
  }

  min(min, message) {
    message = message || array.min;
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },

      // FIXME(ts): Array<typeof T>
      test(value) {
        return isAbsent(value) || value.length >= this.resolve(min);
      }

    });
  }

  max(max, message) {
    message = message || array.max;
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        max
      },

      test(value) {
        return isAbsent(value) || value.length <= this.resolve(max);
      }

    });
  }

  ensure() {
    return this.default(() => []).transform((val, original) => {
      // We don't want to return `null` for nullable schema
      if (this._typeCheck(val)) return val;
      return original == null ? [] : [].concat(original);
    });
  }

  compact(rejector) {
    let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);
    return this.transform(values => values != null ? values.filter(reject) : values);
  }

  describe() {
    let base = super.describe();
    if (this.innerType) base.innerType = this.innerType.describe();
    return base;
  }

  nullable(isNullable = true) {
    return super.nullable(isNullable);
  }

  defined() {
    return super.defined();
  }

  required(msg) {
    return super.required(msg);
  }

}
create.prototype = ArraySchema.prototype; //
// Interfaces
//

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$2(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var isUnknownObject = function isUnknownObject(raw) {
  return raw !== null && _typeof$1(raw) === 'object';
};
var isPromise = function isPromise(raw) {
  return isUnknownObject(raw) && typeof raw.then === 'function';
}; // We are using types to enforce the `stripe` prop in this lib,
// but in an untyped integration `stripe` could be anything, so we need
// to do some sanity validation to prevent type errors.

var isStripe = function isStripe(raw) {
  return isUnknownObject(raw) && typeof raw.elements === 'function' && typeof raw.createToken === 'function' && typeof raw.createPaymentMethod === 'function' && typeof raw.confirmCardPayment === 'function';
};

var PLAIN_OBJECT_STR = '[object Object]';
var isEqual = function isEqual(left, right) {
  if (!isUnknownObject(left) || !isUnknownObject(right)) {
    return left === right;
  }

  var leftArray = Array.isArray(left);
  var rightArray = Array.isArray(right);
  if (leftArray !== rightArray) return false;
  var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;
  var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;
  if (leftPlainObject !== rightPlainObject) return false;
  if (!leftPlainObject && !leftArray) return false;
  var leftKeys = Object.keys(left);
  var rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) return false;
  var keySet = {};

  for (var i = 0; i < leftKeys.length; i += 1) {
    keySet[leftKeys[i]] = true;
  }

  for (var _i = 0; _i < rightKeys.length; _i += 1) {
    keySet[rightKeys[_i]] = true;
  }

  var allKeys = Object.keys(keySet);

  if (allKeys.length !== leftKeys.length) {
    return false;
  }

  var l = left;
  var r = right;

  var pred = function pred(key) {
    return isEqual(l[key], r[key]);
  };

  return allKeys.every(pred);
};

var usePrevious = function usePrevious(value) {
  var ref = React.useRef(value);
  React.useEffect(function () {
    ref.current = value;
  }, [value]);
  return ref.current;
};

var INVALID_STRIPE_ERROR = 'Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.'; // We are using types to enforce the `stripe` prop in this lib, but in a real
// integration `stripe` could be anything, so we need to do some sanity
// validation to prevent type errors.

var validateStripe = function validateStripe(maybeStripe) {
  if (maybeStripe === null || isStripe(maybeStripe)) {
    return maybeStripe;
  }

  throw new Error(INVALID_STRIPE_ERROR);
};

var parseStripeProp = function parseStripeProp(raw) {
  if (isPromise(raw)) {
    return {
      tag: 'async',
      stripePromise: Promise.resolve(raw).then(validateStripe)
    };
  }

  var stripe = validateStripe(raw);

  if (stripe === null) {
    return {
      tag: 'empty'
    };
  }

  return {
    tag: 'sync',
    stripe: stripe
  };
};

var ElementsContext = /*#__PURE__*/React.createContext(null);
ElementsContext.displayName = 'ElementsContext';
var parseElementsContext = function parseElementsContext(ctx, useCase) {
  if (!ctx) {
    throw new Error("Could not find Elements context; You need to wrap the part of your app that ".concat(useCase, " in an <Elements> provider."));
  }

  return ctx;
};
/**
 * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.
 * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.
 *
 * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.
 * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.
 * Pass the returned `Promise` to `Elements`.
 *
 * @docs https://stripe.com/docs/stripe-js/react#elements-provider
 */

var Elements = function Elements(_ref) {
  var rawStripeProp = _ref.stripe,
      options = _ref.options,
      children = _ref.children;

  var _final = React.useRef(false);

  var isMounted = React.useRef(true);
  var parsed = React.useMemo(function () {
    return parseStripeProp(rawStripeProp);
  }, [rawStripeProp]);

  var _React$useState = React.useState(function () {
    return {
      stripe: null,
      elements: null
    };
  }),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      ctx = _React$useState2[0],
      setContext = _React$useState2[1];

  var prevStripe = usePrevious(rawStripeProp);
  var prevOptions = usePrevious(options);

  if (prevStripe !== null) {
    if (prevStripe !== rawStripeProp) {
      console.warn('Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.');
    }

    if (!isEqual(options, prevOptions)) {
      console.warn('Unsupported prop change on Elements: You cannot change the `options` prop after setting the `stripe` prop.');
    }
  }

  if (!_final.current) {
    if (parsed.tag === 'sync') {
      _final.current = true;
      setContext({
        stripe: parsed.stripe,
        elements: parsed.stripe.elements(options)
      });
    }

    if (parsed.tag === 'async') {
      _final.current = true;
      parsed.stripePromise.then(function (stripe) {
        if (stripe && isMounted.current) {
          // Only update Elements context if the component is still mounted
          // and stripe is not null. We allow stripe to be null to make
          // handling SSR easier.
          setContext({
            stripe: stripe,
            elements: stripe.elements(options)
          });
        }
      });
    }
  }

  React.useEffect(function () {
    return function () {
      isMounted.current = false;
    };
  }, []);
  React.useEffect(function () {
    var anyStripe = ctx.stripe;

    if (!anyStripe || !anyStripe._registerWrapper || !anyStripe.registerAppInfo) {
      return;
    }

    anyStripe._registerWrapper({
      name: 'react-stripe-js',
      version: "1.4.1"
    });

    anyStripe.registerAppInfo({
      name: 'react-stripe-js',
      version: "1.4.1",
      url: 'https://stripe.com/docs/stripe-js/react'
    });
  }, [ctx.stripe]);
  return /*#__PURE__*/React.createElement(ElementsContext.Provider, {
    value: ctx
  }, children);
};
Elements.propTypes = {
  stripe: PropTypes.any,
  options: PropTypes.object
};
var useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {
  var ctx = React.useContext(ElementsContext);
  return parseElementsContext(ctx, useCaseMessage);
};
/**
 * @docs https://stripe.com/docs/stripe-js/react#useelements-hook
 */

var useElements = function useElements() {
  var _useElementsContextWi = useElementsContextWithUseCase('calls useElements()'),
      elements = _useElementsContextWi.elements;

  return elements;
};
/**
 * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook
 */

var useStripe = function useStripe() {
  var _useElementsContextWi2 = useElementsContextWithUseCase('calls useStripe()'),
      stripe = _useElementsContextWi2.stripe;

  return stripe;
};
/**
 * @docs https://stripe.com/docs/stripe-js/react#elements-consumer
 */

var ElementsConsumer = function ElementsConsumer(_ref2) {
  var children = _ref2.children;
  var ctx = useElementsContextWithUseCase('mounts <ElementsConsumer>'); // Assert to satisfy the busted React.FC return type (it should be ReactNode)

  return children(ctx);
};
ElementsConsumer.propTypes = {
  children: PropTypes.func.isRequired
};

var useCallbackReference = function useCallbackReference(cb) {
  var ref = React.useRef(cb);
  React.useEffect(function () {
    ref.current = cb;
  }, [cb]);
  return function () {
    if (ref.current) {
      ref.current.apply(ref, arguments);
    }
  };
};

var extractUpdateableOptions = function extractUpdateableOptions(options) {
  if (!isUnknownObject(options)) {
    return {};
  }

  options.paymentRequest;
      var rest = _objectWithoutProperties(options, ["paymentRequest"]);

  return rest;
};

var noop$1 = function noop() {};

var capitalized = function capitalized(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

var createElementComponent = function createElementComponent(type, isServer) {
  var displayName = "".concat(capitalized(type), "Element");

  var ClientElement = function ClientElement(_ref) {
    var id = _ref.id,
        className = _ref.className,
        _ref$options = _ref.options,
        options = _ref$options === void 0 ? {} : _ref$options,
        _ref$onBlur = _ref.onBlur,
        onBlur = _ref$onBlur === void 0 ? noop$1 : _ref$onBlur,
        _ref$onFocus = _ref.onFocus,
        onFocus = _ref$onFocus === void 0 ? noop$1 : _ref$onFocus,
        _ref$onReady = _ref.onReady,
        onReady = _ref$onReady === void 0 ? noop$1 : _ref$onReady,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? noop$1 : _ref$onChange,
        _ref$onEscape = _ref.onEscape,
        onEscape = _ref$onEscape === void 0 ? noop$1 : _ref$onEscape,
        _ref$onClick = _ref.onClick,
        onClick = _ref$onClick === void 0 ? noop$1 : _ref$onClick;

    var _useElementsContextWi = useElementsContextWithUseCase("mounts <".concat(displayName, ">")),
        elements = _useElementsContextWi.elements;

    var elementRef = React.useRef(null);
    var domNode = React.useRef(null);
    var callOnReady = useCallbackReference(onReady);
    var callOnBlur = useCallbackReference(onBlur);
    var callOnFocus = useCallbackReference(onFocus);
    var callOnClick = useCallbackReference(onClick);
    var callOnChange = useCallbackReference(onChange);
    var callOnEscape = useCallbackReference(onEscape);
    React.useLayoutEffect(function () {
      if (elementRef.current == null && elements && domNode.current != null) {
        var element = elements.create(type, options);
        elementRef.current = element;
        element.mount(domNode.current);
        element.on('ready', function () {
          return callOnReady(element);
        });
        element.on('change', callOnChange);
        element.on('blur', callOnBlur);
        element.on('focus', callOnFocus);
        element.on('escape', callOnEscape); // Users can pass an an onClick prop on any Element component
        // just as they could listen for the `click` event on any Element,
        // but only the PaymentRequestButton will actually trigger the event.

        element.on('click', callOnClick);
      }
    });
    var prevOptions = React.useRef(options);
    React.useEffect(function () {
      if (prevOptions.current && prevOptions.current.paymentRequest !== options.paymentRequest) {
        console.warn('Unsupported prop change: options.paymentRequest is not a customizable property.');
      }

      var updateableOptions = extractUpdateableOptions(options);

      if (Object.keys(updateableOptions).length !== 0 && !isEqual(updateableOptions, extractUpdateableOptions(prevOptions.current))) {
        if (elementRef.current) {
          elementRef.current.update(updateableOptions);
          prevOptions.current = options;
        }
      }
    }, [options]);
    React.useLayoutEffect(function () {
      return function () {
        if (elementRef.current) {
          elementRef.current.destroy();
        }
      };
    }, []);
    return /*#__PURE__*/React.createElement("div", {
      id: id,
      className: className,
      ref: domNode
    });
  }; // Only render the Element wrapper in a server environment.


  var ServerElement = function ServerElement(props) {
    // Validate that we are in the right context by calling useElementsContextWithUseCase.
    useElementsContextWithUseCase("mounts <".concat(displayName, ">"));
    var id = props.id,
        className = props.className;
    return /*#__PURE__*/React.createElement("div", {
      id: id,
      className: className
    });
  };

  var Element = isServer ? ServerElement : ClientElement;
  Element.propTypes = {
    id: PropTypes.string,
    className: PropTypes.string,
    onChange: PropTypes.func,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func,
    onReady: PropTypes.func,
    onClick: PropTypes.func,
    options: PropTypes.object
  };
  Element.displayName = displayName;
  Element.__elementType = type;
  return Element;
};

var isServer = typeof window === 'undefined';
/**
 * Requires beta access:
 * Contact [Stripe support](https://support.stripe.com/) for more information.
 *
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('auBankAccount', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('card', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

var CardNumberElement = createElementComponent('cardNumber', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

var CardExpiryElement = createElementComponent('cardExpiry', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

var CardCvcElement = createElementComponent('cardCvc', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('fpxBank', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('iban', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('idealBank', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('p24Bank', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('epsBank', isServer);
createElementComponent('payment', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('paymentRequestButton', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */

createElementComponent('afterpayClearpayMessage', isServer);

var pure$1 = {};

Object.defineProperty(pure$1, '__esModule', { value: true });

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var V3_URL = 'https://js.stripe.com/v3';
var V3_URL_REGEX = /^https:\/\/js\.stripe\.com\/v3\/?(\?.*)?$/;
var EXISTING_SCRIPT_MESSAGE = 'loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used';
var findScript = function findScript() {
  var scripts = document.querySelectorAll("script[src^=\"".concat(V3_URL, "\"]"));

  for (var i = 0; i < scripts.length; i++) {
    var script = scripts[i];

    if (!V3_URL_REGEX.test(script.src)) {
      continue;
    }

    return script;
  }

  return null;
};

var injectScript = function injectScript(params) {
  var queryString = params && !params.advancedFraudSignals ? '?advancedFraudSignals=false' : '';
  var script = document.createElement('script');
  script.src = "".concat(V3_URL).concat(queryString);
  var headOrBody = document.head || document.body;

  if (!headOrBody) {
    throw new Error('Expected document.body not to be null. Stripe.js requires a <body> element.');
  }

  headOrBody.appendChild(script);
  return script;
};

var registerWrapper = function registerWrapper(stripe, startTime) {
  if (!stripe || !stripe._registerWrapper) {
    return;
  }

  stripe._registerWrapper({
    name: 'stripe-js',
    version: "1.15.1",
    startTime: startTime
  });
};

var stripePromise = null;
var loadScript = function loadScript(params) {
  // Ensure that we only attempt to load Stripe.js at most once
  if (stripePromise !== null) {
    return stripePromise;
  }

  stripePromise = new Promise(function (resolve, reject) {
    if (typeof window === 'undefined') {
      // Resolve to null when imported server side. This makes the module
      // safe to import in an isomorphic code base.
      resolve(null);
      return;
    }

    if (window.Stripe && params) {
      console.warn(EXISTING_SCRIPT_MESSAGE);
    }

    if (window.Stripe) {
      resolve(window.Stripe);
      return;
    }

    try {
      var script = findScript();

      if (script && params) {
        console.warn(EXISTING_SCRIPT_MESSAGE);
      } else if (!script) {
        script = injectScript(params);
      }

      script.addEventListener('load', function () {
        if (window.Stripe) {
          resolve(window.Stripe);
        } else {
          reject(new Error('Stripe.js not available'));
        }
      });
      script.addEventListener('error', function () {
        reject(new Error('Failed to load Stripe.js'));
      });
    } catch (error) {
      reject(error);
      return;
    }
  });
  return stripePromise;
};
var initStripe = function initStripe(maybeStripe, args, startTime) {
  if (maybeStripe === null) {
    return null;
  }

  var stripe = maybeStripe.apply(undefined, args);
  registerWrapper(stripe, startTime);
  return stripe;
};
var validateLoadParams = function validateLoadParams(params) {
  var errorMessage = "invalid load parameters; expected object of shape\n\n    {advancedFraudSignals: boolean}\n\nbut received\n\n    ".concat(JSON.stringify(params), "\n");

  if (params === null || _typeof(params) !== 'object') {
    throw new Error(errorMessage);
  }

  if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === 'boolean') {
    return params;
  }

  throw new Error(errorMessage);
};

var loadParams;
var loadStripeCalled = false;
var loadStripe = function loadStripe() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  loadStripeCalled = true;
  var startTime = Date.now();
  return loadScript(loadParams).then(function (maybeStripe) {
    return initStripe(maybeStripe, args, startTime);
  });
};

loadStripe.setLoadParameters = function (params) {
  if (loadStripeCalled) {
    throw new Error('You cannot change load parameters after calling loadStripe');
  }

  loadParams = validateLoadParams(params);
};

pure$1.loadStripe = loadStripe;

var pure = pure$1;

const DrawerContext = react.exports.createContext({ opened: false, close: () => { }, open: () => { } });
const TableSearchContext = react.exports.createContext({
    searching: false,
    searchQuery: '',
    //TODO: not implemented
    onSearch: () => undefined,
    setSearching: () => null,
});

const useT = (root) => {
    const { t } = useTranslation();
    return react.exports.useCallback((key, options, defaultValue) => {
        return t(`adminPortal.${root}.${key}`, options, defaultValue);
    }, [t]);
};
// export const useGlobalT = <T extends keyof Localization>(): UseTFunc<any> => {
const useGlobalT = () => {
    const { t } = useTranslation();
    return react.exports.useCallback((key, options, defaultValue) => {
        return t(key, options, defaultValue);
    }, [t]);
};
const useTableSearch = () => {
    const context = react.exports.useContext(TableSearchContext);
    return Object.assign(Object.assign({}, context), { onSearch: (str) => __awaiter(void 0, void 0, void 0, function* () {
            const searchQuery = str !== null && str !== void 0 ? str : '';
            context.setSearching(!!searchQuery);
            context.onSearch(searchQuery);
        }) });
};
const useMuiMediaQuery = (themeBreakpoints) => {
    const { iframeRendering, rootEl } = useShadowDom();
    const iframeWindowObj = iframeRendering && rootEl.ownerDocument ? rootEl.ownerDocument.defaultView : null;
    const mediaQueryOptions = iframeWindowObj ? { matchMedia: iframeWindowObj === null || iframeWindowObj === void 0 ? void 0 : iframeWindowObj.matchMedia } : undefined;
    return useMediaQuery(themeBreakpoints, mediaQueryOptions);
};

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Listener to provide Shadow DOM focus events, even inside shadow roots
 *
 * Normally, listening for focus with Shadow DOM will just return the top-most 'host' with a shadow
 * root. That may not be a problem! But if you want to find the 'real' focused element...
 *
 * To use this library, add this after the script is included-
 *   document.addEventListener('focus', shadowFocusHandler, true);
 *
 * You can then listen for `-shadow-focus` events, which will return the furthest focused element-
 *   document.addEventListener('-shadow-focus', function(ev) {
 *     console.info('got focused element', ev.detail, '..inside outer-most shadow root', ev.target);
 *   });
 */
const shadowFocusHandler = (function () {
    if (typeof window === 'undefined') {
        return (event) => dispatch(event.target);
    }
    const eventName = '-shadow-focus';
    const dispatch = function (target) {
        const args = { composed: true, bubbles: true, detail: target };
        const customEvent = new CustomEvent(eventName, args);
        target.dispatchEvent(customEvent);
    };
    if (!window.WeakSet || !window.ShadowRoot) {
        return (event) => dispatch(event.target);
    }
    const focusHandlerSet = new WeakSet();
    /**
     * @param {Node} target to work on
     * @param {function(!FocusEvent)} callback to invoke on focus change
     */
    function _internal(target, callback) {
        let currentFocus = target; // save real focus
        // #1: get the nearest ShadowRoot
        while (!(target instanceof ShadowRoot)) {
            if (!target) {
                return;
            }
            target = target.parentNode;
        }
        // #2: are we already handling it?
        if (focusHandlerSet.has(target)) {
            return;
        }
        focusHandlerSet.add(target);
        // #3: setup focus/blur handlers
        const hostEl = target.host;
        const focusinHandler = function (ev) {
            if (ev.target !== currentFocus) { // prevent dup calls for same focus
                currentFocus = ev.target;
                callback(ev);
            }
        };
        const blurHandler = function (ev) {
            hostEl.removeEventListener('blur', blurHandler, false);
            target.removeEventListener('focusin', focusinHandler, true);
            focusHandlerSet.delete(target);
        };
        // #3: add blur handler to host element
        hostEl.addEventListener('blur', blurHandler, false);
        // #4: add focus handler within shadow root, to observe changes
        target.addEventListener('focusin', focusinHandler, true);
        // #5: find next parent SR, do it again
        _internal(target.host, callback);
    }
    /**
     * @param {!FocusEvent} event to process
     */
    function shadowFocusHandler(event) {
        const target = (event.composedPath ? event.composedPath()[0] : null) || event.target;
        _internal(target, shadowFocusHandler);
        dispatch(target);
    }
    return shadowFocusHandler;
}());

function toCurrencySymbol(currency) {
    switch (currency) {
        case 'nis':
            return '₪';
        case 'usd':
        default:
            return '$';
    }
}
function toPriceDisplay(price = 0) {
    return `${(price / 100).toFixed(2)}`;
}

const TextBreakLine = ({ text }) => {
    return (React.createElement(React.Fragment, null, text
        .split('\\n')
        .map((str) => React.createElement(React.Fragment, null, str))
        .reduce((prevList, curr) => {
        if (prevList.length === 0) {
            return [curr];
        }
        return prevList.concat(React.createElement("br", null), curr);
    }, [])));
};

const SubscriptionDialogFooter = ({ cancel, confirm }) => {
    var _a, _b;
    const t = useT('subscriptions');
    return (React.createElement(Grid, { container: true, justifyContent: 'flex-end' },
        cancel && (React.createElement(Button$1, { type: 'button', "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', onClick: cancel.onClick, disabled: cancel.disabled }, t('cancel'))),
        confirm && (React.createElement(Button$1, { "data-test-id": "confirmBtn", type: (_a = confirm.type) !== null && _a !== void 0 ? _a : 'button', color: (_b = confirm.color) !== null && _b !== void 0 ? _b : 'primary', onClick: confirm.onClick, disabled: confirm.disabled, loading: confirm.loading }, t(confirm.text)))));
};

const SubscriptionFormContext = React.createContext({
    valid: false,
    setValid: (value) => { },
    registerSubmit: (cb) => { },
    unregisterSubmit: () => { },
    onSubmit: () => { },
});
const useSubscriptionFormContext = () => react.exports.useContext(SubscriptionFormContext);
const SubscriptionFormContextProvider = ({ children }) => {
    const [{ onSubmit }, setState] = react.exports.useState({
        onSubmit: () => { },
    });
    const [valid, setValid] = react.exports.useState(false);
    return (React.createElement(SubscriptionFormContext.Provider, { value: react.exports.useMemo(() => ({
            valid,
            onSubmit,
            setValid,
            registerSubmit: (callback) => setState({ onSubmit: callback }),
            unregisterSubmit: () => setState({ onSubmit: () => { } }),
        }), [valid, onSubmit]) }, children));
};

const CheckoutDialogFooter = ({ shouldCreatePaymentMethod, onCancel, planId, }) => {
    const { loading } = useCheckout();
    const { paymentMethod } = usePaymentMethod();
    const { valid, onSubmit } = useSubscriptionFormContext();
    const { confirmCheckout } = useCheckoutActions();
    const handleConfirmCheckout = react.exports.useCallback(() => {
        confirmCheckout({ paymentMethodId: paymentMethod.id, planId });
    }, [planId, paymentMethod, confirmCheckout]);
    return shouldCreatePaymentMethod ? (React.createElement(SubscriptionDialogFooter, { cancel: { onClick: onCancel, disabled: loading }, confirm: { onClick: onSubmit, disabled: !valid, loading, text: 'confirm' } })) : (React.createElement(SubscriptionDialogFooter, { cancel: { onClick: onCancel, disabled: loading }, confirm: { onClick: handleConfirmCheckout, loading, text: 'confirm' } }));
};

const CheckoutDialogError = () => {
    const { error } = useCheckout();
    if (!error) {
        return null;
    }
    return (React.createElement(Grid, { p: 4 },
        React.createElement(Alert$1, { "data-test-id": error, severity: 'error' }, error)));
};

const SectionTitle = styled(Box)(({ theme }) => ({
    color: theme.palette.grey[700],
    fontSize: theme.typography.pxToRem(12),
    lineHeight: theme.typography.pxToRem(16),
    padding: theme.spacing(4),
}));
const DialogSectionBox = ({ children, title }) => {
    return (React.createElement(Grid, { mb: 4 },
        React.createElement(SectionTitle, null, title),
        React.createElement(Divider, null),
        children));
};

const PlanTitle$1 = styled(Box)(({ theme }) => ({
    color: theme.palette.grey[800],
    fontWeight: 800,
    fontSize: theme.typography.pxToRem(16),
    lineHeight: theme.typography.pxToRem(24),
    marginBottom: theme.spacing(3),
}));
const PlanSubtitle = styled(Box)(({ theme }) => ({
    color: theme.palette.grey[700],
    fontWeight: 600,
    fontSize: theme.typography.pxToRem(12),
    lineHeight: theme.typography.pxToRem(16),
}));
const PlanPrice$1 = styled(Box)(({ theme }) => ({
    color: theme.palette.grey[800],
    fontWeight: 800,
    fontSize: theme.typography.pxToRem(20),
    lineHeight: theme.typography.pxToRem(24),
    marginBottom: theme.spacing(3),
    textAlign: 'end',
}));
const PlanPriceInterval = styled(Box)(({ theme }) => ({
    color: theme.palette.grey[700],
    fontWeight: 600,
    fontSize: theme.typography.pxToRem(12),
    lineHeight: theme.typography.pxToRem(16),
    textAlign: 'end',
}));
const CheckoutSubscriptionPlanDetails = ({ title, subTitle, price, planInterval, }) => {
    const t = useT('subscriptions_Checkout');
    return (React.createElement(DialogSectionBox, { title: t('selectedPlan') },
        React.createElement(Grid, { container: true, p: 4, mt: 4, justifyContent: 'space-between' },
            React.createElement(Grid, { item: true },
                React.createElement(PlanTitle$1, null, title),
                React.createElement(PlanSubtitle, null,
                    React.createElement(TextBreakLine, { text: subTitle }))),
            React.createElement(Grid, { item: true, display: 'none' },
                React.createElement(PlanPrice$1, null, `${price}`),
                React.createElement(PlanPriceInterval, null, planInterval === 'month' ? 'per each month' : 'per each month')))));
};

const CheckoutDialogDetails = ({ planId }) => {
    const t = useT('subscriptions_Billing');
    const { plans } = usePlans();
    const plan = react.exports.useMemo(() => plans.find((item) => item.id === planId), [plans, planId]);
    if (!plan) {
        return null;
    }
    const price = `${toCurrencySymbol(plan.currency)}${toPriceDisplay(plan.price)}`;
    return (React.createElement(CheckoutSubscriptionPlanDetails, { title: plan.name, subTitle: plan.description || `${price} • ${t('monthly')}`, price: price, planInterval: t('intervalTitle', { interval: t('intervalMonth') }) }));
};

const StripeElementProvider = ({ stripeKey, children }) => {
    const loadStripePromise = react.exports.useMemo(() => pure.loadStripe(stripeKey), [stripeKey]);
    return (React.createElement(Elements, { stripe: loadStripePromise },
        React.createElement(ElementsConsumer, null, ({ stripe, elements }) => {
            if (!stripe || !elements) {
                return React.createElement(Loader$1, null);
            }
            return children;
        })));
};

const StripeFormLabel = styled(FormLabel$1) `
  color: ${UI.palette('grey.800')};
  font-size: ${({ theme }) => theme.typography.pxToRem(14)};
  line-height: ${({ theme }) => theme.typography.pxToRem(16)};
  font-weight: 600;
  margin-bottom: ${UI.spacing(2)};
`;
const StripeTextField = styled(TextField$1) `
  width: 100%;
`;
const StripeInputWrapper = styled('div')(({ theme }) => ({
    color: theme.palette.grey[800],
    border: `1px solid ${theme.palette.grey[400]}`,
    boxShadow: `inset 0px 1px 0px ${theme.palette.grey[200]}`,
    borderRadius: theme.spacing(1),
}));
const classes = {
    base: 'stripe-input-class-base',
    focus: 'stripe-input-class-focused',
    empty: 'stripe-input-class-empty',
    invalid: 'stripe-input-class-invalid',
};
const StripeForm = ({ disabled, cardHolderNameFieldRef, onValidChange }) => {
    const t = useT('subscriptions_Checkout');
    const theme = useTheme();
    const [validation, setValidation] = react.exports.useState({
        cardHolderName: false,
        cardNumber: false,
        cardExpiryDate: false,
        cardCvc: false,
    });
    const isFormValid = Object.values(validation).every((item) => item);
    react.exports.useEffect(() => {
        onValidChange(isFormValid);
    }, [onValidChange, isFormValid]);
    const setValidationField = (key, value) => {
        setValidation((prevState) => (Object.assign(Object.assign({}, prevState), { [key]: value })));
    };
    return (React.createElement(React.Fragment, null,
        React.createElement(RenderAsSlot, { name: 'StripeStyle' },
            React.createElement("style", null, `
            .${classes.base} {
              height: unset;
              padding: ${theme.spacing(2.5)} ${theme.spacing(4)};
              font-weight: bold;
              font-size: ${theme.typography.body1.fontSize};
              font-family: ${theme.typography.body1.fontFamily};
              line-height: ${theme.typography.body1.lineHeight}
              color: ${theme.palette.grey[800]};
              box-shadow: inset 0px 1px 0px ${theme.palette.grey[100]};
            }
            .${classes.base}:hover {
              box-shadow: none;
              outline-color:  #889DB8;
              outline-style: solid;
              outline-width: 2px;
              outline-offset: 0px;
            }
            .${classes.empty} {
              color: ${theme.palette.grey[100]} !important;
            }
            .${classes.empty} input::placeholder {
              color: ${theme.palette.grey[100]} !important;
            }
            .${classes.invalid} {
              color: ${theme.palette.error.main};
              border: 1px solid ${theme.palette.error.main};
            }
            .${classes.invalid}:hover {
              color: ${theme.palette.error.main};
              border-color: ${theme.palette.error.main};
              outline-color: ${theme.palette.error.main};
            }
        `)),
        React.createElement(Grid, { container: true, padding: 0, direction: 'column' },
            React.createElement(Grid, { item: true, mb: 4 },
                React.createElement(StripeFormLabel, { "data-test-id": "nameOnCardBox" }, t('nameOnCard')),
                React.createElement(StripeTextField, { "data-test-id": "NameOnCardBox", inputRef: cardHolderNameFieldRef, disabled: disabled, placeholder: 'Enter your name', name: 'cardHolderName', onChange: (event) => {
                        setValidationField('cardHolderName', !!event.currentTarget.value && event.currentTarget.value.length > 0);
                    } })),
            React.createElement(Grid, { item: true, mb: 4 },
                React.createElement(StripeFormLabel, null, t('cardNumber')),
                React.createElement(StripeInputWrapper, null,
                    React.createElement(RenderAsSlot, { name: 'CardNumberElement' },
                        React.createElement(CardNumberElement, { "data-test-id": "cardNumberBox", onChange: (event) => {
                                setValidationField('cardNumber', event.complete);
                            }, options: {
                                disabled,
                                placeholder: '0000 0000 0000 0000',
                                classes,
                            } })))),
            React.createElement(Grid, { item: true, container: true, mb: 4, spacing: 4 },
                React.createElement(Grid, { item: true, xs: 6 },
                    React.createElement(StripeFormLabel, null, t('expiryDate')),
                    React.createElement(StripeInputWrapper, null,
                        React.createElement(RenderAsSlot, { name: 'CardExpiryElement' },
                            React.createElement(CardExpiryElement, { "data-test-id": "cardExpiryBox", onChange: (event) => {
                                    setValidationField('cardExpiryDate', event.complete);
                                }, options: {
                                    classes,
                                    disabled,
                                    placeholder: 'MM / YY',
                                } })))),
                React.createElement(Grid, { item: true, xs: 6 },
                    React.createElement(StripeFormLabel, null, t('cvc')),
                    React.createElement(StripeInputWrapper, null,
                        React.createElement(RenderAsSlot, { name: 'CardCardCvc' },
                            React.createElement(CardCvcElement, { "data-test-id": "cardCvcBox", onChange: (event) => {
                                    setValidationField('cardCvc', event.complete);
                                }, options: {
                                    classes,
                                    disabled,
                                    placeholder: 'CVC Security Number',
                                } }))))))));
};

const BoxLoader = ({ height }) => {
    return (React.createElement(Grid, { height: height || 220, container: true, alignContent: 'center', justifyContent: 'center' },
        React.createElement(Loader$1, null)));
};

const StripePaymentMethodForm = (_a) => {
    var { mode, apiKey } = _a, rest = __rest(_a, ["mode", "apiKey"]);
    const { paymentMethod } = usePaymentMethod();
    const { cardSetupIntentSecret, error, loading } = useStripeState();
    const { createCardSetupIntentSecret } = useStripeActions();
    react.exports.useEffect(() => {
        if (mode === 'create') {
            createCardSetupIntentSecret(null);
        }
        else {
            createCardSetupIntentSecret((paymentMethod === null || paymentMethod === void 0 ? void 0 : paymentMethod.id) || null);
        }
    }, []);
    if (error) {
        // TODO
        return null;
    }
    if (loading || !cardSetupIntentSecret) {
        return React.createElement(BoxLoader, { height: 250 });
    }
    return (React.createElement(StripeElementProvider, { stripeKey: apiKey },
        React.createElement(PaymentMethodForm$1, Object.assign({ cardSetupIntentSecret: cardSetupIntentSecret }, rest))));
};
const PaymentMethodForm$1 = ({ cardSetupIntentSecret, disabled, onSubmit, onError, onSuccess, }) => {
    const t = useT('subscriptions_Billing');
    const stripe = useStripe();
    const elements = useElements();
    const { setValid, registerSubmit, unregisterSubmit } = useSubscriptionFormContext();
    const cardHolderNameFieldRef = react.exports.useRef(null);
    const handleSubmit = react.exports.useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        if (!stripe || !elements) {
            return;
        }
        const cardNumber = elements.getElement(CardNumberElement);
        const cardNameHolder = (_a = cardHolderNameFieldRef.current) === null || _a === void 0 ? void 0 : _a.value;
        if (!cardNameHolder || !cardNumber) {
            return;
        }
        onSubmit();
        try {
            const { error, setupIntent } = yield stripe.confirmCardSetup(cardSetupIntentSecret, {
                payment_method: {
                    card: cardNumber,
                    //TODO: add metadata
                    // metadata: {}
                    billing_details: {
                        name: cardNameHolder,
                    },
                },
            });
            if (error) {
                onError(t('confirmError', { error: error.message, code: error.code }));
                return;
            }
            if ((setupIntent === null || setupIntent === void 0 ? void 0 : setupIntent.status) === 'succeeded' && setupIntent.payment_method) {
                onSuccess(setupIntent.payment_method);
            }
            else {
                onError(t('invalidCardStatusError', { status: setupIntent === null || setupIntent === void 0 ? void 0 : setupIntent.status }));
            }
        }
        catch (e) {
            console.debug('Failed to process payment method', e);
            onError(t('confirmGenericError'));
        }
    }), [t, stripe, elements, onSubmit, cardSetupIntentSecret, onError, onSuccess]);
    const handleValidation = react.exports.useCallback((status) => {
        setValid(status);
    }, [setValid]);
    react.exports.useEffect(() => {
        registerSubmit(handleSubmit);
        return () => {
            unregisterSubmit();
        };
    }, [registerSubmit, unregisterSubmit, handleSubmit]);
    return react.exports.useMemo(() => (React.createElement(StripeForm, { cardHolderNameFieldRef: cardHolderNameFieldRef, disabled: disabled, onValidChange: handleValidation })), [cardHolderNameFieldRef, disabled, handleValidation]);
};

const PaymentMethodForm = ({ mode, disabled, onError, onSuccess, onSubmit }) => {
    const { config } = usePaymentProvider();
    if ((config === null || config === void 0 ? void 0 : config.paymentProvider) === PaymentProvider.STRIPE) {
        const { apiKey } = config;
        return (React.createElement(StripePaymentMethodForm, { mode: mode, disabled: disabled, apiKey: apiKey, onError: onError, onSuccess: onSuccess, onSubmit: onSubmit }));
    }
    else {
        // TODO error or cancel action
        return null;
    }
};

const cardBrandIcons = {
    visa: VisaCardIcon,
    amex: AmericanExpressIcon,
    mastercard: MasterCardIcon,
    diners: DinersCardIcon,
    unknown: GenericCardIcon
};

const UpdatePaymentMethod = styled(Grid)(({ theme, disabled }) => ({
    display: 'flex',
    alignItems: 'center',
    cursor: disabled ? 'default' : 'pointer',
    svg: {
        marginLeft: '24px',
        width: '0.75rem',
        height: '0.75rem',
        color: theme.palette.grey[500],
    },
}));
const CardInfo = styled(Grid) `
  display: flex;
  align-items: center;

  svg {
    width: 2.5rem;
    height: 1.5rem;
  }
`;
const PaymentMethodSelect = ({ disabled, onUpdate, brand, last4, expMonth, expYear, }) => {
    const t = useT('subscriptions');
    const BankIcon = react.exports.useMemo(() => cardBrandIcons[brand || 'unknown'], [brand]);
    const handleUpdate = react.exports.useCallback(() => {
        if (!disabled && onUpdate) {
            onUpdate();
        }
    }, [disabled, onUpdate]);
    return (React.createElement(Grid, { container: true, justifyContent: 'space-between', alignItems: 'center', alignContent: 'center', p: 0 },
        React.createElement(Grid, { item: true },
            React.createElement(CardInfo, { item: true },
                React.createElement(BankIcon, null),
                last4 && (React.createElement(Typography$1, { variant: 'label', ml: 4 },
                    "\u2022\u2022\u2022\u2022 ",
                    last4)))),
        React.createElement(Grid, { item: true, xs: true }, expMonth && expYear && (React.createElement(Typography$1, { variant: 'tableStandardCell', textAlign: 'center' },
            t('expires'),
            " ",
            expMonth,
            "/",
            expYear))),
        React.createElement(Grid, { item: true }, onUpdate && (React.createElement(UpdatePaymentMethod, { "data-test-id": 'updatePaymentMethodBtn', item: true, onClick: handleUpdate, disabled: disabled },
            React.createElement(Typography$1, { variant: 'body1' }, t('updatePaymentMethod')),
            " ",
            React.createElement(EditIcon, null))))));
};

const CheckoutDialogPaymentMethod = ({ shouldCreatePaymentMethod, handleForcePaymentMethodCreation, planId, }) => {
    const t = useT('subscriptions_Billing');
    const { loading } = useCheckout();
    const { paymentMethod } = usePaymentMethod();
    const { confirmCheckout, errorCheckout, submitCheckout } = useCheckoutActions();
    const handleError = react.exports.useCallback((error) => {
        errorCheckout(error);
    }, [errorCheckout]);
    const handleSubmit = react.exports.useCallback(() => {
        submitCheckout();
    }, [submitCheckout]);
    const handleConfirmPaymentMethod = react.exports.useCallback((newPaymentMethodId) => {
        confirmCheckout({ paymentMethodId: newPaymentMethodId, planId });
    }, [confirmCheckout, planId]);
    return (React.createElement(DialogSectionBox, { title: t('paymentMethod') },
        React.createElement(Grid, { pt: 8, pb: 2, p: 4 }, shouldCreatePaymentMethod ? (React.createElement(PaymentMethodForm, { disabled: loading, mode: paymentMethod ? 'update' : 'create', onError: handleError, onSubmit: handleSubmit, onSuccess: handleConfirmPaymentMethod })) : (React.createElement(PaymentMethodSelect, { disabled: loading, brand: paymentMethod.brand, last4: paymentMethod.last4, onUpdate: handleForcePaymentMethodCreation })))));
};

const CheckoutDialogBody = ({ planId, onClose, onSuccess, onError }) => {
    const { paymentMethod } = usePaymentMethod();
    const [forceNewPaymentMethod, setForcePaymentMethod] = react.exports.useState(!paymentMethod);
    const { confirmed, error } = useCheckout();
    const { loadCheckout, resetCheckout } = useCheckoutActions();
    react.exports.useEffect(() => {
        loadCheckout();
        return () => {
            resetCheckout();
        };
    }, [loadCheckout, resetCheckout]);
    react.exports.useEffect(() => {
        if (confirmed) {
            resetCheckout();
            onSuccess();
        }
    }, [confirmed, onSuccess, resetCheckout]);
    react.exports.useEffect(() => {
        if (error) {
            resetCheckout();
            onError(error);
        }
    }, [error, onError, resetCheckout]);
    const handleForcePaymentMethodCreation = react.exports.useCallback(() => {
        setForcePaymentMethod(true);
    }, [setForcePaymentMethod]);
    const handleClose = react.exports.useCallback(() => {
        resetCheckout();
        onClose();
    }, [resetCheckout, onClose]);
    return (React.createElement(SubscriptionFormContextProvider, null,
        React.createElement(Dialog$1.Body, { noPadding: true },
            React.createElement(CheckoutDialogError, null),
            React.createElement(CheckoutDialogDetails, { planId: planId }),
            React.createElement(CheckoutDialogPaymentMethod, { planId: planId, shouldCreatePaymentMethod: forceNewPaymentMethod, handleForcePaymentMethodCreation: handleForcePaymentMethodCreation })),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(CheckoutDialogFooter, { planId: planId, onCancel: handleClose, shouldCreatePaymentMethod: forceNewPaymentMethod }))));
};

const AuthWrapper = ({ children }) => {
    const { isLoading, isAuthenticated } = useAuth(({ isLoading, isAuthenticated, tenantsState: { loading, tenants } }) => ({
        isLoading: isLoading || (loading && tenants.length === 0),
        isAuthenticated,
    }));
    const { loading: loadingPolicy } = usePublicPolicySettings$1();
    const { injector, basename = '', urlStrategy } = useShadowDom();
    const routes = useAuthRoutes();
    react.exports.useEffect(() => {
        if (!isLoading && !isAuthenticated) {
            const calculatedBasename = basename.endsWith('/') ? basename.substring(0, basename.length - 1) : '';
            if (injector) {
                injector === null || injector === void 0 ? void 0 : injector.hideCheckoutDialog();
            }
            const path = calculatedBasename + routes.loginUrl;
            if (urlStrategy === 'path' && injector) {
                window.location.href = path;
            }
            else {
                window.location.hash = `#${path}`;
            }
        }
    }, [isLoading, isAuthenticated, routes, injector, urlStrategy, basename]);
    return React.createElement(React.Fragment, null, !isLoading && !loadingPolicy && children);
};

const CheckoutDialogSkeleton = () => {
    return React.createElement(BoxLoader, { height: 450 });
};

const PaymentProviderWrapper = ({ children }) => {
    const { fetching } = usePaymentProvider();
    const { loadPaymentConfiguration } = usePaymentProviderActions();
    react.exports.useEffect(() => {
        loadPaymentConfiguration();
    }, [loadPaymentConfiguration]);
    if (fetching) {
        return React.createElement(CheckoutDialogSkeleton, null);
    }
    return React.createElement(React.Fragment, null, children);
};

const SubscriptionsWrapper = ({ children }) => {
    const { fetching: fetchingBillingInformation } = useBillingInformation();
    const { fetching: fetchingPlans } = usePlans();
    const { fetching: fetchingPaymentMethod } = usePaymentMethod();
    const { fetching: fetchingVendorPublicConfig } = useVendorPublicConfig();
    const { loadBillingInformation } = useBillingInformationActions();
    const { loadPlans } = usePlansActions();
    const { loadPaymentMethod } = usePaymentMethodActions();
    const { loadVendorPublicConfiguration } = useVendorPublicConfigActions();
    react.exports.useEffect(() => {
        loadBillingInformation();
        loadPlans();
        loadPaymentMethod();
        loadVendorPublicConfiguration();
    }, [loadBillingInformation, loadPlans, loadPaymentMethod, loadVendorPublicConfiguration]);
    if (fetchingBillingInformation || fetchingPlans || fetchingPaymentMethod || fetchingVendorPublicConfig) {
        return React.createElement(CheckoutDialogSkeleton, null);
    }
    return React.createElement(React.Fragment, null, children);
};

const CheckoutDialogAppContent = ({ plan: planSlug, onClose, onError, onSuccess, }) => {
    const t = useT('subscriptions_CheckoutDialog');
    const { plans } = usePlans();
    const planId = react.exports.useMemo(() => { var _a; return planSlug && ((_a = plans.find((plan) => plan.slug === planSlug)) === null || _a === void 0 ? void 0 : _a.id); }, [planSlug, plans]);
    if (!planId) {
        return (React.createElement(Grid, { p: 4 },
            React.createElement(Alert$1, { "data-test-id": 'checkoutDialogPlanNotFound', severity: 'error' }, t('errorPlanNotFound'))));
    }
    return React.createElement(CheckoutDialogBody, { planId: planId, onSuccess: onSuccess, onError: onError, onClose: onClose });
};
const CheckoutDialogApp = ({ plan, onClose, onError, onSuccess }) => {
    const t = useT('subscriptions');
    const { injector } = useShadowDom();
    const hideDialogWithTimeout = react.exports.useCallback(() => {
        setTimeout(() => {
            injector === null || injector === void 0 ? void 0 : injector.hideCheckoutDialog();
        }, 200);
    }, [injector]);
    const handleClose = react.exports.useCallback(() => {
        onClose === null || onClose === void 0 ? void 0 : onClose();
        hideDialogWithTimeout();
    }, [onClose, hideDialogWithTimeout]);
    const handleSuccess = react.exports.useCallback(() => {
        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();
        hideDialogWithTimeout();
    }, [onSuccess, hideDialogWithTimeout]);
    const handleError = react.exports.useCallback((msg) => {
        onError === null || onError === void 0 ? void 0 : onError(msg);
        hideDialogWithTimeout();
    }, [onError, hideDialogWithTimeout]);
    return (React.createElement(Dialog$1, { open: true, onClose: handleClose, container: injector === null || injector === void 0 ? void 0 : injector.checkoutDialogEl, title: t('dialogCheckoutTitle'), onBackdropClick: handleClose },
        React.createElement(PaymentProviderWrapper, null,
            React.createElement(SubscriptionsWrapper, null,
                React.createElement(CheckoutDialogAppContent, { plan: plan, onClose: handleClose, onSuccess: handleSuccess, onError: handleError })))));
};

const AppWrapper = ({ children }) => {
    const { isShadowDom, injector } = useShadowDom();
    react.exports.useEffect(() => {
        document.addEventListener('focus', shadowFocusHandler, true);
        const oldDocumentBodyOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        return () => {
            document.removeEventListener('focus', shadowFocusHandler, true);
            document.body.style.overflow = oldDocumentBodyOverflow;
            window.history.pushState('', document.title, window.location.pathname);
        };
    }, []);
    const { calculatedTheme, theme, overrides } = initGlobalTheme(true);
    return (React.createElement(I18nProvider$1, null,
        React.createElement(GlobalThemeProvider, { theme: calculatedTheme, isShadowDom: isShadowDom },
            React.createElement(ThemeContext.Provider, { value: { theme, overrides } },
                React.createElement(InnerThemeProvider, { themeOptionKey: 'adminPortal' },
                    React.createElement(Provider, { context: FronteggStoreContext, store: injector.store },
                        React.createElement(AuthWrapper, null, children)))))));
};
const CheckoutDialog$1 = (_a) => {
    var _b, _c;
    var { injector, options } = _a, dialogProps = __rest(_a, ["injector", "options"]);
    return (React.createElement(ShadowDomContext.Provider, { value: Object.assign(Object.assign({ iframeRendering: false }, options), { injector, themeOptions: enhanceAdminBoxTheme((_b = options.metadata) !== null && _b !== void 0 ? _b : {}, (_c = options.themeOptions) !== null && _c !== void 0 ? _c : {}), slotsContainer: injector.checkoutDialogContainer, rootEl: injector.checkoutDialogEl }) },
        React.createElement(AppWrapper, null,
            React.createElement(CheckoutDialogApp, Object.assign({}, dialogProps)))));
};

function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$1(o, p);
}

function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to, from) {
  if (from === undefined) from = '';

  var toParts = (to && to.split('/')) || [];
  var fromParts = (from && from.split('/')) || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');

  if (
    mustEndAbs &&
    fromParts[0] !== '' &&
    (!fromParts[0] || !isAbsolute(fromParts[0]))
  )
    fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

function valueOf(obj) {
  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
}

function valueEqual(a, b) {
  // Test for strict equality first.
  if (a === b) return true;

  // Otherwise, if either of them == null they are not equal.
  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return (
      Array.isArray(b) &&
      a.length === b.length &&
      a.every(function(item, index) {
        return valueEqual(item, b[index]);
      })
    );
  }

  if (typeof a === 'object' || typeof b === 'object') {
    var aValue = valueOf(a);
    var bValue = valueOf(b);

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    return Object.keys(Object.assign({}, a, b)).every(function(key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    throw new Error(prefix + ": " + (message || ''));
}

function addLeadingSlash$1(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
}
function hasBasename(path, prefix) {
  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
}
function stripBasename$1(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';
  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
  return path;
}

function createLocation(path, state, key, currentLocation) {
  var location;

  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends$2({}, path);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}
function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
}

function createTransitionManager() {
  var prompt = null;

  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  }

  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }

  var listeners = [];

  function appendListener(fn) {
    var isActive = true;

    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  }

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message)); // eslint-disable-line no-alert
}
/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
  return window.history && 'pushState' in window.history;
}
/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */

function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
}
/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
}
/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
}
/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */


function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ? invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props,
      _props$forceRefresh = _props.forceRefresh,
      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : '';

  function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = pathname + search + hash;
    if (basename) path = stripBasename$1(path, basename);
    return createLocation(path, state, key);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends$2(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }

  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }

  var forceNextPop = false;

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key]; // Public interface

  function createHref(location) {
    return basename + createPath(location);
  }

  function push(path, state) {
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action: action,
            location: location
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }

  function replace(path, state) {
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action: action,
            location: location
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash$1
  },
  slash: {
    encodePath: addLeadingSlash$1,
    decodePath: addLeadingSlash$1
  }
};

function stripHash(url) {
  var hashIndex = url.indexOf('#');
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
}

function pushHashPath(path) {
  window.location.hash = path;
}

function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + '#' + path);
}

function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ? invariant(false) : void 0;
  var globalHistory = window.history;
  supportsGoWithoutReloadUsingHash();
  var _props = props,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = _props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  function getDOMLocation() {
    var path = decodePath(getHashPath());
    if (basename) path = stripBasename$1(path, basename);
    return createLocation(path);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends$2(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  var forceNextPop = false;
  var ignorePath = null;

  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }

  function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  }

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  } // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  function createHref(location) {
    var baseTag = document.querySelector('base');
    var href = '';

    if (baseTag && baseTag.getAttribute('href')) {
      href = stripHash(window.location.href);
    }

    return href + '#' + encodePath(basename + createPath(location));
  }

  function push(path, state) {
    var action = 'PUSH';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path);
        allPaths = nextPaths;
        setState({
          action: action,
          location: location
        });
      } else {
        setState();
      }
    });
  }

  function replace(path, state) {
    var action = 'REPLACE';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
/**
 * Creates a history object that stores locations in memory.
 */


function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      getUserConfirmation = _props.getUserConfirmation,
      _props$initialEntries = _props.initialEntries,
      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
      _props$initialIndex = _props.initialIndex,
      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends$2(history, nextState);

    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
  }); // Public interface

  var createHref = createPath;

  function push(path, state) {
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);

      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }

  function replace(path, state) {
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
    var action = 'POP';
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    return transitionManager.setPrompt(prompt);
  }

  function listen(listener) {
    return transitionManager.appendListener(listener);
  }

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
  return history;
}

var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};

function getUniqueId() {
  var key = '__global_unique_id__';
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + getUniqueId() + '__';

  var Provider = /*#__PURE__*/function (_Component) {
    _inheritsLoose$2(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(react.exports.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);

  var Consumer = /*#__PURE__*/function (_Component2) {
    _inheritsLoose$2(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(react.exports.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

var index = React.createContext || createReactContext;

var createContext = index;

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

var pathToRegexp$2 = {exports: {}};

var isarray$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = isarray$1;

/**
 * Expose `pathToRegexp`.
 */
pathToRegexp$2.exports = pathToRegexp;
pathToRegexp$2.exports.parse = parse;
pathToRegexp$2.exports.compile = compile;
pathToRegexp$2.exports.tokensToFunction = tokensToFunction;
pathToRegexp$2.exports.tokensToRegExp = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

var pathToRegexp$1 = pathToRegexp$2.exports;

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext = function createNamedContext(name) {
  var context = createContext();
  context.displayName = name;
  return context;
};

var historyContext =
/*#__PURE__*/
createNamedContext("Router-History");

// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext$1 = function createNamedContext(name) {
  var context = createContext();
  context.displayName = name;
  return context;
};

var context =
/*#__PURE__*/
createNamedContext$1("Router");

/**
 * The public API for putting history on context.
 */

var Router =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  function Router(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    }; // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.

    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        if (_this._isMounted) {
          _this.setState({
            location: location
          });
        } else {
          _this._pendingLocation = location;
        }
      });
    }

    return _this;
  }

  var _proto = Router.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;

    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) this.unlisten();
  };

  _proto.render = function render() {
    return React.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, React.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };

  return Router;
}(React.Component);

/**
 * The public API for a <Router> that stores location in memory.
 */

/*#__PURE__*/
(function (_React$Component) {
  _inheritsLoose$1(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }

  var _proto = MemoryRouter.prototype;

  _proto.render = function render() {
    return React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return MemoryRouter;
})(React.Component);

var Lifecycle =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(Lifecycle, _React$Component);

  function Lifecycle() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
}(React.Component);

var cache = {};
var cacheLimit = 10000;
var cacheCount = 0;

function compilePath(path) {
  if (cache[path]) return cache[path];
  var generator = pathToRegexp$1.compile(path);

  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }

  return generator;
}
/**
 * Public API for generating a URL pathname from a path and parameters.
 */


function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }

  if (params === void 0) {
    params = {};
  }

  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}

/**
 * The public API for navigating programmatically with a component.
 */

function Redirect(_ref) {
  var computedMatch = _ref.computedMatch,
      to = _ref.to,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? false : _ref$push;
  return React.createElement(context.Consumer, null, function (context) {
    !context ? invariant(false) : void 0;
    var history = context.history,
        staticContext = context.staticContext;
    var method = push ? history.push : history.replace;
    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends$1({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to); // When rendering in a static context,
    // set the new location immediately.

    if (staticContext) {
      method(location);
      return null;
    }

    return React.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self, prevProps) {
        var prevLocation = createLocation(prevProps.to);

        if (!locationsAreEqual(prevLocation, _extends$1({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to: to
    });
  });
}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path]) return pathCache[path];
  var keys = [];
  var regexp = pathToRegexp$1(path, keys, options);
  var result = {
    regexp: regexp,
    keys: keys
  };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */


function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }

  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === void 0 ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function (matched, path) {
    if (!path && path !== "") return null;
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);
    if (!match) return null;
    var url = match[0],
        values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path,
      // the path used to match
      url: path === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact: isExact,
      // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}
/**
 * The public API for matching a single path and rendering.
 */


var Route =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(Route, _React$Component);

  function Route() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Route.prototype;

  _proto.render = function render() {
    var _this = this;

    return React.createElement(context.Consumer, null, function (context$1) {
      !context$1 ? invariant(false) : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;

      var props = _extends$1({}, context$1, {
        location: location,
        match: match
      });

      var _this$props = _this.props,
          children = _this$props.children,
          component = _this$props.component,
          render = _this$props.render; // Preact uses an empty array as children by
      // default, so use null if that's the case.

      if (Array.isArray(children) && children.length === 0) {
        children = null;
      }

      return React.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? children(props) : children : component ? React.createElement(component, props) : render ? render(props) : null : typeof children === "function" ? children(props) : null);
    });
  };

  return Route;
}(React.Component);

function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;
  return _extends$1({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}

function stripBasename(basename, location) {
  if (!basename) return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return _extends$1({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}

function staticHandler(methodName) {
  return function () {
     invariant(false) ;
  };
}

function noop() {}
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


/*#__PURE__*/
(function (_React$Component) {
  _inheritsLoose$1(StaticRouter, _React$Component);

  function StaticRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.handlePush = function (location) {
      return _this.navigateTo(location, "PUSH");
    };

    _this.handleReplace = function (location) {
      return _this.navigateTo(location, "REPLACE");
    };

    _this.handleListen = function () {
      return noop;
    };

    _this.handleBlock = function () {
      return noop;
    };

    return _this;
  }

  var _proto = StaticRouter.prototype;

  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props,
        _this$props$basename = _this$props.basename,
        basename = _this$props$basename === void 0 ? "" : _this$props$basename,
        _this$props$context = _this$props.context,
        context = _this$props$context === void 0 ? {} : _this$props$context;
    context.action = action;
    context.location = addBasename(basename, createLocation(location));
    context.url = createURL(context.location);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        _this$props2$basename = _this$props2.basename,
        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
        _this$props2$context = _this$props2.context,
        context = _this$props2$context === void 0 ? {} : _this$props2$context,
        _this$props2$location = _this$props2.location,
        location = _this$props2$location === void 0 ? "/" : _this$props2$location,
        rest = _objectWithoutPropertiesLoose$1(_this$props2, ["basename", "context", "location"]);

    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return React.createElement(Router, _extends$1({}, rest, {
      history: history,
      staticContext: context
    }));
  };

  return StaticRouter;
})(React.Component);

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(Switch, _React$Component);

  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Switch.prototype;

  _proto.render = function render() {
    var _this = this;

    return React.createElement(context.Consumer, null, function (context) {
      !context ? invariant(false) : void 0;
      var location = _this.props.location || context.location;
      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
      // here because toArray adds keys to all child elements and we do not want
      // to trigger an unmount/remount for two <Route>s that render the same
      // component at different URLs.

      React.Children.forEach(_this.props.children, function (child) {
        if (match == null && React.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, _extends$1({}, child.props, {
            path: path
          })) : context.match;
        }
      });
      return match ? React.cloneElement(element, {
        location: location,
        computedMatch: match
      }) : null;
    });
  };

  return Switch;
}(React.Component);

var useContext = React.useContext;
function useHistory() {

  return useContext(historyContext);
}
function useLocation() {

  return useContext(context).location;
}
function useRouteMatch(path) {

  var location = useLocation();
  var match = useContext(context).match;
  return path ? matchPath(location.pathname, path) : match;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * The public API for a <Router> that uses HTML5 history.
 */

/*#__PURE__*/
(function (_React$Component) {
  _inheritsLoose(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }

  var _proto = BrowserRouter.prototype;

  _proto.render = function render() {
    return React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return BrowserRouter;
})(React.Component);

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(HashRouter, _React$Component);

  function HashRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }

  var _proto = HashRouter.prototype;

  _proto.render = function render() {
    return React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return HashRouter;
}(React.Component);

var resolveToLocation = function resolveToLocation(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};

var forwardRefShim = function forwardRefShim(C) {
  return C;
};

var forwardRef = React.forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

var LinkAnchor = forwardRef(function (_ref, forwardedRef) {
  var innerRef = _ref.innerRef,
      navigate = _ref.navigate,
      _onClick = _ref.onClick,
      rest = _objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);

  var target = rest.target;

  var props = _extends({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick) _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && ( // ignore everything but left clicks
      !target || target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();
          navigate();
        }
    }
  }); // React 15 compat


  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  /* eslint-disable-next-line jsx-a11y/anchor-has-content */


  return React.createElement("a", props);
});
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = forwardRef(function (_ref2, forwardedRef) {
  var _ref2$component = _ref2.component,
      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,
      replace = _ref2.replace,
      to = _ref2.to,
      innerRef = _ref2.innerRef,
      rest = _objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);

  return React.createElement(context.Consumer, null, function (context) {
    !context ? invariant(false) : void 0;
    var history = context.history;
    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);
    var href = location ? history.createHref(location) : "";

    var props = _extends({}, rest, {
      href: href,
      navigate: function navigate() {
        var location = resolveToLocation(to, context.location);
        var method = replace ? history.replace : history.push;
        method(location);
      }
    }); // React 15 compat


    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return React.createElement(component, props);
  });
});

var forwardRefShim$1 = function forwardRefShim(C) {
  return C;
};

var forwardRef$1 = React.forwardRef;

if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}

function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }

  return classnames.filter(function (i) {
    return i;
  }).join(" ");
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


forwardRef$1(function (_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"],
      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,
      _ref$activeClassName = _ref.activeClassName,
      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,
      activeStyle = _ref.activeStyle,
      classNameProp = _ref.className,
      exact = _ref.exact,
      isActiveProp = _ref.isActive,
      locationProp = _ref.location,
      sensitive = _ref.sensitive,
      strict = _ref.strict,
      styleProp = _ref.style,
      to = _ref.to,
      innerRef = _ref.innerRef,
      rest = _objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);

  return React.createElement(context.Consumer, null, function (context) {
    !context ? invariant(false) : void 0;
    var currentLocation = locationProp || context.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202

    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact: exact,
      sensitive: sensitive,
      strict: strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
    var style = isActive ? _extends({}, styleProp, {}, activeStyle) : styleProp;

    var props = _extends({
      "aria-current": isActive && ariaCurrent || null,
      className: className,
      style: style,
      to: toLocation
    }, rest); // React 15 compat


    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return React.createElement(Link, props);
  });
});

/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

const isObject = isobject;

var getValue = function(target, path, options) {
  if (!isObject(options)) {
    options = { default: options };
  }

  if (!isValidObject(target)) {
    return typeof options.default !== 'undefined' ? options.default : target;
  }

  if (typeof path === 'number') {
    path = String(path);
  }

  const isArray = Array.isArray(path);
  const isString = typeof path === 'string';
  const splitChar = options.separator || '.';
  const joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.');

  if (!isString && !isArray) {
    return target;
  }

  if (isString && path in target) {
    return isValid$1(path, target, options) ? target[path] : options.default;
  }

  let segs = isArray ? path : split(path, splitChar, options);
  let len = segs.length;
  let idx = 0;

  do {
    let prop = segs[idx];
    if (typeof prop === 'number') {
      prop = String(prop);
    }

    while (prop && prop.slice(-1) === '\\') {
      prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options);
    }

    if (prop in target) {
      if (!isValid$1(prop, target, options)) {
        return options.default;
      }

      target = target[prop];
    } else {
      let hasProp = false;
      let n = idx + 1;

      while (n < len) {
        prop = join([prop, segs[n++]], joinChar, options);

        if ((hasProp = prop in target)) {
          if (!isValid$1(prop, target, options)) {
            return options.default;
          }

          target = target[prop];
          idx = n - 1;
          break;
        }
      }

      if (!hasProp) {
        return options.default;
      }
    }
  } while (++idx < len && isValidObject(target));

  if (idx === len) {
    return target;
  }

  return options.default;
};

function join(segs, joinChar, options) {
  if (typeof options.join === 'function') {
    return options.join(segs);
  }
  return segs[0] + joinChar + segs[1];
}

function split(path, splitChar, options) {
  if (typeof options.split === 'function') {
    return options.split(path);
  }
  return path.split(splitChar);
}

function isValid$1(key, target, options) {
  if (typeof options.isValid === 'function') {
    return options.isValid(key, target);
  }
  return true;
}

function isValidObject(val) {
  return isObject(val) || Array.isArray(val) || typeof val === 'function';
}

var getValue$1 = getValue;

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the days added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  date.setDate(date.getDate() + amount);
  return date;
}

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */

function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 1, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.

  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();

  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

var MILLISECONDS_IN_MINUTE$2 = 60000;

function getDateMillisecondsPart(date) {
  return date.getTime() % MILLISECONDS_IN_MINUTE$2;
}
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */


function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
  date.setSeconds(0, 0);
  var hasNegativeUTCOffset = baseTimezoneOffset > 0;
  var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE$2 + getDateMillisecondsPart(date)) % MILLISECONDS_IN_MINUTE$2 : getDateMillisecondsPart(date);
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE$2 + millisecondsPartOfTimezoneOffset;
}

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

var MILLISECONDS_IN_DAY$1 = 86400000;
/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * var result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * var result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */

function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
  // because the number of milliseconds in a day is not constant
  // (e.g. it's different in the day of the daylight saving time clock shift)

  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}

/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */

function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Now `isValid` doesn't throw an exception
 *   if the first argument is not an instance of Date.
 *   Instead, argument is converted beforehand using `toDate`.
 *
 *   Examples:
 *
 *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
 *   |---------------------------|---------------|---------------|
 *   | `new Date()`              | `true`        | `true`        |
 *   | `new Date('2016-01-01')`  | `true`        | `true`        |
 *   | `new Date('')`            | `false`       | `false`       |
 *   | `new Date(1488370835081)` | `true`        | `true`        |
 *   | `new Date(NaN)`           | `false`       | `false`       |
 *   | `'2016-01-01'`            | `TypeError`   | `false`       |
 *   | `''`                      | `TypeError`   | `false`       |
 *   | `1488370835081`           | `TypeError`   | `true`        |
 *   | `NaN`                     | `TypeError`   | `false`       |
 *
 *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
 *   that try to coerce arguments to the expected type
 *   (which is also the case with other *date-fns* functions).
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * var result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * var result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * var result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return !isNaN(date);
}

// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.

function compareLocalAsc(dateLeft, dateRight) {
  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}
/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full days according to the local timezone
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * var result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * var result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 92 days, even in
 * // time zones where DST starts and the
 * // period has only 92*24-1 hours.
 * var result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
//=> 92
 */


function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign * difference); // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
  // If so, result must be decreased by 1 in absolute value

  var isLastDayNotFull = compareLocalAsc(dateLeft, dateRight) === -sign;
  var result = sign * (difference - isLastDayNotFull); // Prevent negative zero

  return result === 0 ? 0 : result;
}

/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of milliseconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * var result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */

function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getTime() - dateRight.getTime();
}

var MILLISECONDS_IN_MINUTE$1 = 60000;
/**
 * @name differenceInMinutes
 * @category Minute Helpers
 * @summary Get the number of minutes between the given dates.
 *
 * @description
 * Get the signed number of full (rounded towards 0) minutes between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of minutes
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
 * var result = differenceInMinutes(
 *   new Date(2014, 6, 2, 12, 20, 0),
 *   new Date(2014, 6, 2, 12, 7, 59)
 * )
 * //=> 12
 *
 * @example
 * // How many minutes are from 10:01:59 to 10:00:00
 * var result = differenceInMinutes(
 *   new Date(2000, 0, 1, 10, 0, 0),
 *   new Date(2000, 0, 1, 10, 1, 59)
 * )
 * //=> -1
 */

function differenceInMinutes(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / MILLISECONDS_IN_MINUTE$1;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
}

function buildFormatLongFn(args) {
  return function (dirtyOptions) {
    var options = dirtyOptions || {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var formatLong$1 = formatLong;

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};
function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}

function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.

};
var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

function ordinalNumber(dirtyNumber, _dirtyOptions) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`:
  //
  //   var options = dirtyOptions || {}
  //   var unit = String(options.unit)
  //
  // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
}

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var localize$1 = localize;

function buildMatchPatternFn(args) {
  return function (dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options = dirtyOptions || {};
    var matchResult = string.match(args.matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);

    if (!parseResult) {
      return null;
    }

    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    return {
      value: value,
      rest: string.slice(matchedString.length)
    };
  };
}

function buildMatchFn(args) {
  return function (dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options = dirtyOptions || {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var value;

    if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
      value = findIndex(parsePatterns, function (pattern) {
        return pattern.test(matchedString);
      });
    } else {
      value = findKey(parsePatterns, function (pattern) {
        return pattern.test(matchedString);
      });
    }

    value = args.valueCallback ? args.valueCallback(value) : value;
    value = options.valueCallback ? options.valueCallback(value) : value;
    return {
      value: value,
      rest: string.slice(matchedString.length)
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var match$1 = match;

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */

var locale = {
  code: 'en-US',
  formatDistance: formatDistance,
  formatLong: formatLong$1,
  formatRelative: formatRelative,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters$2 = {
  // Year
  y: function (date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function (date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function (date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function (date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function (date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function (date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function (date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function (date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function (date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var formatters$3 = formatters$2;

var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate, dirtyOptions);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
   * |  p! | Long localized time            |  P! | Long localized date            |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   * - `P` is long localized date format
   * - `p` is long localized time format
   */

};
var formatters = {
  // Era
  G: function (date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return formatters$3.y(date, token);
  },
  // Local week-numbering year
  Y: function (date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function (date, token) {
    var isoWeekYear = getUTCISOWeekYear(date); // Padding

    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return formatters$3.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function (date, token, localize, options) {
    var week = getUTCWeek(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function (date, token, localize) {
    var isoWeek = getUTCISOWeek(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function (date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return formatters$3.d(date, token);
  },
  // Day of year
  D: function (date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return formatters$3.h(date, token);
  },
  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return formatters$3.H(date, token);
  },
  // Hour [0-11]
  K: function (date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function (date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function (date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return formatters$3.m(date, token);
  },
  // Second
  s: function (date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return formatters$3.s(date, token);
  },
  // Fraction of second
  S: function (date, token) {
    return formatters$3.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var formatters$1 = formatters;

function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}

function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}

function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/);
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 0001, ..., 999               |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The second argument is now required for the sake of explicitness.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   format(new Date(2016, 0, 1))
 *
 *   // v2.0.0 onward
 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
 *   ```
 *
 * - New format string API for `format` function
 *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
 *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
 *
 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong, formatterOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }

    var formatter = formatters$1[firstCharacter];

    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }

      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the days subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */

function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}

/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */

function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The previous `parse` implementation was renamed to `parseISO`.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward
 *   parseISO('2016-01-01')
 *   ```
 *
 * - `parseISO` now validates separate date and time values in ISO-8601 strings
 *   and returns `Invalid Date` if the date is invalid.
 *
 *   ```javascript
 *   parseISO('2018-13-32')
 *   //=> Invalid Date
 *   ```
 *
 * - `parseISO` now doesn't fall back to `new Date` constructor
 *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * var result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */

function parseISO(argument, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);

  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }

  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }

  var dateStrings = splitDateString(argument);
  var date;

  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (isNaN(date) || !date) {
    return new Date(NaN);
  }

  var timestamp = date.getTime();
  var time = 0;
  var offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);

    if (isNaN(time) || time === null) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);

    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time); // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.

    var result = new Date(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate(), dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    result.setFullYear(dirtyDate.getUTCFullYear());
    return result;
  }

  return new Date(timestamp + time + offset);
}

function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString; // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].

  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];

    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }

  if (timeString) {
    var token = patterns.timezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex); // Invalid ISO-formatted year

  if (!captures) return {
    year: null
  };
  var year = captures[1] && parseInt(captures[1]);
  var century = captures[2] && parseInt(captures[2]);
  return {
    year: century == null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return null;
  var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

  if (!captures) return null;
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }

    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);

    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }

    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures) return null; // Invalid ISO-formatted time

  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
}

function parseTimeUnit(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE);
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // Validation functions
// February is null to handle the leap year (using ||)


var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100;
}

function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */

function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}

var Download = {};

var _interopRequireDefault = interopRequireDefault.exports;

Object.defineProperty(Download, "__esModule", {
  value: true
});
var default_1 = Download.default = void 0;

var _createSvgIcon = _interopRequireDefault(createSvgIcon$1);

var _jsxRuntime = jsxRuntime.exports;

var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
  d: "M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"
}), 'Download');

default_1 = Download.default = _default;

const AppDialogContext = react.exports.createContext({ closeAdminBox: () => { } });
const AppDialog = styled(props => {
    var _a, _b, _c;
    const theme = useTheme();
    const [open, setOpen] = react.exports.useState(true);
    const { injector, themeOptions, builderMode } = useShadowDom();
    const mediaQueryMdDown = useMuiMediaQuery(theme.breakpoints.down('md'));
    const fullScreen = (_c = (_b = (_a = themeOptions === null || themeOptions === void 0 ? void 0 : themeOptions.adminPortal) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.fullScreenMode) !== null && _c !== void 0 ? _c : mediaQueryMdDown;
    const rootElementStyle = react.exports.useMemo(() => ({
        style: { height: fullScreen ? undefined : 'calc(100vh - 100px)', overflow: 'hidden' },
    }), [fullScreen]);
    const closeAdminBox = react.exports.useCallback(() => {
        if (!builderMode) {
            setOpen(false);
            setTimeout(() => injector === null || injector === void 0 ? void 0 : injector.close(), 300);
        }
    }, [injector, builderMode]);
    return React.createElement(AppDialogContext.Provider, { value: { closeAdminBox } },
        React.createElement(MuiDialog, Object.assign({ open: open }, props, { container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, fullWidth: true, maxWidth: 'lg', fullScreen: fullScreen, onBackdropClick: closeAdminBox, PaperProps: rootElementStyle })));
}) `
  & .MuiDialog-paper {
    transition: all 300ms;
  }
`;

const SkeletonListItem = styled(Skeleton)({
    width: '100%',
});
SkeletonListItem.defaultProps = {
    variant: 'rectangular',
    height: 36,
    sx: { mb: 8 },
};
const SkeletonTenantName = styled((props) => React.createElement(Skeleton, Object.assign({ variant: 'rectangular', height: 16 }, props))) `
  width: 60%;
  margin-top: 24px;
  margin-bottom: 24px;
`;
const NavSkeleton = () => {
    return React.createElement("nav", null,
        React.createElement(Grid, { container: true, spacing: 3, justifyContent: 'center', alignItems: 'center', mt: 2, mb: 8 },
            React.createElement(Grid, { item: true },
                React.createElement(Skeleton, { variant: 'circular', height: 32, width: 32 })),
            React.createElement(Grid, { item: true, xs: true },
                React.createElement(Skeleton, { variant: 'text', height: 18, width: '60%' }),
                React.createElement(Skeleton, { variant: 'text', height: 16, width: '90%' }))),
        React.createElement(SkeletonListItem, { sx: { mb: 8, mt: 6 } }),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonTenantName, null),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonListItem, null),
        React.createElement(SkeletonListItem, null));
};

const PageTitleSkeleton = styled(Box) `
  height: 5.5rem;
  border-bottom: 1px solid ${({ theme }) => theme.palette.divider};

  ${({ theme }) => theme.breakpoints.down('sm')} {
    height: 3.5rem;
  }
`;
const PageSkeleton = () => {
    return React.createElement("div", null,
        React.createElement(PageTitleSkeleton, null));
};

const NavigationGridItem = styled(Grid)(({ theme, withPoweredBy }) => ({
    transition: 'width 300ms ease-in-out, padding 300ms ease-in-out',
    width: '14.25rem',
    position: 'relative',
    height: '100%',
    backgroundColor: theme.navigation.background,
    'nav': {
        boxSizing: 'border-box',
        padding: theme.spacing(4),
        overflow: 'auto',
        maxHeight: '100%',
        paddingBottom: withPoweredBy ? '5rem' : undefined,
    },
    [theme.breakpoints.up('xl')]: {
        width: '18rem',
        'nav': {
            padding: theme.spacing(4, 6),
            paddingBottom: withPoweredBy ? '5rem' : undefined,
        },
    },
    [theme.breakpoints.up('sm')]: {
        width: '18rem',
        'nav': {
            padding: theme.spacing(4, 6),
            paddingBottom: withPoweredBy ? '5rem' : undefined,
        },
    },
}));
NavigationGridItem.defaultProps = {
    item: true,
};
const PageGridItem = styled(Grid)(({ theme }) => ({
    backgroundColor: theme.palette.background.default,
    overflow: 'auto',
}));
const StyledGrid = styled(Grid)(({ theme }) => ({
    fontFamily: theme.typographyStyleOptions,
}));
const AppSkeleton = ({ absolute }) => {
    const overrideStyle = absolute ? { position: 'absolute', left: 0, top: 0, zIndex: 1000 } : {};
    const theme = useTheme();
    const displayAsDrawer = useMuiMediaQuery(theme.breakpoints.down('sm'));
    return React.createElement(StyledGrid, { "data-test-id": 'admin-portal-loader', height: '100%', container: true, alignItems: "stretch", style: overrideStyle },
        !displayAsDrawer && React.createElement(NavigationGridItem, null,
            React.createElement(NavSkeleton, null)),
        React.createElement(PageGridItem, { item: true, xs: true },
            React.createElement(PageSkeleton, null)));
};

const UserAvatar = () => {
    const user = useAuthUserOrNull();
    return user ? React.createElement(Avatar$1$1, { name: user.name, picture: user.profilePictureUrl }) : React.createElement(ProfileIcon, null);
};

const wrapPage = (Component, pageKey) => {
    return () => {
        const t = useT(pageKey);
        return React.createElement(React.Fragment, null,
            React.createElement(PageHeaderUpdater, { title: t('pageTitle') }),
            React.createElement(Component, null));
    };
};

const callbackToPromise = (resolve, reject, closeable) => (data, error) => {
    if (error) {
        if (typeof error === typeof Error) {
            reject(error);
        }
        else {
            reject(new Error(error));
        }
        return;
    }
    resolve(data);
    closeable === null || closeable === void 0 ? void 0 : closeable(data);
};
const notNull = (p) => !!p;
const getUserMetadataTitle = (user) => {
    let metadata = {};
    try {
        metadata = JSON.parse(user.metadata);
    }
    catch (e) {
        // ignore metadata data parse error
    }
    return (metadata !== null && metadata !== void 0 ? metadata : {}).title;
};
const getUserMetadata = (user, key) => {
    let metadata = {};
    try {
        metadata = JSON.parse(user.metadata);
    }
    catch (e) {
        // ignore metadata data parse error
    }
    return key ? getValue$1(metadata, key) : metadata;
};
const addUserMetadata = (user, newMetadata) => {
    let metadata = {};
    try {
        metadata = JSON.parse(user.metadata);
    }
    catch (e) {
        // ignore metadata data parse error
    }
    return JSON.stringify(Object.assign(Object.assign({}, metadata), newMetadata));
};
const formatAddress = (addressMetadata) => {
    const { address1, address2, city, state, postCode, country, } = addressMetadata !== null && addressMetadata !== void 0 ? addressMetadata : {};
    return [
        address1,
        address2,
        city,
        state,
        postCode,
        country,
    ].filter(notNull).join(', ');
};
const getUserAddress = (user) => {
    var _a;
    return (_a = formatAddress(getUserMetadata(user, 'address'))) !== null && _a !== void 0 ? _a : '';
};
const getUserFullName = (user) => {
    return [getUserMetadataTitle(user), user.name].filter(notNull).join('. ');
};

const defaultPasswordConfig = {
    allowPassphrases: true,
    maxLength: 128,
    minLength: 6,
    minOptionalTestsToPass: 1,
    minPhraseLength: 6,
};
var MfaTypeEnum;
(function (MfaTypeEnum) {
    MfaTypeEnum["DontForce"] = "DontForce";
    MfaTypeEnum["Force"] = "Force";
    MfaTypeEnum["ForceExceptSAML"] = "ForceExceptSAML";
})(MfaTypeEnum || (MfaTypeEnum = {}));
const useOptionalEnforceMfaTypes = () => {
    const vendorMfaPolicy = useVendorMfaPolicySettings(true);
    return react.exports.useMemo(() => {
        var _a, _b, _c;
        if (vendorMfaPolicy.loading) {
            return [MfaTypeEnum.Force];
        }
        if (((_a = vendorMfaPolicy.policy) === null || _a === void 0 ? void 0 : _a.enforceMFAType) === MfaTypeEnum.DontForce || !((_b = vendorMfaPolicy.policy) === null || _b === void 0 ? void 0 : _b.enforceMFAType)) {
            return [MfaTypeEnum.DontForce, MfaTypeEnum.Force, MfaTypeEnum.ForceExceptSAML];
        }
        if (((_c = vendorMfaPolicy.policy) === null || _c === void 0 ? void 0 : _c.enforceMFAType) === 'ForceExceptSAML') {
            return [MfaTypeEnum.Force, MfaTypeEnum.ForceExceptSAML];
        }
        return [MfaTypeEnum.Force];
    }, [vendorMfaPolicy]);
};
const usePasswordConfig = (userId, loadOnMount = true) => {
    const { loadPasswordConfig } = useForgotPasswordActions();
    const { passwordConfig, loading } = useForgotPasswordState();
    react.exports.useEffect(() => {
        if (loading) {
            return;
        }
        if (!passwordConfig) {
            loadPasswordConfig({ userId });
        }
    }, [loading, passwordConfig, loadPasswordConfig]);
    react.exports.useEffect(() => {
        loadOnMount && loadPasswordConfig({ userId });
    }, [loadOnMount, loadPasswordConfig]);
    const passwordServerConfig = Object.assign(Object.assign({}, defaultPasswordConfig), passwordConfig);
    const strength = passwordServerConfig.minLength <= 6 ? 'easy' : passwordServerConfig.minLength <= 8 ? 'medium' : 'hard';
    return {
        loading,
        passwordConfig: loading && !passwordConfig ? null : passwordServerConfig,
        defaultPasswordConfig,
        strength,
    };
};
const useMfaPolicySettings = (loadOnMount = false) => {
    const { loading, policy, saving, error } = useSecurityPolicyState(state => state.mfaPolicy);
    const { loadSecurityPolicyMfa, saveSecurityPolicyMfa } = useSecurityPolicyActions();
    react.exports.useEffect(() => {
        (loadOnMount || !policy) && loadSecurityPolicyMfa();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadSecurityPolicyMfa]);
    return { loading, saving, error, policy, saveSecurityPolicyMfa };
};
const useSessionPolicySettings = (loadOnMount = false) => {
    const { loading, configurations, saving, error } = useSessionsPolicyState();
    const { loadSessionsPolicy, createOrUpdateSessionsPolicy } = useSessionsPolicyActions();
    react.exports.useEffect(() => {
        (loadOnMount || !configurations) && loadSessionsPolicy();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadSessionsPolicy]);
    return { loading, saving, error, configurations, createOrUpdateSessionsPolicy };
};
const useVendorMfaPolicySettings = (loadOnMount = false) => {
    const { loading, policy, saving, error } = useSecurityPolicyState(state => state.vendorMfaPolicy);
    const { loadSecurityPolicyVendorMfa } = useSecurityPolicyActions();
    react.exports.useEffect(() => {
        (loadOnMount || !policy) && loadSecurityPolicyVendorMfa();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadSecurityPolicyVendorMfa]);
    return { loading, saving, error, policy };
};
const useLockoutPolicySettings = (loadOnMount = false) => {
    const { loading, policy, saving, error } = useSecurityPolicyState(state => state.lockoutPolicy);
    const { loadSecurityPolicyLockout, saveSecurityPolicyLockout } = useSecurityPolicyActions();
    react.exports.useEffect(() => {
        (loadOnMount || !policy) && loadSecurityPolicyLockout();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadSecurityPolicyLockout]);
    return { loading, saving, error, policy, saveSecurityPolicyLockout };
};
const usePasswordHistoryPolicySettings = (loadOnMount = false) => {
    const { loading, policy, saving, error } = useSecurityPolicyState(state => state.passwordHistoryPolicy);
    const { loadSecurityPolicyPasswordHistory, saveSecurityPolicyPasswordHistory } = useSecurityPolicyActions();
    react.exports.useEffect(() => {
        (loadOnMount || !policy) && loadSecurityPolicyPasswordHistory();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadSecurityPolicyPasswordHistory]);
    return { loading, saving, error, policy, saveSecurityPolicyPasswordHistory };
};
const usePublicPolicySettings = (loadOnMount = false) => {
    const { loading, policy, saving, error } = useSecurityPolicyState(state => state.publicPolicy);
    const { loadPublicSecurityPolicy } = useSecurityPolicyActions();
    react.exports.useEffect(() => {
        (loadOnMount || !policy) && loadPublicSecurityPolicy();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadPublicSecurityPolicy]);
    return { loading, saving, error, policy };
};
const useDialogState = (defaultOpen = false) => {
    const [open, setOpen] = react.exports.useState(defaultOpen);
    const [data, setData] = react.exports.useState(null);
    const handleCloseEditName = react.exports.useCallback(() => {
        setOpen(false);
        setData(null);
    }, [setOpen]);
    const handleOpenEditName = react.exports.useCallback((data) => {
        setData(data);
        setOpen(true);
    }, [setOpen]);
    return [open, handleCloseEditName, handleOpenEditName, data, setOpen];
};
const useBooleanToggle = (delay) => {
    const [bool, setBoolean] = react.exports.useState(false);
    react.exports.useEffect(() => {
        if (bool) {
            setTimeout(() => {
                setBoolean(false);
            }, delay !== null && delay !== void 0 ? delay : 3000);
        }
    }, [bool]);
    return [bool, setBoolean];
};
const useEffectAfterMount = (fn, deps) => {
    const [mounted, setMounted] = react.exports.useState(false);
    react.exports.useEffect(() => setMounted(true), [setMounted]);
    react.exports.useEffect(() => {
        if (!mounted) {
            return;
        }
        fn();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
};
const useDebounce = (value, delay = 300) => {
    const [debouncedValue, setDebouncedValue] = react.exports.useState(value);
    react.exports.useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);
        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);
    return debouncedValue;
};
const useAsyncEffect = (effectFn, deps) => {
    const didMountRef = react.exports.useRef(true);
    react.exports.useEffect(() => {
        if (didMountRef.current) {
            didMountRef.current = false;
            return;
        }
        // noinspection JSIgnoredPromiseFromCall
        effectFn();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [...deps]);
};
const useMemoProps = (props, key) => {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return react.exports.useMemo(() => props[key], []);
};
const useRolesMap = (roles) => {
    return react.exports.useMemo(() => (roles !== null && roles !== void 0 ? roles : []).reduce((p, n) => (Object.assign(Object.assign({}, p), { [n.id]: n.name })), {}), [roles]);
};

const FormDialogBody = (props) => {
    const { initialValues, validationSchema, onSubmit, children, enableReinitialize, validateOnMount } = props;
    const [formError, setFormError] = react.exports.useState(null);
    const formikProps = {
        onSubmit: (values, formikHelpers) => __awaiter(void 0, void 0, void 0, function* () {
            setFormError(null);
            try {
                yield onSubmit(values, formikHelpers);
            }
            catch (e) {
                setFormError(e.message);
            }
        }),
        enableReinitialize,
        initialValues,
        validationSchema,
        validateOnMount
    };
    return React.createElement(Formik, Object.assign({}, formikProps), props => {
        const canSubmit = !props.isSubmitting && props.isValid && props.dirty;
        return React.createElement(Form, { autoComplete: 'on' }, children === null || children === void 0 ? void 0 : children(Object.assign(Object.assign({}, props), { canSubmit, formError })));
    });
};
const FormErrorDialogMessage = react.exports.memo(({ message, fieldName }) => {
    var _a, _b;
    let msg = ((_a = message === null || message === void 0 ? void 0 : message.startsWith) === null || _a === void 0 ? void 0 : _a.call(message, 'Error: ')) ? (_b = message === null || message === void 0 ? void 0 : message.substring) === null || _b === void 0 ? void 0 : _b.call(message, 'Error: '.length) : message;
    return msg ?
        // TODO: changed test-id from message to `${fieldName}-error`
        React.createElement(Box, { component: Alert$1, mt: 4, "data-test-id": `${fieldName}-error` || msg, severity: 'error' }, msg)
        : null;
}, shallowEqual$1('message'));

const RemovePhotoForm = (props) => {
    const t = useT('profile');
    const { onClose } = props;
    const { saving, error, profile } = useProfileState();
    const { saveProfile, setProfileState } = useProfileActions();
    const handleRemoveImage = react.exports.useCallback(() => {
        setProfileState({ profile: Object.assign(Object.assign({}, profile), { profilePictureUrl: 'null' }) });
    }, [profile, setProfileState]);
    react.exports.useEffect(() => {
        if ((profile === null || profile === void 0 ? void 0 : profile.profilePictureUrl) === 'null') {
            saveProfile({
                callback: (_, error) => {
                    if (!error) {
                        onClose();
                    }
                },
            });
        }
    }, [profile, saveProfile, onClose]);
    return React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, null,
            React.createElement(Typography$1, { variant: 'subtitle2Light' }, t('removeImageMessage')),
            React.createElement(FormErrorDialogMessage, { message: error })),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(Box, { flex: 1 }),
            React.createElement(Button$1, { color: 'inherit', variant: 'text', "data-test-id": 'remove-photo-btn', onClick: props.onClose }, t('removeImageCancelButton')),
            React.createElement(Button$1, { loading: saving, color: 'danger', onClick: handleRemoveImage }, t('removeImageButton'))));
};
const RemovePhotoDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('profile');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('removeImageTitle') }),
        React.createElement(RemovePhotoForm, Object.assign({}, props)));
};

const HeaderContainer = styled(Card)(({ theme }) => ({
    backgroundColor: theme.rightPanel.profileHeader,
}));
const AvatarContainer = styled((props) => React.createElement(Grid, Object.assign({ item: true }, props))) `
  & {
    margin: ${({ theme }) => `${theme.spacing(2)}`};
    position: relative;

    .MuiAvatar-root {
      width: 6.5rem;
      height: 6.5rem;
    }

    .show-on-hover {
      opacity: 0;
      transition: opacity 200ms ease-in-out;
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
    }

    &:hover {
      .show-on-hover {
        opacity: 1;
      }
    }
  }
`;
const UserEmptyAvatar = styled(Avatar$1) `
  &.MuiAvatar-root {
    background: ${UI.palette('grey.150')};
    color: ${UI.palette('grey.500')};
  }
`;
const EditAvatarButton = styled(IconButton) `
  &.MuiIconButton-root {
    background: rgba(60, 74, 90, .7) !important;
    color: white;
  }
`;
const DetailsContainer = styled((props) => React.createElement(Grid, Object.assign({ item: true, xs: true }, props))) `
  & {
    padding: ${({ theme }) => `${theme.spacing(2)}`};
    padding-left: ${({ theme }) => `${theme.spacing(8)}`};


    .MuiTypography-root {
      margin-bottom: .5rem;
      text-overflow: ellipsis;
      overflow: hidden;
      font-weight: 800;

      &:last-child {
        margin-bottom: 0;
        font-weight: 400;
        color: ${({ theme }) => theme.palette.grey[700]};
      }
    }
  }
`;
const JobTitleSpan = styled('span') `
  font-size: 0.8em;
  font-weight: 400;
  color: ${({ theme }) => theme.palette.grey[600]}
`;
const toBase64 = (file) => new Promise((resolve, reject) => {
    if (file == null) {
        resolve('');
        return;
    }
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => { var _a, _b; return resolve((_b = (_a = reader.result) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''); };
    reader.onerror = (error) => reject(error);
});
const ProfileHeader = () => {
    const t = useT('profile');
    const [avatarAnchorEl, setAvatarAnchorEl] = react.exports.useState(null);
    const [openDownloadBrowse, setOpenDownloadBrowse] = react.exports.useState(false);
    const user = useAuthUser();
    const { injector } = useShadowDom();
    const jobTitle = getUserMetadata(user, 'jobTitle');
    const [uploadPhotoDialog, handleCloseUploadPhoto, handleOpenUploadPhoto] = useDialogState();
    const [removePhotoDialog, handleCloseRemovePhoto, handleOpenRemovePhoto] = useDialogState();
    const { saveProfile } = useProfileActions();
    const menuItems = react.exports.useMemo(() => [{
            icon: React.createElement(UploadIcon, { "data-test-id": 'upload-avatar-icon' }),
            onClick: () => {
                setOpenDownloadBrowse(true);
                handleOpenUploadPhoto();
                setTimeout(() => {
                    setOpenDownloadBrowse(false);
                });
            },
            text: t('uploadImage'),
        },
        ...(user.profilePictureUrl && user.profilePictureUrl !== 'null' ? [{
                icon: React.createElement(DeleteIcon, { "data-test-id": 'delete-avatar-icon' }),
                onClick: handleOpenRemovePhoto,
                text: t('removeImage'),
                negative: true,
            }] : []),
    ], [t, user, handleOpenUploadPhoto, handleOpenRemovePhoto]);
    const onEditAvatarClick = react.exports.useCallback((e) => {
        if (user.profilePictureUrl && user.profilePictureUrl !== 'null') {
            setAvatarAnchorEl(e.currentTarget);
        }
        else {
            setOpenDownloadBrowse(true);
            handleOpenUploadPhoto();
            setTimeout(() => {
                setOpenDownloadBrowse(false);
            });
        }
    }, [handleOpenUploadPhoto, user.profilePictureUrl]);
    return React.createElement(Box, { sx: { mb: 8 } },
        React.createElement(HeaderContainer, null,
            React.createElement(Grid, { container: true, justifyContent: 'center', alignItems: 'center' },
                React.createElement(AvatarContainer, null,
                    user.profilePictureUrl && user.profilePictureUrl !== 'null' ? React.createElement(UserAvatar, null) : React.createElement(UserEmptyAvatar, { "data-test-id": 'empty-avatar' },
                        React.createElement(ProfileIcon, null)),
                    React.createElement(EditAvatarButton, { "data-test-id": "edit-avatar-btn", onClick: onEditAvatarClick, className: 'show-on-hover' },
                        React.createElement(PencilIcon, { "data-test-id": 'edit-avatar-icon' })),
                    React.createElement(Menu$1, { anchorOrigin: {
                            vertical: 'bottom',
                            horizontal: 'center',
                        }, transformOrigin: {
                            vertical: 'top',
                            horizontal: 'center',
                        }, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, items: menuItems, onClose: () => setAvatarAnchorEl(null), anchorEl: avatarAnchorEl, open: !!avatarAnchorEl })),
                React.createElement(DetailsContainer, null,
                    React.createElement(Typography$1, { variant: 'h4', "data-test-id": 'profile-header-name' },
                        getUserFullName(user),
                        " ",
                        React.createElement(JobTitleSpan, { "data-test-id": jobTitle }, jobTitle && `(${jobTitle})`)),
                    React.createElement(Typography$1, { "data-test-id": 'profile-header-email' }, user.email)))),
        React.createElement(UploadPhoto, { open: uploadPhotoDialog, "data-test-id": "uploadPhotoDialog", openDownloadBrowse: openDownloadBrowse, onClose: handleCloseUploadPhoto, type: 'circle', uploadProgress: 0, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, onSubmit: (file) => new Promise((resolve, reject) => {
                toBase64(file).then(content => {
                    const callback = callbackToPromise$1(() => {
                        handleCloseUploadPhoto();
                        resolve();
                    }, reject);
                    saveProfile({ profilePictureUrl: content, callback });
                });
            }) }),
        React.createElement(RemovePhotoDialog, { open: removePhotoDialog, onClose: handleCloseRemovePhoto }));
};

const DisplayNameField = () => {
    const t = useT('profile_EditName');
    const { values } = useFormikContext();
    const displayName = [values.title, [values.firstName, values.lastName].filter(notNull).join(' ').trim()].filter(notNull).join('. ');
    return React.createElement(Input$1$1, { "data-test-id": "displayNameBox", label: t('displayNameInputLabel'), disabled: true, value: displayName });
};
const TitleField = () => {
    const t = useT('profile_EditName');
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue }] = useField('title');
    const options = react.exports.useMemo(() => [{
            label: t('nameTitle_mr'),
            value: 'Mr',
        }, {
            label: t('nameTitle_mrs'),
            value: 'Mrs',
        }, {
            label: t('nameTitle_miss'),
            value: 'Miss',
        }, {
            label: t('nameTitle_ms'),
            value: 'Ms',
        }, {
            label: t('nameTitle_dr'),
            value: 'Dr',
        }, {
            label: t('nameTitle_phd'),
            value: 'PhD',
        }], [t]);
    return React.createElement(Select$1$1, { label: t('nameTitle'), clearable: true, name: fieldProps.name, value: fieldProps.value, onChange: (value) => setValue(value, true), errorMessage: touched ? error : undefined, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options });
};
const FirstNameField$2 = () => {
    const t = useT('profile_EditName');
    const [fieldProps, { error, touched }] = useField('firstName');
    return React.createElement(Input$1$1, Object.assign({ label: t('firstNameInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": "firstNameBox", autoComplete: 'given-name' }));
};
const LastNameField$1 = () => {
    const t = useT('profile_EditName');
    const [fieldProps, { error, touched }] = useField('lastName');
    return React.createElement(Input$1$1, Object.assign({ label: t('lastNameInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": "lastNameBox", autoComplete: 'family-name' }));
};
const EditNameForm$1 = (props) => {
    const t = useT('profile_EditName');
    const user = useAuthUser();
    const { saveProfile } = useProfileActions();
    const initialValues = react.exports.useMemo(() => ({
        firstName: user.name.split(' ')[0],
        lastName: user.name.split(' ').slice(1).join(' '),
        title: getUserMetadataTitle(user),
    }), [user]);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        firstName: validateNotEmpty(t('firstNameIsRequired')),
    }), [t]);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const name = [values.firstName, values.lastName].filter(notNull).join(' ').trim();
            const metadata = addUserMetadata(user, { title: values.title, name });
            const callback = callbackToPromise(() => {
                props.onClose();
                resolve();
            }, reject);
            saveProfile({ name, metadata, callback });
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(DisplayNameField, null),
                React.createElement(TitleField, null),
                React.createElement(FirstNameField$2, null),
                React.createElement(LastNameField$1, null)),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditNameDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('profile_EditName');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title') }),
        React.createElement(EditNameForm$1, Object.assign({}, props)));
};

const Field$1 = (props) => {
    const [fieldProps, { error, touched }] = useField(props.name);
    //TODO add to data-test-id: -box
    return React.createElement(Input$1$1, Object.assign({ label: props.label }, fieldProps, { error: !!error && touched, errorMessage: error, autoFocus: true, "data-test-id": `${props.name}-box`, autoComplete: props.autoComplete }));
};
const SingleInputFormDialog = (props) => {
    const { validationSchema, initialValues, onSubmit } = props;
    const formikProps = { onSubmit, initialValues, validationSchema: validationSchema !== null && validationSchema !== void 0 ? validationSchema : validateSchema({}) };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(Field$1, { label: props.inputLabel, name: props.inputName, autoComplete: props.inputAutoComplete }),
                React.createElement(FormErrorDialogMessage, { fieldName: props.inputName, message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, props.cancelButton),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, props.submitButton)));
    });
};
const EditSingleInputDialog = (props) => {
    const dialogProps = __rest(props, ["onSubmit", "inputLabel", "inputName", "inputAutoComplete", "initialValues", "validationSchema", "description"]);
    const { injector } = useShadowDom();
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, dialogProps),
        React.createElement(SingleInputFormDialog, Object.assign({}, props)));
};

const EditPhoneDialog = (props) => {
    const t = useT('profile_EditPhone');
    const user = useAuthUser();
    const { saveProfile } = useProfileActions();
    const phoneNumber = getUserMetadata(user, 'phoneNumber');
    return React.createElement(EditSingleInputDialog, { title: t('title'), onClose: props.onClose, open: props.open, inputName: 'phone', inputLabel: t('phoneInputLabel'), cancelButton: t('cancel'), submitButton: t('save'), inputAutoComplete: 'tel', initialValues: {
            phone: phoneNumber !== null && phoneNumber !== void 0 ? phoneNumber : '',
        }, validationSchema: validateSchema({
            phone: validationPhoneOptional(t('phoneIsInvalid')),
        }), onSubmit: (values) => new Promise((resolve, reject) => {
            const metadata = addUserMetadata(user, { phoneNumber: values.phone });
            const callback = callbackToPromise(() => {
                props.onClose();
                resolve();
            }, reject);
            saveProfile({ metadata, callback });
        }) });
};

const EditJobTitleDialog = (props) => {
    var _a;
    const t = useT('profile_EditJobTitle');
    const user = useAuthUser();
    const { saveProfile } = useProfileActions();
    return React.createElement(EditSingleInputDialog, { title: t('title'), onClose: props.onClose, open: props.open, inputName: 'jobTitle', inputAutoComplete: 'organization-title', inputLabel: t('jobTitleInputLabel'), cancelButton: t('cancel'), submitButton: t('save'), initialValues: {
            jobTitle: (_a = getUserMetadata(user, 'jobTitle')) !== null && _a !== void 0 ? _a : '',
        }, onSubmit: (values) => new Promise((resolve, reject) => {
            const metadata = addUserMetadata(user, { jobTitle: values.jobTitle });
            const callback = callbackToPromise(() => {
                props.onClose();
                resolve();
            }, reject);
            saveProfile({ metadata, callback });
        }) });
};

const getRoleLevel = (roleId, roles) => {
    var _a;
    if (!roles)
        return Infinity;
    const roleSettings = roles.find((role) => role.id === roleId);
    return (_a = roleSettings === null || roleSettings === void 0 ? void 0 : roleSettings.permissionLevel) !== null && _a !== void 0 ? _a : Infinity;
};
const getMaxRoleLevel = (roleIds, roles) => {
    if (!roleIds)
        return Infinity;
    const levelsArr = roleIds.map((roleId) => getRoleLevel(roleId, roles));
    return levelsArr.length ? Math.min(...levelsArr) : Infinity;
};
const getUserMaxRoleLevel = (roles, loggedIn) => {
    const context = ContextHolder.getContext();
    const user = loggedIn !== null && loggedIn !== void 0 ? loggedIn : ContextHolder.getUser();
    let currentUserRoleLevel = Infinity;
    const currentUserRolesIds = user === null || user === void 0 ? void 0 : user.roles.map((r) => r.id);
    if (context.currentUserRoles && context.currentUserRoles.length > 0) {
        currentUserRoleLevel = getMaxRoleLevel(context.currentUserRoles, roles);
    }
    else if (currentUserRolesIds && currentUserRolesIds.length > 0) {
        currentUserRoleLevel = getMaxRoleLevel(currentUserRolesIds, roles);
    }
    return currentUserRoleLevel;
};
const checkRoleAccess = (roles, loggedIn) => {
    const currentUserRoleLevel = getUserMaxRoleLevel(roles, loggedIn);
    if (roles) {
        return roles.filter((role) => { var _a; return ((_a = role.permissionLevel) !== null && _a !== void 0 ? _a : Infinity) >= currentUserRoleLevel; });
    }
    return [];
};
const hasPermission = (...permissions) => {
    var _a, _b;
    const userPermissions = (_b = (_a = ContextHolder.getUser()) === null || _a === void 0 ? void 0 : _a.permissions) !== null && _b !== void 0 ? _b : [];
    return permissions.reduce((p, permission) => {
        return !!userPermissions.find(userPermission => new RegExp(userPermission.key
            .replace(/\./g, '\\.')
            .replace(/\*/g, '.*')).test(permission));
    }, true);
};
const usePermission = (...permissions) => {
    const { policy, loading: loadingPolicy } = usePublicPolicySettings();
    return hasPermission(...permissions) || (!loadingPolicy && !(policy === null || policy === void 0 ? void 0 : policy.forcePermissions));
};

const countries = [
    { name: 'Afghanistan', code: 'AF' },
    { name: 'Åland Islands', code: 'AX' },
    { name: 'Albania', code: 'AL' },
    { name: 'Algeria', code: 'DZ' },
    { name: 'American Samoa', code: 'AS' },
    { name: 'AndorrA', code: 'AD' },
    { name: 'Angola', code: 'AO' },
    { name: 'Anguilla', code: 'AI' },
    { name: 'Antarctica', code: 'AQ' },
    { name: 'Antigua and Barbuda', code: 'AG' },
    { name: 'Argentina', code: 'AR' },
    { name: 'Armenia', code: 'AM' },
    { name: 'Aruba', code: 'AW' },
    { name: 'Australia', code: 'AU' },
    { name: 'Austria', code: 'AT' },
    { name: 'Azerbaijan', code: 'AZ' },
    { name: 'Bahamas', code: 'BS' },
    { name: 'Bahrain', code: 'BH' },
    { name: 'Bangladesh', code: 'BD' },
    { name: 'Barbados', code: 'BB' },
    { name: 'Belarus', code: 'BY' },
    { name: 'Belgium', code: 'BE' },
    { name: 'Belize', code: 'BZ' },
    { name: 'Benin', code: 'BJ' },
    { name: 'Bermuda', code: 'BM' },
    { name: 'Bhutan', code: 'BT' },
    { name: 'Bolivia', code: 'BO' },
    { name: 'Bosnia and Herzegovina', code: 'BA' },
    { name: 'Botswana', code: 'BW' },
    { name: 'Bouvet Island', code: 'BV' },
    { name: 'Brazil', code: 'BR' },
    { name: 'British Indian Ocean Territory', code: 'IO' },
    { name: 'Brunei Darussalam', code: 'BN' },
    { name: 'Bulgaria', code: 'BG' },
    { name: 'Burkina Faso', code: 'BF' },
    { name: 'Burundi', code: 'BI' },
    { name: 'Cambodia', code: 'KH' },
    { name: 'Cameroon', code: 'CM' },
    { name: 'Canada', code: 'CA' },
    { name: 'Cape Verde', code: 'CV' },
    { name: 'Cayman Islands', code: 'KY' },
    { name: 'Central African Republic', code: 'CF' },
    { name: 'Chad', code: 'TD' },
    { name: 'Chile', code: 'CL' },
    { name: 'China', code: 'CN' },
    { name: 'Christmas Island', code: 'CX' },
    { name: 'Cocos (Keeling) Islands', code: 'CC' },
    { name: 'Colombia', code: 'CO' },
    { name: 'Comoros', code: 'KM' },
    { name: 'Congo', code: 'CG' },
    { name: 'Congo, The Democratic Republic of the', code: 'CD' },
    { name: 'Cook Islands', code: 'CK' },
    { name: 'Costa Rica', code: 'CR' },
    { name: 'Cote D\'Ivoire', code: 'CI' },
    { name: 'Croatia', code: 'HR' },
    { name: 'Cuba', code: 'CU' },
    { name: 'Cyprus', code: 'CY' },
    { name: 'Czech Republic', code: 'CZ' },
    { name: 'Denmark', code: 'DK' },
    { name: 'Djibouti', code: 'DJ' },
    { name: 'Dominica', code: 'DM' },
    { name: 'Dominican Republic', code: 'DO' },
    { name: 'Ecuador', code: 'EC' },
    { name: 'Egypt', code: 'EG' },
    { name: 'El Salvador', code: 'SV' },
    { name: 'Equatorial Guinea', code: 'GQ' },
    { name: 'Eritrea', code: 'ER' },
    { name: 'Estonia', code: 'EE' },
    { name: 'Ethiopia', code: 'ET' },
    { name: 'Falkland Islands (Malvinas)', code: 'FK' },
    { name: 'Faroe Islands', code: 'FO' },
    { name: 'Fiji', code: 'FJ' },
    { name: 'Finland', code: 'FI' },
    { name: 'France', code: 'FR' },
    { name: 'French Guiana', code: 'GF' },
    { name: 'French Polynesia', code: 'PF' },
    { name: 'French Southern Territories', code: 'TF' },
    { name: 'Gabon', code: 'GA' },
    { name: 'Gambia', code: 'GM' },
    { name: 'Georgia', code: 'GE' },
    { name: 'Germany', code: 'DE' },
    { name: 'Ghana', code: 'GH' },
    { name: 'Gibraltar', code: 'GI' },
    { name: 'Greece', code: 'GR' },
    { name: 'Greenland', code: 'GL' },
    { name: 'Grenada', code: 'GD' },
    { name: 'Guadeloupe', code: 'GP' },
    { name: 'Guam', code: 'GU' },
    { name: 'Guatemala', code: 'GT' },
    { name: 'Guernsey', code: 'GG' },
    { name: 'Guinea', code: 'GN' },
    { name: 'Guinea-Bissau', code: 'GW' },
    { name: 'Guyana', code: 'GY' },
    { name: 'Haiti', code: 'HT' },
    { name: 'Heard Island and Mcdonald Islands', code: 'HM' },
    { name: 'Holy See (Vatican City State)', code: 'VA' },
    { name: 'Honduras', code: 'HN' },
    { name: 'Hong Kong', code: 'HK' },
    { name: 'Hungary', code: 'HU' },
    { name: 'Iceland', code: 'IS' },
    { name: 'India', code: 'IN' },
    { name: 'Indonesia', code: 'ID' },
    { name: 'Iran, Islamic Republic Of', code: 'IR' },
    { name: 'Iraq', code: 'IQ' },
    { name: 'Ireland', code: 'IE' },
    { name: 'Isle of Man', code: 'IM' },
    { name: 'Israel', code: 'IL' },
    { name: 'Italy', code: 'IT' },
    { name: 'Jamaica', code: 'JM' },
    { name: 'Japan', code: 'JP' },
    { name: 'Jersey', code: 'JE' },
    { name: 'Jordan', code: 'JO' },
    { name: 'Kazakhstan', code: 'KZ' },
    { name: 'Kenya', code: 'KE' },
    { name: 'Kiribati', code: 'KI' },
    { name: 'Korea, Democratic People\'S Republic of', code: 'KP' },
    { name: 'Korea, Republic of', code: 'KR' },
    { name: 'Kuwait', code: 'KW' },
    { name: 'Kyrgyzstan', code: 'KG' },
    { name: 'Lao People\'S Democratic Republic', code: 'LA' },
    { name: 'Latvia', code: 'LV' },
    { name: 'Lebanon', code: 'LB' },
    { name: 'Lesotho', code: 'LS' },
    { name: 'Liberia', code: 'LR' },
    { name: 'Libyan Arab Jamahiriya', code: 'LY' },
    { name: 'Liechtenstein', code: 'LI' },
    { name: 'Lithuania', code: 'LT' },
    { name: 'Luxembourg', code: 'LU' },
    { name: 'Macao', code: 'MO' },
    { name: 'Macedonia, The Former Yugoslav Republic of', code: 'MK' },
    { name: 'Madagascar', code: 'MG' },
    { name: 'Malawi', code: 'MW' },
    { name: 'Malaysia', code: 'MY' },
    { name: 'Maldives', code: 'MV' },
    { name: 'Mali', code: 'ML' },
    { name: 'Malta', code: 'MT' },
    { name: 'Marshall Islands', code: 'MH' },
    { name: 'Martinique', code: 'MQ' },
    { name: 'Mauritania', code: 'MR' },
    { name: 'Mauritius', code: 'MU' },
    { name: 'Mayotte', code: 'YT' },
    { name: 'Mexico', code: 'MX' },
    { name: 'Micronesia, Federated States of', code: 'FM' },
    { name: 'Moldova, Republic of', code: 'MD' },
    { name: 'Monaco', code: 'MC' },
    { name: 'Mongolia', code: 'MN' },
    { name: 'Montserrat', code: 'MS' },
    { name: 'Morocco', code: 'MA' },
    { name: 'Mozambique', code: 'MZ' },
    { name: 'Myanmar', code: 'MM' },
    { name: 'Namibia', code: 'NA' },
    { name: 'Nauru', code: 'NR' },
    { name: 'Nepal', code: 'NP' },
    { name: 'Netherlands', code: 'NL' },
    { name: 'Netherlands Antilles', code: 'AN' },
    { name: 'New Caledonia', code: 'NC' },
    { name: 'New Zealand', code: 'NZ' },
    { name: 'Nicaragua', code: 'NI' },
    { name: 'Niger', code: 'NE' },
    { name: 'Nigeria', code: 'NG' },
    { name: 'Niue', code: 'NU' },
    { name: 'Norfolk Island', code: 'NF' },
    { name: 'Northern Mariana Islands', code: 'MP' },
    { name: 'Norway', code: 'NO' },
    { name: 'Oman', code: 'OM' },
    { name: 'Pakistan', code: 'PK' },
    { name: 'Palau', code: 'PW' },
    { name: 'Palestinian Territory, Occupied', code: 'PS' },
    { name: 'Panama', code: 'PA' },
    { name: 'Papua New Guinea', code: 'PG' },
    { name: 'Paraguay', code: 'PY' },
    { name: 'Peru', code: 'PE' },
    { name: 'Philippines', code: 'PH' },
    { name: 'Pitcairn', code: 'PN' },
    { name: 'Poland', code: 'PL' },
    { name: 'Portugal', code: 'PT' },
    { name: 'Puerto Rico', code: 'PR' },
    { name: 'Qatar', code: 'QA' },
    { name: 'Reunion', code: 'RE' },
    { name: 'Romania', code: 'RO' },
    { name: 'Russian Federation', code: 'RU' },
    { name: 'RWANDA', code: 'RW' },
    { name: 'Saint Helena', code: 'SH' },
    { name: 'Saint Kitts and Nevis', code: 'KN' },
    { name: 'Saint Lucia', code: 'LC' },
    { name: 'Saint Pierre and Miquelon', code: 'PM' },
    { name: 'Saint Vincent and the Grenadines', code: 'VC' },
    { name: 'Samoa', code: 'WS' },
    { name: 'San Marino', code: 'SM' },
    { name: 'Sao Tome and Principe', code: 'ST' },
    { name: 'Saudi Arabia', code: 'SA' },
    { name: 'Senegal', code: 'SN' },
    { name: 'Serbia and Montenegro', code: 'CS' },
    { name: 'Seychelles', code: 'SC' },
    { name: 'Sierra Leone', code: 'SL' },
    { name: 'Singapore', code: 'SG' },
    { name: 'Slovakia', code: 'SK' },
    { name: 'Slovenia', code: 'SI' },
    { name: 'Solomon Islands', code: 'SB' },
    { name: 'Somalia', code: 'SO' },
    { name: 'South Africa', code: 'ZA' },
    { name: 'South Georgia and the South Sandwich Islands', code: 'GS' },
    { name: 'Spain', code: 'ES' },
    { name: 'Sri Lanka', code: 'LK' },
    { name: 'Sudan', code: 'SD' },
    { name: 'Suriname', code: 'SR' },
    { name: 'Svalbard and Jan Mayen', code: 'SJ' },
    { name: 'Swaziland', code: 'SZ' },
    { name: 'Sweden', code: 'SE' },
    { name: 'Switzerland', code: 'CH' },
    { name: 'Syrian Arab Republic', code: 'SY' },
    { name: 'Taiwan, Province of China', code: 'TW' },
    { name: 'Tajikistan', code: 'TJ' },
    { name: 'Tanzania, United Republic of', code: 'TZ' },
    { name: 'Thailand', code: 'TH' },
    { name: 'Timor-Leste', code: 'TL' },
    { name: 'Togo', code: 'TG' },
    { name: 'Tokelau', code: 'TK' },
    { name: 'Tonga', code: 'TO' },
    { name: 'Trinidad and Tobago', code: 'TT' },
    { name: 'Tunisia', code: 'TN' },
    { name: 'Turkey', code: 'TR' },
    { name: 'Turkmenistan', code: 'TM' },
    { name: 'Turks and Caicos Islands', code: 'TC' },
    { name: 'Tuvalu', code: 'TV' },
    { name: 'Uganda', code: 'UG' },
    { name: 'Ukraine', code: 'UA' },
    { name: 'United Arab Emirates', code: 'AE' },
    { name: 'United Kingdom', code: 'GB' },
    { name: 'United States', code: 'US' },
    { name: 'United States Minor Outlying Islands', code: 'UM' },
    { name: 'Uruguay', code: 'UY' },
    { name: 'Uzbekistan', code: 'UZ' },
    { name: 'Vanuatu', code: 'VU' },
    { name: 'Venezuela', code: 'VE' },
    { name: 'Viet Nam', code: 'VN' },
    { name: 'Virgin Islands, British', code: 'VG' },
    { name: 'Virgin Islands, U.S.', code: 'VI' },
    { name: 'Wallis and Futuna', code: 'WF' },
    { name: 'Western Sahara', code: 'EH' },
    { name: 'Yemen', code: 'YE' },
    { name: 'Zambia', code: 'ZM' },
    { name: 'Zimbabwe', code: 'ZW' },
];

const InputCopyField = react.exports.memo(({ label, value, testId }) => {
    return React.createElement(InputCopy$1, { label: label, value: value, testId: testId, sx: { marginBottom: 2 } });
});
const RolesField$4 = react.exports.memo(({ label, placeholder }) => {
    const { injector } = useShadowDom();
    const user = useAuthUserOrNull();
    const allRoles = useAuthTeamState(state => state.roles);
    const roles = checkRoleAccess(allRoles, user);
    const [fieldProps, { error, touched }, { setValue, setTouched }] = useField('roleIds');
    const options = react.exports.useMemo(() => (roles !== null && roles !== void 0 ? roles : []).map(role => ({ label: role.name, value: role.id, withCheckbox: true })), [roles]);
    return React.createElement(Select$1$1, { label: label, name: 'roleIds', multi: true, placeholder: placeholder, value: fieldProps.value, "data-test-id": "selectRoles", onChange: (value) => {
            setValue(value, true);
            setTouched(true);
        }, error: !!error && touched, errorMessage: error, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options });
}, shallowEqual$1('label'));
const Field = (props) => {
    var _a;
    const { autoComplete, autoFocus } = props;
    const [fieldProps, { error, touched }] = useField(props.name);
    //TODO add to data test id: props.name-box
    return React.createElement(Input$1$1, Object.assign({ label: props.label, placeholder: props.placeholder }, fieldProps, { value: (_a = fieldProps.value) !== null && _a !== void 0 ? _a : '', error: !!error && touched, errorMessage: error, autoFocus: autoFocus, "data-test-id": `${props.name}-box`, autoComplete: autoComplete }));
};
const CountryField = ({ name, countryCode, label, placeholder }) => {
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue }] = useField(name !== null && name !== void 0 ? name : 'country');
    const [search, setSearch] = react.exports.useState('');
    const handleSearchChanged = react.exports.useCallback((str) => __awaiter(void 0, void 0, void 0, function* () { return setSearch((str !== null && str !== void 0 ? str : '').toLowerCase().trim()); }), [setSearch]);
    const options = react.exports.useMemo(() => {
        let data = countries.map(({ name, code }) => ({ label: name, value: countryCode ? code : name }));
        if (search) {
            return data.filter(({ label }) => label.toLowerCase().indexOf(search) !== -1);
        }
        return data;
    }, [search, countryCode]);
    return React.createElement(Select$1$1, { size: 'small', "data-test-id": "country-dropdown", name: fieldProps.name, value: fieldProps.value, onChange: (value) => setValue(value, true), options: options, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, label: label, errorMessage: touched ? error : undefined, onSearch: handleSearchChanged, placeholder: placeholder });
};

const CustomCountryField$2 = () => {
    const t = useT('profile_EditAddress');
    return React.createElement(CountryField, { label: t('countryInputLabel'), placeholder: t('countryInputPlaceholder') });
};
const Address1Field$2 = () => {
    const t = useT('profile_EditAddress');
    return React.createElement(Field, { autoComplete: 'street-address', name: 'address1', label: t('address1InputLabel') });
};
const Address2Field$2 = () => {
    const t = useT('profile_EditAddress');
    return React.createElement(Field, { autoComplete: 'address-level3', name: 'address2', label: t('address2InputLabel') });
};
const CityField$2 = () => {
    const t = useT('profile_EditAddress');
    return React.createElement(Field, { autoComplete: 'address-level2', name: 'city', label: t('cityInputLabel') });
};
const StateField$2 = () => {
    const t = useT('profile_EditAddress');
    return React.createElement(Field, { autoComplete: 'address-level1', name: 'state', label: t('stateInputLabel') });
};
const PostcodeField$2 = () => {
    const t = useT('profile_EditAddress');
    return React.createElement(Field, { autoComplete: 'postal-code', name: 'postCode', label: t('postCodeInputLabel') });
};
const EditNameForm = (props) => {
    const t = useT('profile_EditAddress');
    const user = useAuthUser();
    const { saveProfile } = useProfileActions();
    const initialValues = react.exports.useMemo(() => ({
        address1: getUserMetadata(user, 'address.address1'),
        address2: getUserMetadata(user, 'address.address2'),
        city: getUserMetadata(user, 'address.city'),
        state: getUserMetadata(user, 'address.state'),
        postCode: getUserMetadata(user, 'address.postCode'),
        country: getUserMetadata(user, 'address.country'),
    }), [user]);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        address1: validateNotEmpty(t('address1IsRequired')),
        city: validateNotEmpty(t('cityIsRequired')),
        postCode: validationPostCodeOptional(t('postCodeIsInvalid')),
        country: validateNotEmpty(t('countryIsRequired')),
    }), [t]);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const metadata = addUserMetadata(user, { address: values });
            const callback = callbackToPromise(() => {
                props.onClose();
                resolve();
            }, reject);
            saveProfile({ metadata, callback });
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(CustomCountryField$2, null),
                React.createElement(Address1Field$2, null),
                React.createElement(Address2Field$2, null),
                React.createElement(CityField$2, null),
                React.createElement(StateField$2, null),
                React.createElement(PostcodeField$2, null)),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditAddressDialog$1 = (props) => {
    const { injector } = useShadowDom();
    const t = useT('profile_EditAddress');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title') }),
        React.createElement(EditNameForm, Object.assign({}, props)));
};

const PageWrapper = styled(Box)(({ theme }) => {
    var _a;
    return (Object.assign({ flex: 1, overflow: 'auto', transform: 'translate3d(0,0,0)' }, (_a = theme === null || theme === void 0 ? void 0 : theme.pages) === null || _a === void 0 ? void 0 : _a.content));
});
PageWrapper.defaultProps = {
    pt: 4,
    pb: 4,
    pl: 6,
    pr: 6,
};

const ProfilePage$1 = () => {
    const t = useT('profile');
    const user = useAuthUser();
    reloadProfileIfNeeded();
    const [editNameDialog, handleCloseEditName, handleOpenEditName] = useDialogState();
    const [editPhoneNumberDialog, handleCloseEditPhoneNumber, handleOpenEditPhoneNumber] = useDialogState();
    const [editJobTitleDialog, handleCloseEditJobTitle, handleOpenEditJobTitle] = useDialogState();
    const [editAddressDialog, handleCloseEditAddress, handleOpenEditAddress] = useDialogState();
    const items = react.exports.useMemo(() => [
        {
            id: 'email',
            title: t('email'),
            value: user.email,
            onEditClick: null,
            testId: 'email-field'
        }, {
            id: 'name',
            title: t('name'),
            value: getUserFullName(user),
            onEditClick: handleOpenEditName,
            testId: 'name-field'
        }, {
            id: 'phone',
            title: t('phone'),
            value: getUserMetadata(user, 'phoneNumber'),
            onEditClick: handleOpenEditPhoneNumber,
            testId: 'phone-field'
        }, {
            id: 'metadata.address',
            title: t('address'),
            value: getUserAddress(user),
            onEditClick: handleOpenEditAddress,
            testId: 'address-field'
        }, {
            id: 'metadata.jobTitle',
            title: t('jobTitle'),
            value: getUserMetadata(user, 'jobTitle'),
            onEditClick: handleOpenEditJobTitle,
            testId: 'jobTitle-field'
        }
    ], [user, t, handleOpenEditName, handleOpenEditPhoneNumber, handleOpenEditJobTitle, handleOpenEditAddress]);
    return React.createElement(PageWrapper, { "data-test-id": 'profile-page-wrapper' },
        React.createElement(ProfileHeader, null),
        React.createElement(SettingsList, { title: t('informationTitle'), items: items }),
        React.createElement(EditNameDialog, { open: editNameDialog, onClose: handleCloseEditName }),
        React.createElement(EditPhoneDialog, { open: editPhoneNumberDialog, onClose: handleCloseEditPhoneNumber }),
        React.createElement(EditJobTitleDialog, { open: editJobTitleDialog, onClose: handleCloseEditJobTitle }),
        React.createElement(EditAddressDialog$1, { open: editAddressDialog, onClose: handleCloseEditAddress }));
};
var ProfilePage$2 = ProfilePage$1;

var ProfilePage = wrapPage(ProfilePage$2, 'profile');

const CurrentPasswordField = react.exports.memo(() => {
    const t = useT('privacy_ChangePassword');
    const [fieldProps, { error, touched }] = useField('password');
    return React.createElement(InputPassword$1, Object.assign({}, fieldProps, { autoFocus: true, label: t('currentPasswordInputLabel'), error: !!error, errorMessage: error && touched ? error : undefined, "data-test-id": "currentPasswordBox", autoComplete: 'current-password' }));
});
const NewPasswordField = react.exports.memo(() => {
    const t = useT('privacy_ChangePassword');
    const [fieldProps, { error, touched }] = useField('newPassword');
    return React.createElement(InputPassword$1, Object.assign({}, fieldProps, { label: t('newPasswordInputLabel'), error: !!error && touched, "aria-autocomplete": 'none', "data-test-id": "newPasswordBox", autoComplete: 'new-password' }));
});
const ConfirmPasswordField = react.exports.memo(() => {
    const t = useT('privacy_ChangePassword');
    const [fieldProps, { error, touched }] = useField('confirmPassword');
    return React.createElement(InputPassword$1, Object.assign({}, fieldProps, { label: t('confirmPasswordInputLabel'), error: !!error && touched, errorMessage: error, "aria-autocomplete": 'none', "data-test-id": "confirmPasswordBox", autoComplete: 'new-password' }));
});
const PasswordStrength = (props) => {
    const [{ value }] = useField('newPassword');
    const globalT = useGlobalT();
    return React.createElement(PasswordStrengthChecker, Object.assign({ t: globalT, value: value, isTouched: value !== '' }, props));
};
const ChangePasswordForm = (props) => {
    const t = useT('privacy_ChangePassword');
    const user = useAuthUser();
    const { changePassword } = useProfileActions();
    const { loading, passwordConfig: passwordServerConfig, defaultPasswordConfig } = usePasswordConfig(user.id, false);
    const initialValues = react.exports.useMemo(() => ({
        password: '',
        newPassword: '',
        confirmPassword: '',
    }), []);
    const passwordConfig = loading || !passwordServerConfig ? defaultPasswordConfig : passwordServerConfig;
    const validationSchema = react.exports.useMemo(() => {
        return validateSchema({
            password: validateNotEmpty(t('currentPasswordIsRequired')),
            newPassword: validatePasswordUsingOWASP(t('newPasswordIsRequired')),
            confirmPassword: validateConfirmPassword(t('confirmPasswordIsRequired'), t('confirmPasswordMustMatch'), 'newPassword'),
        });
    }, [t, passwordConfig]);
    const formikProps = {
        onSubmit: ({ password, newPassword }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, props.onClose);
            changePassword({ password, newPassword, callback });
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(CurrentPasswordField, null),
                React.createElement(NewPasswordField, null),
                React.createElement(PasswordStrength, { passwordConfig: passwordConfig, loading: loading || !passwordConfig }),
                React.createElement(ConfirmPasswordField, null),
                React.createElement(FormErrorDialogMessage, { fieldName: 'changePassword', message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "changePasswordBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('changePassword'))));
    });
};
const ChangePasswordDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('privacy_ChangePassword');
    return React.createElement(Dialog$1, Object.assign({ "data-test-id": "changePasswordDialog", container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, dialogTitleDataTestId: 'changePasswordHeader', title: t('title') }, props, { size: 'sm' }),
        React.createElement(ChangePasswordForm, Object.assign({}, props)));
};

const PulseSvgIcon = styled(react.exports.forwardRef((props, ref) => React.createElement(SvgIcon, Object.assign({ ref: ref }, props)))) `
  & {
    animation: svg-pulse 1.5s ease-in-out 0.5s infinite;
    color: #E7E7E7;
  }

  @keyframes svg-pulse {
    0% {
      opacity: 1
    }
    50% {
      opacity: 0.4
    }
    100% {
      opacity: 1
    }
  }
`;
const QrCodeSkeleton = react.exports.forwardRef((_, ref) => {
    const dots = [[90, 0], [120, 0], [110, 10], [120, 10], [120, 20], [90, 30], [90, 40], [120, 40], [80, 50], [100, 50], [110, 50], [120, 50], [80, 60], [100, 60], [120, 60], [110, 70], [120, 70], [0, 80], [30, 80], [50, 80], [60, 80], [80, 80], [90, 80], [130, 80], [150, 80], [40, 90], [100, 90], [140, 90], [150, 90], [180, 90], [190, 90], [200, 90], [0, 100], [10, 100], [20, 100], [60, 100], [70, 100], [90, 100], [100, 100], [120, 100], [130, 100], [170, 100], [200, 100], [10, 110], [20, 110], [70, 110], [90, 110], [110, 110], [160, 110], [170, 110], [190, 110], [200, 110], [0, 120], [10, 120], [20, 120], [30, 120], [40, 120], [50, 120], [60, 120], [70, 120], [90, 120], [100, 120], [120, 120], [140, 120], [150, 120], [160, 120], [190, 120], [80, 130], [90, 130], [100, 130], [110, 130], [150, 130], [170, 130], [200, 130], [130, 140], [150, 140], [160, 140], [180, 140], [190, 140], [80, 150], [100, 150], [110, 150], [120, 150], [130, 150], [150, 150], [160, 150], [200, 150], [90, 160], [100, 160], [110, 160], [140, 160], [150, 160], [160, 160], [200, 160], [80, 170], [110, 170], [150, 170], [160, 170], [170, 170], [190, 170], [200, 170], [100, 180], [120, 180], [150, 180], [160, 180], [180, 180], [200, 180], [130, 190], [140, 190], [160, 190], [80, 200], [90, 200], [100, 200], [110, 200], [120, 200], [170, 200], [190, 200]];
    const largeDots = [[20, 20], [160, 20], [20, 160]];
    const corners = [[0, 0], [140, 0], [0, 140]];
    return React.createElement(PulseSvgIcon, { viewBox: '0 0 250 250', ref: ref },
        React.createElement("g", { transform: "translate(20,20)" },
            dots.map((dot, index) => React.createElement("g", { key: index, transform: `translate(${dot[0]},${dot[1]}) scale(0.1,0.1)` },
                React.createElement("rect", { width: "100", height: "100" }))),
            largeDots.map((dot, index) => React.createElement("g", { key: index, transform: `translate(${dot[0]},${dot[1]}) scale(0.3,0.3)` },
                React.createElement("rect", { width: "100", height: "100" }))),
            corners.map((corner, index) => React.createElement("g", { key: index, transform: `translate(${corner[0]},${corner[1]}) scale(0.7, 0.7)` },
                React.createElement("rect", { x: '15', y: '15', fill: 'none', width: '70', height: '70' }),
                React.createElement("path", { d: "M85,0H15H0v15v70v15h15h70h15V85V15V0H85z M85,85H15V15h70V85z" })))));
});

const GoogleAuthenticatorLink = react.exports.memo(() => {
    return React.createElement(Link$1, { href: 'https://www.google.com/search?q=google+authenticator', target: '_blank' }, ` Google Authenticator `);
});
const QrCodeContainer = styled(Grid)(({ theme }) => ({
    height: '12rem',
    width: '12rem',
    border: `1px solid ${theme.palette.grey[300]}`,
    borderRadius: '0.5rem',
    position: 'relative',
    padding: theme.spacing(10),
    justifyContent: 'center',
    alignItems: 'center',
    margin: '2rem auto',
    'img, svg': {
        top: '0.5rem',
        left: '0.5rem',
        position: 'absolute',
        width: 'calc(100% - 1rem)',
        height: 'calc(100% - 1rem)',
    },
}));
const QrCodeComponent = () => {
    const { loading, qrCode } = useMfaState();
    const displaySkeleton = !qrCode && loading;
    return React.createElement(QrCodeContainer, { container: true },
        React.createElement(Grid, { item: true },
            React.createElement(Fade, { in: displaySkeleton },
                React.createElement(QrCodeSkeleton, null)),
            React.createElement(Fade, { in: !displaySkeleton },
                React.createElement("img", { "data-test-id": "qrCode", alt: 'qr-code', src: qrCode !== null && qrCode !== void 0 ? qrCode : '' }))));
};
const TokenInput$1 = react.exports.memo(() => {
    const t = useT('privacy_EnableMfa');
    const { submitCount, dirty } = useFormikContext();
    const [fieldProps, { error, touched }] = useField('token');
    return React.createElement(Input$1$1, Object.assign({}, fieldProps, { autoFocus: true, "data-test-id": "6DigitsCode", inputMode: 'numeric', label: t('codeInputLabel'), placeholder: t('codeInputPlaceholder'), error: !!error && ((touched && !!submitCount) || dirty), errorMessage: error, autoComplete: 'one-time-code' }));
});
const VerifyMfaForm = react.exports.forwardRef((props, ref) => {
    const t = useT('privacy_EnableMfa');
    const { verifyMfa } = useMfaActions();
    const initialValues = react.exports.useMemo(() => ({ token: '' }), []);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        token: validateMinLength(6, t('codeIsRequired'), t('codeLengthAtLeast6')),
    }), [t]);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            verifyMfa({ token: values.token, callback });
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, { ref: ref },
                React.createElement(Box, { mb: 8 },
                    React.createElement(Typography$1, { variant: 'subtitle2' }, t('subtitle'))),
                React.createElement(Typography$1, { variant: 'body1' },
                    t('scanDescription1'),
                    " ",
                    React.createElement(GoogleAuthenticatorLink, null),
                    " ",
                    t('scanDescription2')),
                React.createElement(QrCodeComponent, null),
                React.createElement(TokenInput$1, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "verifyBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('verify'))));
    });
});
const RecoveryMfaForm = react.exports.forwardRef((props, ref) => {
    const t = useT('privacy_EnableMfa');
    const { recoveryCode = '' } = useMfaState();
    return React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, { ref: ref },
            React.createElement(Typography$1, { variant: 'subtitle1' }, t('recoveryCodeTitle')),
            React.createElement(Box, { mt: 8 },
                React.createElement(InputCopy$1, { label: t('recoveryCodeLabel'), value: recoveryCode })),
            React.createElement(Box, { mt: 8 },
                React.createElement(Alert$1, { severity: 'info' }, t('recoveryCodeInstructions')))),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
            React.createElement(Button$1, { "data-test-id": "closeBtn", color: "inherit", onClick: props.onClose }, t('close'))));
});
const EnableMfaStepper = props => {
    const { step } = useMfaState();
    const { enrollMfa, resetMfaState } = useMfaActions();
    react.exports.useEffect(() => {
        enrollMfa();
        return resetMfaState;
    }, [enrollMfa, resetMfaState]);
    react.exports.useEffect(() => {
        if (step !== MFAStep.verify && step !== MFAStep.recoveryCode) {
            props.onClose();
        }
    }, [step, props]);
    return React.createElement(React.Fragment, null,
        React.createElement(Slide$1, { in: step === MFAStep.verify, appear: false, exit: false, unmountOnExit: true, direction: step === MFAStep.verify ? 'left' : 'right' },
            React.createElement(VerifyMfaForm, Object.assign({}, props))),
        React.createElement(Slide$1, { in: step === MFAStep.recoveryCode, mountOnEnter: true, unmountOnExit: true, direction: step === MFAStep.recoveryCode ? 'left' : 'right' },
            React.createElement(RecoveryMfaForm, Object.assign({}, props))));
};
const EnableMfaDialog = props => {
    const { injector } = useShadowDom();
    const t = useT('privacy_EnableMfa');
    return React.createElement(Dialog$1, Object.assign({ "data-test-id": "enableMfa", container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title'), size: 'sm' }),
        React.createElement(EnableMfaStepper, Object.assign({}, props)));
};

const TokenInput = react.exports.memo(() => {
    const t = useT('privacy_DisableMfa');
    const [fieldProps, { error, touched }] = useField('token');
    return React.createElement(Input$1$1, Object.assign({}, fieldProps, { autoFocus: true, inputMode: 'numeric', "data-test-id": "6DigitsCode", label: t('tokenInputLabel'), placeholder: t('tokenInputLabelPlaceholder'), error: !!error && touched, errorMessage: error, autoComplete: 'one-time-code' }));
});
const DisableMfaForm = (props) => {
    const t = useT('privacy_DisableMfa');
    const { disableMfa, resetMfaState } = useMfaActions();
    react.exports.useEffect(() => resetMfaState, [resetMfaState]);
    const initialValues = react.exports.useMemo(() => ({ token: '' }), []);
    const validationSchema = react.exports.useMemo(() => validateSchema({ token: validateMinLength(6, t('codeIsRequired'), t('codeLengthAtLeast6')) }), [t]);
    const formikProps = {
        onSubmit: ({ token }, { setErrors }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, (e) => {
                setErrors({ token: e.message });
                reject();
            }, props.onClose);
            disableMfa({ token, callback });
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(Box, { "data-test-id": "disableMfabtn", mb: 4, component: Typography$1, variant: 'subtitle2' }, t('description')),
                React.createElement(TokenInput, null)),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Button$1, { "data-test-id": "cancel", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "submit", disabled: !canSubmit, loading: isSubmitting, color: 'danger', type: 'submit' }, t('disable'))));
    });
};
const DisableMfaDialog = props => {
    const { injector } = useShadowDom();
    const t = useT('privacy_DisableMfa');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title'), size: 'sm' }),
        React.createElement(DisableMfaForm, Object.assign({}, props)));
};

const getIpMetadata = (ip) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        return yield fetch.Get(`/metadata/ip/${ip}`);
    }
    catch (e) {
        throw new Error(`ip metadata not found`);
    }
});
const getFilterType = (type) => {
    switch (type) {
        case 'Timestamp':
            return 'select';
        case 'Severity':
            return 'select';
        default:
            return 'input';
    }
};
const capitalize = (s) => {
    // noinspection SuspiciousTypeOfGuard
    if (typeof s !== 'string')
        return `${s}`;
    return s.charAt(0).toUpperCase() + s.slice(1);
};
const getFilterName = (name) => {
    switch (name) {
        case 'createdAt':
            return 'Time';
        default:
            return capitalize(name);
    }
};
//TODO: wrong items order in selector
const timeOptions = [
    { label: 'Last Day', value: 'last_day' },
    { label: 'Last Week', value: 'last_week' },
    { label: 'Last Month', value: 'last_month' },
    { label: 'Last Year', value: 'last_year' },
];
const severityOptions = [
    { label: 'Info', value: 'Info' },
    { label: 'Medium', value: 'Medium' },
    { label: 'High', value: 'High' },
    { label: 'Critical', value: 'Critical' },
];
const getTimeDiff = (time) => {
    const diff = differenceInDays(new Date(), parseISO(time));
    return diff <= 1 ? 'last_day' : diff <= 7 ? 'last_week' : diff <= 30 ? 'last_month' : 'last_year';
};
const getFilterTime = (time) => {
    let value;
    const date = new Date();
    switch (time) {
        case 'last_day':
            value = subDays(date, 1).toISOString();
            break;
        case 'last_week':
            value = subDays(date, 7).toISOString();
            break;
        case 'last_month':
            value = subMonths(date, 1).toISOString();
            break;
        case 'last_year':
            value = subYears(date, 1).toISOString();
            break;
        default:
            value = date.toISOString();
    }
    return { $gt: value };
};
const getSeverityByName = (severity) => {
    switch (severity === null || severity === void 0 ? void 0 : severity.toLowerCase()) {
        case 'info':
            return 'info';
        case 'error':
            return 'error';
        case 'attention':
            return 'warning';
        case 'high':
            return 'warning';
        default:
            return 'info';
    }
};
const str2bool = (str) => {
    var _a;
    const value = (_a = str === null || str === void 0 ? void 0 : str.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(str);
    if (!value) {
        return false;
    }
    switch (value) {
        case 'yes':
        case 'always':
            return true;
        default:
            return false;
    }
};

const UserSessionsTableColumns = ({ t }) => [
    {
        Header: t('deviceHeader'),
        accessor: ({ userAgent, current }) => ({ userAgent, current, endAdornment: current ? React.createElement(Chip, { label: t('currentSessionChip'), sx: { backgroundColor: 'success.light', color: 'success.main' } }) : undefined }),
        minWidth: 280,
        maxWidth: 280,
        Cell: TableUserAgentCell,
    },
    {
        Header: t('locationHeader'),
        accessor: ({ ipAddress }) => ({ ip: ipAddress, getIpMetadata }),
        Cell: TableLocationCell,
        width: 200,
        maxWidth: 200,
    },
    {
        Header: t('ipAddressHeader'),
        accessor: ({ ipAddress }) => ({ description: ipAddress }),
        minWidth: 200,
        maxWidth: 200,
        Cell: TableTextCell,
    },
    {
        Header: t('timeHeader'),
        accessor: ({ createdAt }) => ({ date: createdAt, withAgo: true }),
        minWidth: 200,
        maxWidth: 200,
        Cell: TableDateCell,
    },
    {
        Header: () => React.createElement(Box, { width: '1rem' }),
        id: `logOut`,
        accessor: ({ id, current }) => ({ id, current, actionText: t('logout') }),
        minWidth: 180,
        maxWidth: 180,
        Cell: TableLogoutCell,
    },
];

const DeleteDialogBody = ({ error, description, loading, onDelete, onClose, deleteButtonText, cancelButtonText }) => {
    //TODO change data test id cancelBtn to cancel-btn
    //TODO change data test id deleteBtn to delete-btn
    return (React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, null,
            React.createElement(Typography$1, { variant: "subtitle2Light" }, description),
            React.createElement(FormErrorDialogMessage, { message: error })),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(Box, { flex: 1 }),
            cancelButtonText &&
                React.createElement(Button$1, { "data-test-id": "cancel-btn", color: "inherit", variant: "text", onClick: onClose }, cancelButtonText),
            React.createElement(Button$1, { "data-test-id": "delete-btn", loading: loading, color: "danger", onClick: onDelete }, deleteButtonText))));
};
const DeleteDialog = (_a) => {
    var { onClose, title, open, dataTestId } = _a, props = __rest(_a, ["onClose", "title", "open", "dataTestId"]);
    const { injector } = useShadowDom();
    return (React.createElement(Dialog$1, { "data-test-id": dataTestId, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, open: open, onClose: onClose, title: title },
        React.createElement(DeleteDialogBody, Object.assign({}, props, { onClose: onClose }))));
};

const LogOutAllDialog = ({ onClose, open }) => {
    const t = useT('privacy_UserSessions');
    const [submitted, setSubmitted] = react.exports.useState(false);
    const { loading, error } = useSessionsState();
    const { deleteAllUserSessions } = useSessionsActions();
    react.exports.useEffect(() => {
        if (submitted && !error && !loading) {
            onClose();
        }
    }, [submitted, error, loading, onClose]);
    const handleLogoutAll = react.exports.useCallback(() => {
        deleteAllUserSessions();
        setSubmitted(true);
    }, [setSubmitted, deleteAllUserSessions]);
    return (React.createElement(DeleteDialog, { dataTestId: 'logoutAllDialog', title: t('logoutAllDialogTitle'), deleteButtonText: t('logoutAllDialogAcceptButton'), description: t('logoutAllDialogText'), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleLogoutAll }));
};

const useUserSessionsData = () => {
    const { sessions } = useSessionsState();
    return react.exports.useMemo(() => sessions.filter(({ userAgent }) => !(userAgent === null || userAgent === void 0 ? void 0 : userAgent.toLowerCase().includes('axios'))).sort((a, b) => Number(b.current) - Number(a.current)), [sessions]);
};

const UsersSessionsTableHeader = () => {
    const t = useT('privacy_UserSessions');
    const [isLogoutAllDialogOpen, handleCloseLogOutAllDialog, handleOpenLogOutAllDialog] = useDialogState();
    const sessions = useUserSessionsData();
    const isLogoutButtonVisible = react.exports.useMemo(() => (sessions === null || sessions === void 0 ? void 0 : sessions.length) > 1, [sessions]);
    return React.createElement(React.Fragment, null,
        React.createElement(Grid, { container: true, display: 'flex', alignItems: 'center', mb: 2 },
            React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
                React.createElement(Typography$1, { variant: 'subtitle1' },
                    " ",
                    t('loginSessionsTitle'))),
            React.createElement(Grid, { item: true, xs: true }),
            React.createElement(Grid, { item: true }, isLogoutButtonVisible && React.createElement(Button$1, { "data-test-id": "delete-sessions-btn", color: 'inherit', onClick: handleOpenLogOutAllDialog }, t('logoutAllButtonText')))),
        React.createElement(LogOutAllDialog, { onClose: handleCloseLogOutAllDialog, open: isLogoutAllDialogOpen }));
};

const UserSessionsTable = () => {
    const t = useT('privacy_UserSessions');
    const { loadUserSessions } = useSessionsActions();
    const { loading } = useSessionsState();
    const rows = useUserSessionsData();
    react.exports.useEffect(() => {
        loadUserSessions();
    }, [loadUserSessions]);
    const columns = react.exports.useMemo(() => UserSessionsTableColumns({
        t,
    }), [t]);
    return (React.createElement(Box, { mt: 6, flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(UsersSessionsTableHeader, null),
        React.createElement(Table, { "data-test-id": "table", columns: columns, data: rows, loading: !!loading })));
};

const PrivacyPage$1 = () => {
    const t = useT('privacy');
    const [changePasswordDialog, handleCloseChangePassword, handleOpenChangePassword] = useDialogState();
    const [enableMfaDialog, handleCloseEnableMfaDialog, handleOpenEnableMfaDialog] = useDialogState();
    const [disableMfaDialog, handleCloseDisableMfaDialog, handleOpenDisableMfaDialog] = useDialogState();
    const user = useAuthUser();
    const { policy, loading: loadingPolicy } = usePublicPolicySettings();
    const mfaPolicy = useMfaPolicySettings();
    usePasswordConfig(user.id);
    const isMfaForced = mfaPolicy.policy && mfaPolicy.policy.enforceMFAType !== 'DontForce';
    const items = react.exports.useMemo(() => [
        ...(!loadingPolicy && (policy === null || policy === void 0 ? void 0 : policy.authStrategy) === 'EmailAndPassword' ? [{
                id: 'password',
                title: t('passwordTitle'),
                value: '',
                onEditClick: handleOpenChangePassword,
            }] : []),
        {
            id: 'multiFactorAuthentication',
            title: t('mfaTitle'),
            value: mfaPolicy.loading ?
                React.createElement(Skeleton, { width: 80, height: 18 })
                : isMfaForced ? (React.createElement(Typography$1, { variant: 'label' },
                    t('mfaRequired'),
                    React.createElement(HelpMessage, { message: t('mfaHelpMessage') }))) :
                    user.mfaEnrolled ? t('mfaEnabled') : t('mfaDisabled'),
            actions: React.createElement(Switch$1, { "data-test-id": "Switch", disabled: isMfaForced, checked: !mfaPolicy.loading && (isMfaForced || user.mfaEnrolled), onChange: e => {
                    if (e.target.checked) {
                        handleOpenEnableMfaDialog();
                    }
                    else {
                        handleOpenDisableMfaDialog();
                    }
                } }),
        }
    ], [user, t, handleOpenChangePassword, handleOpenEnableMfaDialog, handleOpenDisableMfaDialog, mfaPolicy.loading, isMfaForced, policy, loadingPolicy]);
    return React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(SettingsList, { title: t('basicSettings'), items: items }),
        React.createElement(Box, { mt: 6, flex: 1, display: 'flex', flexDirection: 'column' },
            React.createElement(UserSessionsTable, null)),
        React.createElement(ChangePasswordDialog, { open: changePasswordDialog, onClose: handleCloseChangePassword }),
        React.createElement(EnableMfaDialog, { open: enableMfaDialog, onClose: handleCloseEnableMfaDialog }),
        React.createElement(DisableMfaDialog, { open: disableMfaDialog, onClose: handleCloseDisableMfaDialog }));
};
var PrivacyPage$2 = PrivacyPage$1;

var PrivacyPage = wrapPage(PrivacyPage$2, 'privacy');

const TimezoneField = () => {
    const { injector } = useShadowDom();
    const t = useT('accountSettings_EditTimezone');
    const [search, setSearch] = react.exports.useState('');
    const [fieldProps, { error, touched }, { setValue }] = useField('timezone');
    const handleSearchChanged = react.exports.useCallback((str) => __awaiter(void 0, void 0, void 0, function* () { return setSearch((str !== null && str !== void 0 ? str : '').toLowerCase().trim()); }), [setSearch]);
    const options = react.exports.useMemo(() => {
        let data = getOptions();
        if (search) {
            return data.filter(({ label }) => label.toLowerCase().indexOf(search) !== -1);
        }
        return data;
    }, [search]);
    return React.createElement(Select$1$1, { value: fieldProps.value, "data-test-id": "timezone-dropdown", onChange: (value) => setValue(value, true), errorMessage: touched ? error : undefined, options: options, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, label: t('timezoneInputLabel'), onSearch: handleSearchChanged });
};
const EditTimezoneForm = (props) => {
    const t = useT('accountSettings_EditTimezone');
    const { saveAccountSettings } = useAuthActions();
    const { accountSettingsState: settings } = useAuth();
    const initialValues = react.exports.useMemo(() => {
        var _a;
        return ({
            timezone: (_a = settings.timezone) !== null && _a !== void 0 ? _a : '',
        });
    }, [settings.timezone]);
    const validationSchema = react.exports.useMemo(() => validateSchema({}), []);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, props.onClose);
            saveAccountSettings(Object.assign(Object.assign(Object.assign({}, settings), values), { callback }));
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(TimezoneField, null),
                React.createElement(FormErrorDialogMessage, { fieldName: "timezone", message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditTimezoneDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('accountSettings_EditTimezone');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title'), size: 'sm' }),
        React.createElement(EditTimezoneForm, Object.assign({}, props)));
};

const EditCompanyNameDialog = (props) => {
    const t = useT('accountSettings_EditCompanyName');
    const { saveAccountSettings } = useAuthActions();
    const { accountSettingsState: settings } = useAuth();
    const { loadTenants } = useTenantsActions();
    const validationSchema = react.exports.useMemo(() => validateSchema({
        companyName: validateNotEmpty(t('companyNameIsRequired')),
    }), [t]);
    const submitHandler = react.exports.useCallback((values) => new Promise((resolve, reject) => {
        const callback = callbackToPromise(resolve, reject, () => {
            loadTenants();
            props.onClose();
        });
        saveAccountSettings(Object.assign(Object.assign({}, settings), { name: values.companyName, callback }));
    }), [props, saveAccountSettings, settings, loadTenants]);
    return React.createElement(EditSingleInputDialog, { title: t('title'), onClose: props.onClose, open: props.open, validationSchema: validationSchema, inputName: 'companyName', inputLabel: t('companyNameLabel'), submitButton: t('save'), cancelButton: ('cancel'), initialValues: {
            companyName: settings.name,
        }, 
        // TODO: changed test-id from editName to companyName-box
        onSubmit: submitHandler });
};

const getAccountAddress = (address, key) => {
    let parsedAddress = {};
    try {
        parsedAddress = JSON.parse(address);
    }
    catch (e) {
        // ignore address data parse error
    }
    return key ? getValue$1(parsedAddress, key) : parsedAddress;
};
const addAddress = (address, newAddress) => {
    let parsedAddress = {};
    try {
        parsedAddress = JSON.parse(address);
    }
    catch (e) {
        // ignore address data parse error
    }
    return JSON.stringify(Object.assign(Object.assign({}, parsedAddress), newAddress));
};

const CustomCountryField$1 = () => {
    const t = useT('accountSettings_EditAddress');
    return React.createElement(CountryField, { label: t('countryInputLabel'), placeholder: t('countryInputPlaceholder') });
};
const Address1Field$1 = () => {
    const t = useT('accountSettings_EditAddress');
    return React.createElement(Field, { autoComplete: 'street-address', name: 'address1', label: t('address1InputLabel') });
};
const Address2Field$1 = () => {
    const t = useT('accountSettings_EditAddress');
    return React.createElement(Field, { autoComplete: 'address-level3', name: 'address2', label: t('address2InputLabel') });
};
const CityField$1 = () => {
    const t = useT('accountSettings_EditAddress');
    return React.createElement(Field, { autoComplete: 'address-level2', name: 'city', label: t('cityInputLabel') });
};
const StateField$1 = () => {
    const t = useT('accountSettings_EditAddress');
    return React.createElement(Field, { autoComplete: 'address-level1', name: 'state', label: t('stateInputLabel') });
};
//TODO change postCode to postcode
const PostcodeField$1 = () => {
    const t = useT('accountSettings_EditAddress');
    return React.createElement(Field, { autoComplete: 'postal-code', name: 'postCode', label: t('postCodeInputLabel') });
};
const EditAddressForm = (props) => {
    const t = useT('accountSettings_EditAddress');
    const { saveAccountSettings } = useAuthActions();
    const { accountSettingsState: settings } = useAuth();
    const initialValues = react.exports.useMemo(() => {
        var _a, _b, _c, _d, _e;
        return ({
            address1: (_a = getAccountAddress(settings.address, 'address1')) !== null && _a !== void 0 ? _a : '',
            address2: (_b = getAccountAddress(settings.address, 'address2')) !== null && _b !== void 0 ? _b : '',
            city: (_c = getAccountAddress(settings.address, 'city')) !== null && _c !== void 0 ? _c : '',
            state: (_d = getAccountAddress(settings.address, 'state')) !== null && _d !== void 0 ? _d : '',
            postCode: (_e = getAccountAddress(settings.address, 'postCode')) !== null && _e !== void 0 ? _e : '',
            country: getAccountAddress(settings.address, 'country'),
        });
    }, [settings.address]);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        address1: validateNotEmpty(t('address1IsRequired')),
        city: validateNotEmpty(t('cityIsRequired')),
        postCode: validationPostCodeOptional(t('postCodeIsInvalid')),
        country: validateNotEmpty(t('countryIsRequired')),
    }), [t]);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const newAddress = addAddress(settings.address, values);
            const callback = callbackToPromise(resolve, reject, props.onClose);
            saveAccountSettings(Object.assign(Object.assign({}, settings), { address: newAddress, callback }));
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(CustomCountryField$1, null),
                React.createElement(Address1Field$1, null),
                React.createElement(Address2Field$1, null),
                React.createElement(CityField$1, null),
                React.createElement(StateField$1, null),
                React.createElement(PostcodeField$1, null),
                React.createElement(FormErrorDialogMessage, { fieldName: "address", message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditAddressDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('accountSettings_EditAddress');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title') }),
        React.createElement(EditAddressForm, Object.assign({}, props)));
};

const EditWebsiteDialog = (props) => {
    var _a;
    const t = useT('accountSettings_EditWebsite');
    const { saveAccountSettings } = useAuthActions();
    const { accountSettingsState: settings } = useAuth();
    const submitHandler = react.exports.useCallback((values) => new Promise((resolve, reject) => {
        const callback = callbackToPromise(resolve, reject, props.onClose);
        saveAccountSettings(Object.assign(Object.assign(Object.assign({}, settings), values), { callback }));
    }), [props.onClose, saveAccountSettings, settings]);
    return React.createElement(EditSingleInputDialog, { title: t('title'), onClose: props.onClose, open: props.open, inputName: 'website', inputLabel: t('websiteInputLabel'), submitButton: t('save'), cancelButton: ('cancel'), inputAutoComplete: 'organization-title', initialValues: {
            website: (_a = settings.website) !== null && _a !== void 0 ? _a : ' ',
        }, onSubmit: submitHandler, "data-test-id": "website-box" });
};

const currencies = [
    { label: 'USD', value: 'USD' },
    { label: 'EUR', value: 'EUR' },
];
const CurrencyField = () => {
    const { injector } = useShadowDom();
    const t = useT('accountSettings_EditCurrency');
    const [fieldProps, { error, touched }, { setValue }] = useField('currency');
    return React.createElement(Select$1$1, { value: fieldProps.value, "data-test-id": "currency-dropdown", onChange: (value) => setValue(value, true), errorMessage: touched ? error : undefined, options: currencies, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, label: t('currencyLabel') });
};
const EditCurrencyForm = (props) => {
    const t = useT('accountSettings_EditCurrency');
    const { saveAccountSettings } = useAuthActions();
    const { accountSettingsState: settings } = useAuth();
    const initialValues = react.exports.useMemo(() => ({
        currency: settings.currency,
    }), [settings.currency]);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, props.onClose);
            saveAccountSettings(Object.assign(Object.assign(Object.assign({}, settings), values), { callback }));
        }),
        initialValues,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(CurrencyField, null),
                React.createElement(FormErrorDialogMessage, { fieldName: "currency", message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditCurrencyDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('accountSettings_EditCurrency');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title'), size: 'sm' }),
        React.createElement(EditCurrencyForm, Object.assign({}, props)));
};

const SettingsRowValue = ({ value, noValueText, dataTestId, onClick }) => {
    const t = useT('accountSettings');
    if (value) {
        return React.createElement(Typography$1, { variant: 'body1', "data-test-id": `${dataTestId}-value`, component: 'span' }, value);
    }
    if (noValueText) {
        return React.createElement(Typography$1, { variant: 'body1Bold' },
            React.createElement(Link$1, { "data-test-id": `add-${dataTestId}`, onClick: onClick }, t(noValueText)));
    }
    return null;
};
const AccountDetailsPage$1 = () => {
    const t = useT('accountSettings');
    const { loadAccountSettings } = useAuthActions();
    const { accountSettingsState: settings } = useAuth();
    react.exports.useEffect(() => loadAccountSettings(), [loadAccountSettings]);
    const [editCompanyName, handleCloseCompanyName, handleOpenCompanyName] = useDialogState();
    const [editAddress, handleCloseAddress, handleOpenAddress] = useDialogState();
    const [editWebsite, handleCloseWebsite, handleOpenWebsite] = useDialogState();
    const [editTimezone, handleCloseTimezone, handleOpenTimezone] = useDialogState();
    const [editCurrency, handleCloseCurrency, handleOpenCurrency] = useDialogState();
    const user = useAuthUserOrNull();
    const tenantsState = useTenantsState();
    const tenants = tenantsState.tenants;
    const tenantName = react.exports.useMemo(() => {
        var _a, _b;
        return (_b = (_a = tenants.find(({ tenantId }) => tenantId === (user === null || user === void 0 ? void 0 : user.tenantId))) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';
    }, [tenants, user === null || user === void 0 ? void 0 : user.tenantId]);
    const items = react.exports.useMemo(() => {
        var _a, _b;
        const companyAddress = formatAddress(getAccountAddress(settings.address));
        const companyTimezone = (_b = (_a = getOptions().find(s => s.value === settings.timezone)) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : '';
        return [{
                id: 'companyName',
                title: t('companyName'),
                value: React.createElement(SettingsRowValue, { value: settings.name || tenantName, onClick: handleOpenCompanyName, dataTestId: 'companyName', noValueText: 'addCompanyButton' }),
                onEditClick: settings.name ? handleOpenCompanyName : undefined,
                testId: 'account-details-companyName-list-item'
            }, {
                id: 'address',
                title: t('address'),
                value: React.createElement(SettingsRowValue, { value: companyAddress, onClick: handleOpenAddress, dataTestId: "address", noValueText: 'addAddressButton' }),
                onEditClick: companyAddress ? handleOpenAddress : undefined,
                testId: 'account-details-address-list-item'
            }, {
                id: 'website',
                title: t('website'),
                value: React.createElement(SettingsRowValue, { value: settings.website, onClick: handleOpenWebsite, dataTestId: "website", noValueText: 'addWebsiteButton' }),
                onEditClick: settings.website ? handleOpenWebsite : undefined,
                testId: 'account-details-website-list-item'
            }, {
                id: 'timezone',
                title: t('timezone'),
                value: React.createElement(SettingsRowValue, { value: companyTimezone, onClick: handleOpenTimezone, dataTestId: "timezone", noValueText: 'setTimezoneButton' }),
                onEditClick: companyTimezone ? handleOpenTimezone : undefined,
                testId: 'account-details-timezone-list-item'
            }, {
                id: 'currency',
                title: t('currency'),
                value: React.createElement(SettingsRowValue, { value: settings.currency, onClick: handleOpenCurrency, dataTestId: 'currency', noValueText: 'setCurrencyButton' }),
                onEditClick: settings.currency ? handleOpenCurrency : undefined,
                testId: 'account-details-currency-list-item'
            }];
    }, [t, handleOpenAddress, handleOpenCompanyName, handleOpenCurrency,
        handleOpenTimezone, handleOpenWebsite, settings.address,
        settings.currency, settings.name, settings.timezone, settings.website, tenantName,
    ]);
    return React.createElement(PageWrapper, null,
        React.createElement(SettingsList, { title: t('subtitle'), items: items }),
        React.createElement(EditCurrencyDialog, { "data-test-id": "editCurrency", open: editCurrency, onClose: handleCloseCurrency }),
        React.createElement(EditTimezoneDialog, { "data-test-id": "editTimezone", open: editTimezone, onClose: handleCloseTimezone }),
        React.createElement(EditCompanyNameDialog, { "data-test-id": "editCompanyName", open: editCompanyName, onClose: handleCloseCompanyName }),
        React.createElement(EditAddressDialog, { "data-test-id": "editAddress", open: editAddress, onClose: handleCloseAddress }),
        React.createElement(EditWebsiteDialog, { "data-test-id": "editWebsite", open: editWebsite, onClose: handleCloseWebsite }));
};
var AccountDetailsPage$2 = AccountDetailsPage$1;

var AccountDetailsPage = wrapPage(AccountDetailsPage$2, 'accountSettings');

const UsersHeader = ({ handleOpenInviteUser, isInviteWithEmailEnabled, isInviteLinkEnabled }) => {
    const t = useT('users');
    const { onSearch } = useTableSearch();
    const [search, setSearch] = react.exports.useState('');
    const debounceSearch = useDebounce(search);
    const canInviteUser = usePermission('fe.secure.write.users') && (isInviteWithEmailEnabled || isInviteLinkEnabled);
    const { events } = useShadowDom();
    const { email } = useAuthUser();
    const handleClickOnInviteUser = react.exports.useCallback(() => {
        var _a;
        handleOpenInviteUser === null || handleOpenInviteUser === void 0 ? void 0 : handleOpenInviteUser();
        (_a = events === null || events === void 0 ? void 0 : events.inviteMemberClicked) === null || _a === void 0 ? void 0 : _a.call(events, { email });
    }, []);
    useAsyncEffect(() => onSearch(debounceSearch), [debounceSearch]);
    return React.createElement(Grid, { container: true, spacing: 4 },
        React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
            React.createElement(Box, null,
                React.createElement(Input$1$1, { "data-test-id": "searchBox", endAdornment: React.createElement(SearchIcon, null), onChange: (e) => setSearch(e.target.value), placeholder: t('searchInputPlaceholder') }))),
        React.createElement(Grid, { item: true, xs: true }),
        canInviteUser && React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": "invite-user-btn", onClick: handleClickOnInviteUser }, t('inviteUserButton'))));
};

const usersTableColumns = ({ t, user, rolesMap, container }) => [
    {
        Header: () => React.createElement(Box, { width: '2rem' }),
        accessor: ({ name, profileImageUrl, profilePictureUrl }) => ({ name, picture: profilePictureUrl !== null && profilePictureUrl !== void 0 ? profilePictureUrl : profileImageUrl }),
        width: '2rem',
        id: 'id',
        Cell: TableAvatarCell,
    },
    Object.assign(Object.assign({ Header: t('userHeader'), accessor: ({ id, name, email }) => ({ title: `${name} ${id === user.id ? `(${t('meTooltip')})` : ''}`, description: email }) }, (rolesMap && Object.keys(rolesMap).length > 0 ? { width: 260, maxWidth: 260 } : { minWidth: 260 })), { Cell: TableTextCell }),
    rolesMap && Object.keys(rolesMap).length > 0 && {
        Header: t('rolesHeader'),
        accessor: ({ roleIds }) => ({ items: roleIds.map(v => ({ text: rolesMap[v] })), max: 2, container }),
        minWidth: 300,
        Cell: TableChipsCell,
    },
    {
        Header: t('joinedHeader'),
        accessor: ({ createdAt, verified, activatedForTenant }) => ({ date: createdAt, verified, activatedForTenant }),
        width: 160,
        maxWidth: 160,
        Cell: (props) => {
            return !props.value.activatedForTenant
                ? React.createElement(Chip, { color: "secondary", label: t('pendingApprovalStatus') })
                : !props.value.verified
                    ? React.createElement(Chip, { color: "secondary", label: t('pendingActivationStatus') })
                    : React.createElement(TableDateCell, Object.assign({}, props));
        },
    },
    {
        Header: t('lastSeenHeader'),
        accessor: ({ lastLogin }) => ({ date: lastLogin }),
        width: 160,
        maxWidth: 160,
        Cell: TableDateCell,
    },
].filter(notNull);
const LEAVE_TEAM_OPTION = false;
const useUsersTableRowActions$1 = ({ container, resendActivationLink, resendInvitationLink, handleOpenDeleteUser, handleOpenEditUserRoles, revokeUserSessions, currentTenantId, subTenants }) => {
    const t = useT('users');
    const user = useAuthUserOrNull();
    const canEditRoles = usePermission('fe.secure.write.users');
    const canDeleteUser = usePermission('fe.secure.delete.users');
    const canRevokeUserSessions = usePermission('fe.secure.delete.sessions');
    //TODO: add virified type to ITeamUser
    return react.exports.useMemo(() => (row) => {
        var _a;
        const items = [];
        const handleEditRole = () => {
            handleOpenEditUserRoles(row);
        };
        const handleSendActivationLink = () => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            resendActivationLink({ userId: row.id, callback });
        });
        const handleRevokeUserSessions = () => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            revokeUserSessions({ userId: row.id, callback });
        });
        const handleSendInvitationLink = () => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            const invitationData = __rest(row, ["id"]);
            resendInvitationLink(Object.assign(Object.assign({}, invitationData), { callback }));
        });
        const handleDeleteUser = () => {
            handleOpenDeleteUser(row);
        };
        const isMe = row.id === (user === null || user === void 0 ? void 0 : user.id);
        const canEditSubTenantUser = !(subTenants === null || subTenants === void 0 ? void 0 : subTenants.length) || ((_a = row.tenants) === null || _a === void 0 ? void 0 : _a.find((tenant) => tenant.tenantId === currentTenantId));
        if (!isMe && canEditRoles && canEditSubTenantUser) {
            items.push({
                icon: React.createElement(EditIcon, { "data-test-id": "editBtn" }),
                onClick: handleEditRole,
                text: t('editRolesAction'),
            });
        }
        if (canEditSubTenantUser) {
            if (!row.activatedForTenant) {
                // add to tenant by addUser
                items.push({
                    icon: React.createElement(ResendIcon, { "data-test-id": "resendInvitationBtn" }),
                    onClick: handleSendInvitationLink,
                    text: t('resendInvitationAction'),
                });
            }
            else if (!row.verified) {
                items.push({
                    icon: React.createElement(ResendIcon, { "data-test-id": "resendBtn" }),
                    onClick: handleSendActivationLink,
                    text: t('resendActivationAction'),
                });
            }
        }
        if (!isMe && row.activatedForTenant && canRevokeUserSessions) {
            items.push({
                icon: React.createElement(CloseIcon, { "data-test-id": "revokeBtn" }),
                onClick: handleRevokeUserSessions,
                text: t('logOutUserSessionsActions'),
            });
        }
        if ((!isMe || LEAVE_TEAM_OPTION) && canDeleteUser && canEditSubTenantUser) {
            items.push({
                icon: React.createElement(DeleteIcon, { "data-test-id": "deleteBtn" }),
                onClick: handleDeleteUser,
                text: isMe ? t('leaveTeamAction') : t('deleteUserAction'),
                negative: true,
            });
        }
        return { items, container };
    }, [t, user, container, canEditRoles, canDeleteUser, canRevokeUserSessions, revokeUserSessions, resendActivationLink, resendInvitationLink, handleOpenDeleteUser, handleOpenEditUserRoles, subTenants, currentTenantId]);
};

const usersTableColumnsOrganization = ({ t, user, subTenants, forcePermissions, container, currentTenantName, currentTenantId }) => [
    {
        Header: () => React.createElement(Box, { width: '2rem' }),
        accessor: ({ name, profileImageUrl, profilePictureUrl }) => ({ name, picture: profilePictureUrl !== null && profilePictureUrl !== void 0 ? profilePictureUrl : profileImageUrl }),
        width: '2rem',
        id: 'id',
        Cell: TableAvatarCell,
    },
    Object.assign(Object.assign({ Header: t('userHeader'), accessor: ({ id, name, email }) => ({ title: `${name} ${id === user.id ? `(${t('meTooltip')})` : ''}`, description: email }) }, (forcePermissions ? { width: 260, maxWidth: 260 } : { minWidth: 260 })), { Cell: TableTextCell }),
    subTenants && {
        Header: t('organizationHeader'),
        accessor: ({ tenants }) => {
            var _a;
            const items = (_a = tenants === null || tenants === void 0 ? void 0 : tenants.map((tenant) => {
                var _a;
                let text = (_a = subTenants.find((subTenant) => subTenant.tenantId === tenant.tenantId)) === null || _a === void 0 ? void 0 : _a.tenantName;
                if (!text && tenant.tenantId === currentTenantId) {
                    text = currentTenantName;
                }
                const subItems = forcePermissions ? tenant.roles.map((role) => role.name) : [];
                return { text, subItems };
            })) !== null && _a !== void 0 ? _a : [];
            return { items: items.filter((item) => item.text), max: 1, container };
        },
        minWidth: 300,
        Cell: TableChipsCell,
    },
    {
        Header: t('joinedHeader'),
        accessor: ({ createdAt, verified, activatedForTenant }) => ({ date: createdAt, verified, activatedForTenant }),
        width: 160,
        maxWidth: 160,
        Cell: (props) => {
            return !props.value.activatedForTenant
                ? React.createElement(Chip, { color: "secondary", label: t('pendingApprovalStatus') })
                : !props.value.verified
                    ? React.createElement(Chip, { color: "secondary", label: t('pendingActivationStatus') })
                    : React.createElement(TableDateCell, Object.assign({}, props));
        },
    },
    {
        Header: t('lastSeenHeader'),
        accessor: ({ lastLogin }) => ({ date: lastLogin }),
        width: 160,
        maxWidth: 160,
        Cell: TableDateCell,
    },
].filter(notNull);

const RolesField$3 = () => {
    const t = useT('users_EditUserRoles');
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue }] = useField('roleIds');
    const roles = useAuthTeamState(state => state.roles);
    const currentUserRoleLevel = getUserMaxRoleLevel(roles);
    const options = react.exports.useMemo(() => (roles !== null && roles !== void 0 ? roles : []).filter(role => {
        var _a;
        if (currentUserRoleLevel > ((_a = role.permissionLevel) !== null && _a !== void 0 ? _a : Infinity)) {
            return fieldProps.value.indexOf(role.id) !== -1;
        }
        return true;
    }).map(role => {
        var _a;
        return ({
            label: role.name,
            value: role.id,
            withCheckbox: true,
            disabled: currentUserRoleLevel > ((_a = role.permissionLevel) !== null && _a !== void 0 ? _a : Infinity),
        });
    }), [roles, currentUserRoleLevel, fieldProps.value]);
    return React.createElement(Select$1$1, { label: t('selectRolesLabel'), "data-test-id": "editRoleDropdown", name: 'roleIds', multi: true, placeholder: t('selectRolesPlaceholder'), value: fieldProps.value, onChange: (value) => setValue(value, true), errorMessage: touched ? error : undefined, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options });
};
const EditUserRolesForm = (props) => {
    const t = useT('users_EditUserRoles');
    const { updateUser } = useAuthTeamActions();
    const user = useMemoProps(props, 'user');
    const initialValues = react.exports.useMemo(() => ({
        fullName: user.name,
        email: user.email,
        roleIds: user.roleIds,
    }), [user]);
    const formikProps = {
        onSubmit: ({ email, roleIds }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, props.onClose);
            updateUser({ id: user.id, email, roleIds, callback });
        }),
        initialValues,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(RolesField$3, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "updateBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('update'))));
    });
};
const EditUserRolesDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('users_EditUserRoles');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title') }),
        React.createElement(EditUserRolesForm, Object.assign({}, props)));
};

const DeleteUserDialog$1 = ({ onClose, open, user }) => {
    const t = useT('users_DeleteUser');
    const [loading, setLoading] = react.exports.useState(false);
    const [error, setError] = react.exports.useState(null);
    const { deleteUser } = useAuthTeamActions();
    const callback = react.exports.useCallback((success, error) => {
        if (error) {
            setError(error);
        }
        else {
            onClose();
        }
        setLoading(false);
    }, [setLoading, setError, onClose]);
    const handleDeleteUser = react.exports.useCallback(() => {
        setLoading(true);
        setError(null);
        deleteUser({ userId: user === null || user === void 0 ? void 0 : user.id, callback });
    }, [user === null || user === void 0 ? void 0 : user.id, callback, setLoading, setError, deleteUser]);
    return (React.createElement(DeleteDialog, { dataTestId: 'deleteUserBtn', title: t('title'), cancelButtonText: t('cancel'), deleteButtonText: t('delete'), description: React.createElement(React.Fragment, null,
            t('areYouSureDeleteUser1'),
            " ",
            React.createElement("strong", null, user === null || user === void 0 ? void 0 : user.name),
            "? ",
            t('areYouSureDeleteUser2')), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleDeleteUser }));
};

const UsersTable = () => {
    const t = useT('users');
    const { injector } = useShadowDom();
    const container = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl;
    const user = useAuthUser();
    const { revokeUserSessions } = useSessionsActions();
    const { loaders, users, roles, permissions, totalPages, pageOffset, filter } = useAuthTeamState();
    const { resendActivationLink, loadUsers, resendInvitationLink } = useAuthTeamActions();
    const [deleteUserDialog, handleCloseDeleteUser, handleOpenDeleteUser, deleteUserData] = useDialogState();
    const [editUserRolesDialog, handleCloseEditUserRoles, handleOpenEditUserRoles, editUserRolesData] = useDialogState();
    const { policy, loading: loadingPolicy } = usePublicPolicySettings();
    const rolesUse = useRolesMap(roles);
    const rolesMap = react.exports.useMemo(() => !loadingPolicy && (policy === null || policy === void 0 ? void 0 : policy.forcePermissions) ? rolesUse : undefined, [policy, rolesUse, loadingPolicy]);
    const { tenants, subTenants } = useTenantsState();
    const tenantName = react.exports.useMemo(() => {
        var _a, _b;
        return (_b = (_a = tenants.find(({ tenantId }) => tenantId === user.tenantId)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';
    }, [tenants, user.tenantId]);
    const isPermissionsAndRolesEnabled = react.exports.useMemo(() => !loadingPolicy && (policy === null || policy === void 0 ? void 0 : policy.forcePermissions), [loadingPolicy, policy]);
    const columns = react.exports.useMemo(() => {
        if (subTenants.length > 0) {
            return usersTableColumnsOrganization({ t, user, subTenants, forcePermissions: isPermissionsAndRolesEnabled, container, currentTenantName: tenantName, currentTenantId: user.tenantId });
        }
        else {
            return usersTableColumns({ t, user, rolesMap, container });
        }
    }, [t, user, subTenants, isPermissionsAndRolesEnabled, container, rolesMap, tenantName, user.tenantId]);
    const { searching } = useTableSearch();
    const getRowActions = useUsersTableRowActions$1({
        roles,
        subTenants,
        permissions,
        container,
        resendActivationLink,
        resendInvitationLink,
        handleOpenDeleteUser,
        handleOpenEditUserRoles,
        revokeUserSessions,
        currentTenantId: user.tenantId
    });
    const onPageChange = react.exports.useCallback((event, page) => {
        loadUsers({ pageOffset: page - 1 });
    }, [loadUsers]);
    const loading = !!loaders.USERS;
    const tablePlaceholderProps = react.exports.useMemo(() => {
        if (loading || searching) {
            return null;
        }
        else if (filter.length === 0 && users.length === 0) {
            return {
                show: true,
                icon: React.createElement(GroupUsersIcon, null),
                title: t('noUsersYet'),
                description: t('noUsersYetDescription'),
            };
        }
        else if (filter.length > 0 && users.length === 0) {
            return {
                show: true,
                icon: React.createElement(SearchBigIcon, null),
                title: t('noResultFound'),
                description: t('noResultFoundDescription'),
            };
        }
        return null;
    }, [t, loading, searching, filter.length, users.length]);
    return React.createElement(React.Fragment, null,
        React.createElement(Table, { forwardedKey: 'users-table', columns: columns, data: users, getRowActions: getRowActions, loading: loading, searching: searching, loadingText: searching ? t('searchingPlaceholder') : undefined, totalPages: totalPages, pageOffset: pageOffset, onPageChange: onPageChange }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))),
        React.createElement(DeleteUserDialog$1, { open: deleteUserDialog, onClose: handleCloseDeleteUser, user: deleteUserData }),
        React.createElement(EditUserRolesDialog, { open: editUserRolesDialog, onClose: handleCloseEditUserRoles, user: editUserRolesData, roles: roles }));
};

const countDifferenceInDays = (expirationDate) => {
    const exp = parseISO(expirationDate);
    const differenceMinutes = differenceInMinutes(exp, new Date());
    const differenceDays = differenceInDays(exp, new Date());
    if (differenceMinutes < 0) {
        return -1;
    }
    return differenceDays + 1;
};
const daysInMinutes = {
    one: 1430,
    seven: 10070,
    thirty: 43190
};
const expirationPeriodsOptions = [{ label: '1 day', value: daysInMinutes.one }, { label: '7 days', value: daysInMinutes.seven }, { label: '30 days', value: daysInMinutes.thirty }];

var EditInviteUserActiveDialog;
(function (EditInviteUserActiveDialog) {
    EditInviteUserActiveDialog["EDIT_LINK"] = "EDIT_LINK";
    EditInviteUserActiveDialog["INVITATION_FORM"] = "INVITATION_FORM";
})(EditInviteUserActiveDialog || (EditInviteUserActiveDialog = {}));

const CopiedLinkIcon = styled(CheckIcon$1) `
  &.MuiSvgIcon-root {
    width: 13px;
  }
`;
const CopyLinkIcon = styled(LinkIcon) `
  &.MuiSvgIcon-root {
    width: 16px;
    margin-bottom: -1px;
  }
`;
const EditInviteLinkSettingsButton = styled(Box) `
  cursor: pointer;
  &:hover {
    text-decoration: underline;
  }
`;
const CopyInviteLink = ({ setActiveDialog, isEmailInviteShown }) => {
    const t = useT('users_EditInvitationLink');
    const [isLinkCopied, setIslinkCopied] = useBooleanToggle();
    const routes = useAuthRoutes();
    const { inviteTokenState } = useAuthTeamState();
    const { createInvitationLink, getInvitationLink, deleteInvitationLink } = useAuthTeamActions();
    const { token, expires, tenantInvitationsAllowed } = inviteTokenState !== null && inviteTokenState !== void 0 ? inviteTokenState : {};
    const { hostedLoginBox } = useShadowDom();
    const canCopyInviteLink = usePermission('fe.secure.write.tenantInvites');
    const { baseUrl } = ContextHolder.getContext();
    react.exports.useEffect(() => {
        if (!token) {
            getInvitationLink();
        }
        if (expires && countDifferenceInDays(expires) < 0) {
            deleteInvitationLink();
        }
    }, [getInvitationLink, deleteInvitationLink, expires]);
    const createSignupUrl = react.exports.useCallback((token) => {
        if (hostedLoginBox) {
            return `${baseUrl}/oauth/prelogin?redirectUrl=${window.location.origin}&invitationToken=${token}`;
        }
        else {
            return `${window.location.origin}${routes.signUpUrl}?invitationToken=${token}`;
        }
    }, [hostedLoginBox, baseUrl]);
    const handleCreateInvitationLink = react.exports.useCallback(() => {
        if (!token) {
            createInvitationLink({
                callback: (token) => {
                    copy(token ? createSignupUrl(token) : '');
                    setIslinkCopied(true);
                },
            });
        }
        else {
            copy(createSignupUrl(token));
            setIslinkCopied(true);
        }
    }, [createInvitationLink, token, createSignupUrl]);
    const handleSetActiveDialog = react.exports.useCallback(() => {
        setActiveDialog(EditInviteUserActiveDialog.EDIT_LINK);
    }, [setActiveDialog]);
    const linkExpiredAt = react.exports.useMemo(() => countDifferenceInDays(expires), [expires]);
    const showInviteLink = tenantInvitationsAllowed && canCopyInviteLink;
    return !showInviteLink ? (React.createElement(React.Fragment, null)) : (React.createElement(React.Fragment, null,
        isEmailInviteShown && React.createElement(Box, { mb: 6, mt: 8 },
            React.createElement(Divider, null)),
        React.createElement(Box, null,
            React.createElement(Grid, { container: true, justifyContent: 'space-between' },
                React.createElement(Grid, { item: true },
                    React.createElement(Typography$1, { mb: 2, variant: 'dialogTitle' }, t('inviteWithLinkTitle')),
                    expires && (React.createElement(Typography$1, { mb: 3, variant: 'body1' },
                        t('linkExpiration', { days: linkExpiredAt }),
                        " ",
                        t(linkExpiredAt > 1 ? 'days' : 'day'))),
                    React.createElement(Button$1, { "data-test-id": 'copy-invite-btn', type: 'button', color: 'secondary', onClick: handleCreateInvitationLink, startIcon: isLinkCopied ? React.createElement(CopiedLinkIcon, null) : React.createElement(CopyLinkIcon, null) }, t('copyInviteLink'))),
                token && (React.createElement(Grid, { item: true },
                    React.createElement(EditInviteLinkSettingsButton, { onClick: handleSetActiveDialog },
                        React.createElement(Typography$1, { "data-test-id": 'editBtn', variant: 'body1' }, t('edit')))))))));
};

const DeactivateInviteLinkDialog = ({ onClose, open }) => {
    const t = useT('users_DeactivateInvitationLink');
    const [loading, setLoading] = react.exports.useState(false);
    const [error, setError] = react.exports.useState(null);
    const { deleteInvitationLink } = useAuthTeamActions();
    const callback = react.exports.useCallback((success, error) => {
        if (error) {
            setLoading(false);
            setError(error);
        }
        else {
            onClose(true);
        }
    }, [setLoading, setError, onClose]);
    const handleDeleteLink = react.exports.useCallback(() => {
        setLoading(true);
        setError(null);
        deleteInvitationLink({ callback });
    }, [callback, setLoading, setError, deleteInvitationLink]);
    return (React.createElement(DeleteDialog, { dataTestId: 'deactivateBtn', title: t('title'), cancelButtonText: t('cancel'), deleteButtonText: t('deactivate'), description: t('areYouSureDeleteInviteLink'), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleDeleteLink }));
};

const DeactivateLinkButton = styled(Box) `
  cursor: pointer;
`;
const SendEmailField = () => {
    const t = useT('users_EditInvitationLink');
    const [{ value }, , { setValue, setTouched }] = useField('sendNotification');
    return (React.createElement(Grid, { container: true, ml: -2, alignItems: 'center' },
        React.createElement(Checkbox$1, { size: 'small', name: 'sendNotification', checked: value, onChange: () => {
                setValue(!value, true);
                setTouched(true);
            } }),
        React.createElement(Typography$1, { variant: 'body1' }, t('sendMeNotification'))));
};
const ExpirationField = () => {
    const t = useT('users_EditInvitationLink');
    const { injector } = useShadowDom();
    const [{ value }, { error, touched }, { setValue, setTouched }] = useField('expiration');
    return (React.createElement(Select$1$1, { "data-test-id": "expirationDropdown", label: t('expirationInputLabel'), name: 'expiration', value: value, placeholder: t('expirationInputPlaceholder'), container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: expirationPeriodsOptions, onChange: (value) => {
            setValue(value, true);
            setTouched(true);
        }, error: !!error && touched, errorMessage: error }));
};
const EditInviteLinkDialog = ({ setActiveDialog }) => {
    const t = useT('users_EditInvitationLink');
    const { updateInvitationLink } = useAuthTeamActions();
    const { inviteTokenState } = useAuthTeamState();
    const { expires, emailsEnabled, shouldSendEmail } = inviteTokenState !== null && inviteTokenState !== void 0 ? inviteTokenState : {};
    const [deactivateLinkDialog, handleCloseDeactivateLink, handleOpenDeactivateLink] = useDialogState();
    const canDeleteInviteLink = usePermission('fe.secure.delete.tenantInvites');
    const initialValues = react.exports.useMemo(() => ({ sendNotification: shouldSendEmail !== null && shouldSendEmail !== void 0 ? shouldSendEmail : true }), [shouldSendEmail]);
    const handleSetActiveDialogToInvitationForm = react.exports.useCallback(() => {
        setActiveDialog(EditInviteUserActiveDialog.INVITATION_FORM);
    }, []);
    const formikProps = {
        onSubmit: ({ sendNotification, expiration }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, handleSetActiveDialogToInvitationForm);
            updateInvitationLink({ shouldSendEmail: sendNotification, expiresInMinutes: expiration, callback });
        }),
        initialValues,
    };
    const handleCloseDeactivateInvitationLinkDialog = react.exports.useCallback((success) => {
        if (success) {
            handleSetActiveDialogToInvitationForm();
        }
        handleCloseDeactivateLink();
    }, [handleCloseDeactivateLink, handleSetActiveDialogToInvitationForm]);
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(ExpirationField, null),
                emailsEnabled && (React.createElement(React.Fragment, null,
                    React.createElement(Box, { mb: 6, mt: 8 },
                        React.createElement(Divider, null)),
                    React.createElement(Typography$1, { "data-test-id": "notificationBtn", variant: 'dialogTitle', mb: 3 }, t('notification')),
                    React.createElement(SendEmailField, null))),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                canDeleteInviteLink && (React.createElement(DeactivateLinkButton, { onClick: handleOpenDeactivateLink },
                    React.createElement(Typography$1, { "data-test-id": "deactivateLinkBtn", variant: 'body1', color: 'error' }, t('deactivateLink')))),
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": 'backBtn', color: 'inherit', variant: 'text', type: 'reset', onClick: handleSetActiveDialogToInvitationForm }, t('back')),
                React.createElement(Button$1, { "data-test-id": 'inviteBtn', disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))),
            React.createElement(DeactivateInviteLinkDialog, { open: deactivateLinkDialog, onClose: handleCloseDeactivateInvitationLinkDialog })));
    }));
};

const FirstNameField$1 = () => {
    const t = useT('users_InviteUser');
    const [fieldProps, { error, touched }] = useField('firstName');
    return React.createElement(Input$1$1, Object.assign({ label: t('firstNameInputLabel') }, fieldProps, { autoFocus: true, error: !!error && touched, errorMessage: error, "data-test-id": "nameBox", autoComplete: 'given-name' }));
};
const LastNameField = () => {
    const t = useT('users_InviteUser');
    const [fieldProps, { error, touched }] = useField('lastName');
    return React.createElement(Input$1$1, Object.assign({ label: t('lastNameInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": "lastNameBox", autoComplete: 'family-name' }));
};
const PhoneField = () => {
    const t = useT('users_InviteUser');
    const [fieldProps, { error, touched }] = useField('phone');
    return React.createElement(Input$1$1, Object.assign({ label: t('phoneInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": "phoneBox", autoComplete: 'tel' }));
};
const EmailField$2 = () => {
    const t = useT('users_InviteUser');
    const [fieldProps, { error, touched }] = useField('email');
    return React.createElement(Input$1$1, Object.assign({ label: t('emailInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": "emailBox", autoComplete: 'email' }));
};
const RolesField$2 = ({ roles }) => {
    const t = useT('users_InviteUser');
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue, setTouched }] = useField('roleIds');
    const options = react.exports.useMemo(() => (roles !== null && roles !== void 0 ? roles : []).map((role) => ({ label: role.name, value: role.id, withCheckbox: true })), [roles]);
    return React.createElement(Select$1$1, { label: t('rolesInputLabel'), name: 'roleIds', multi: true, placeholder: t('rolesInputPlaceholder'), value: fieldProps.value, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options, onChange: (value) => {
            setValue(value, true);
            setTouched(true);
        }, error: !!error && touched, errorMessage: error });
};
const InviteUserForm$1 = (_a) => {
    var _b, _c;
    var { setActiveDialog, hideInviteWithEmail } = _a, props = __rest(_a, ["setActiveDialog", "hideInviteWithEmail"]);
    const t = useT('users_InviteUser');
    const { addUser } = useAuthTeamActions();
    const user = useAuthUserOrNull();
    const allRoles = useAuthTeamState(state => state.roles);
    const { injector } = useShadowDom();
    const metadata = (_c = (_b = Metadata.getInstance(injector.name).navigation.users) === null || _b === void 0 ? void 0 : _b.inviteDialog) !== null && _c !== void 0 ? _c : {};
    const initialValues = react.exports.useMemo(() => ({
        firstName: '',
        lastName: '',
        email: '',
        phone: '',
        roleIds: [],
    }), []);
    const { policy } = usePublicPolicySettings();
    const validationSchema = react.exports.useMemo(() => validateSchema({
        firstName: validateNotEmpty(t('firstNameIsRequired')),
        lastName: validateNotEmpty(t('lastNameIsRequired')),
        email: validateEmail(t('emailMustBeValid'), t('emailIsRequired')),
        phone: metadata.phoneNumberField === 'mandatory' ? validationPhone(t('phoneIsRequired'), t('phoneIsInvalid')) :
            validationPhoneOptional(t('phoneIsInvalid')),
        roleIds: create().min((policy === null || policy === void 0 ? void 0 : policy.forcePermissions) ? 1 : 0, t('rolesIsRequired')),
    }), [t, metadata.phoneNumberField, policy === null || policy === void 0 ? void 0 : policy.forcePermissions]);
    const { events } = useShadowDom();
    const { email: userEmail } = useAuthUser();
    const formikProps = {
        onSubmit: ({ firstName, lastName, email, phone, roleIds }) => new Promise((resolve, reject) => {
            var _a;
            const name = [firstName, lastName].filter(notNull).join(' ');
            const callback = callbackToPromise(resolve, reject, props.onClose);
            addUser({ name, email, roleIds, phone: phone ? '+' + phone.replace('+', '') : undefined, callback });
            (_a = events === null || events === void 0 ? void 0 : events.inviteMemberSubmit) === null || _a === void 0 ? void 0 : _a.call(events, { email: userEmail, invitedUserFirstName: firstName, invitedUserLastName: lastName, invitedUserEmail: email, invitedUserPhoneNumber: phone, invitedUserRoles: roleIds });
        }),
        initialValues,
        validationSchema,
    };
    const roles = checkRoleAccess(allRoles, user);
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                !hideInviteWithEmail && React.createElement(React.Fragment, null,
                    React.createElement(Grid, { container: true, spacing: 4 },
                        React.createElement(Grid, { item: true, xs: 12, sm: 6 },
                            React.createElement(FirstNameField$1, null)),
                        React.createElement(Grid, { item: true, xs: 12, sm: 6 },
                            React.createElement(LastNameField, null))),
                    !!metadata.phoneNumberField && React.createElement(PhoneField, null),
                    React.createElement(EmailField$2, null),
                    (policy === null || policy === void 0 ? void 0 : policy.forcePermissions) && roles.length > 0 && React.createElement(RolesField$2, { roles: roles })),
                React.createElement(CopyInviteLink, { setActiveDialog: setActiveDialog, isEmailInviteShown: !hideInviteWithEmail }),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                !hideInviteWithEmail && React.createElement(Button$1, { "data-test-id": "inviteBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('invite'))));
    });
};
const InviteUserDialog$1 = (_a) => {
    var { onClose, hideInviteWithEmail } = _a, props = __rest(_a, ["onClose", "hideInviteWithEmail"]);
    const t = useT('users_InviteUser');
    const [activeDialog, setActiveDialog] = react.exports.useState(EditInviteUserActiveDialog.INVITATION_FORM);
    const { injector } = useShadowDom();
    const handleClose = react.exports.useCallback(() => {
        onClose();
        setActiveDialog(EditInviteUserActiveDialog.INVITATION_FORM);
    }, [setActiveDialog, onClose]);
    return (React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { onClose: handleClose, title: t(activeDialog === EditInviteUserActiveDialog.INVITATION_FORM ? 'title' : 'inviteWithLinkSettings') }), activeDialog === EditInviteUserActiveDialog.INVITATION_FORM ? (React.createElement(InviteUserForm$1, Object.assign({}, props, { onClose: handleClose, setActiveDialog: setActiveDialog, hideInviteWithEmail: hideInviteWithEmail }))) : (React.createElement(EditInviteLinkDialog, { setActiveDialog: setActiveDialog }))));
};

const UsersPage$1 = () => {
    var _a, _b, _c;
    const [searching, setSearching] = react.exports.useState(false);
    const [searchQuery, onSearch] = react.exports.useState('');
    const themeOptions = useTheme();
    const hideInviteWithEmail = (_c = (_b = (_a = themeOptions === null || themeOptions === void 0 ? void 0 : themeOptions.adminPortal) === null || _a === void 0 ? void 0 : _a.pages) === null || _b === void 0 ? void 0 : _b.users) === null || _c === void 0 ? void 0 : _c.hideInviteWithEmail;
    const { users, roles, inviteTokenState } = useAuthTeamState();
    const { loadUsers, getInvitationLink } = useAuthTeamActions();
    const { loadSubTenants } = useTenantsActions();
    const [inviteUserDialog, handleCloseInviteUser, handleOpenInviteUser] = useDialogState();
    const { tenantInvitationsAllowed } = inviteTokenState !== null && inviteTokenState !== void 0 ? inviteTokenState : {};
    const canCopyInviteLink = usePermission('fe.secure.write.tenantInvites');
    react.exports.useEffect(() => {
        getInvitationLink();
        loadSubTenants();
        const queryObject = { pageOffset: 0, pageSize: 10, filter: [], silentLoading: users.length > 0 };
        loadUsers(queryObject);
        return () => loadUsers(queryObject);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadUsers, getInvitationLink]);
    useEffectAfterMount(() => {
        loadUsers({
            filter: searchQuery ? [{ id: 'searchFilter', value: searchQuery }] : [],
            pageOffset: 0,
            callback: () => setSearching(false),
        });
    }, [searchQuery, loadUsers]);
    return React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(TableSearchContext.Provider, { value: { searching, searchQuery, onSearch, setSearching } },
            React.createElement(UsersHeader, { handleOpenInviteUser: handleOpenInviteUser, isInviteWithEmailEnabled: !hideInviteWithEmail, isInviteLinkEnabled: canCopyInviteLink && tenantInvitationsAllowed }),
            React.createElement(Box, { mt: 6, flex: 1, display: 'flex', flexDirection: 'column' },
                React.createElement(UsersTable, null)),
            React.createElement(InviteUserDialog$1, { open: inviteUserDialog, onClose: handleCloseInviteUser, roles: roles, hideInviteWithEmail: hideInviteWithEmail })));
};
var UsersPage$2 = UsersPage$1;

var UsersPage = wrapPage(UsersPage$2, 'users');

const RolesHeader = ({ handleOpenAddRole }) => {
    const t = useT('roles');
    const { onSearch } = useTableSearch();
    const [search, setSearch] = react.exports.useState('');
    const debounceSearch = useDebounce(search);
    const canAddRole = usePermission('fe.secure.write.roles');
    useAsyncEffect(() => onSearch(debounceSearch), [debounceSearch]);
    return React.createElement(Grid, { container: true, spacing: 4 },
        React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
            React.createElement(Box, null,
                React.createElement(Input$1$1, { "data-test-id": "searchBox", endAdornment: React.createElement(SearchIcon, null), onChange: (e) => setSearch(e.target.value), placeholder: t('searchInputPlaceholder') }))),
        React.createElement(Grid, { item: true, xs: true }),
        canAddRole && React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": "addRoleBtn", onClick: handleOpenAddRole }, t('addNewRoleButton'))));
};

const RoleName = react.exports.memo(() => {
    const t = useT('roles_AddRole');
    const { values, setFieldValue } = useFormikContext();
    const [fieldProps, { error, touched }] = useField('name');
    return React.createElement(Input$1$1, Object.assign({ label: t('nameInputLabel') }, fieldProps, { onChange: (e) => {
            fieldProps.onChange(e);
            if (values.shouldChangeKey) {
                setFieldValue('key', e.target.value.toLowerCase().replace(/ /g, '-'), true);
            }
        }, autoFocus: true, error: !!error && touched, errorMessage: error, "data-test-id": "roleNameBox" }));
});
const RoleKey = react.exports.memo(() => {
    const t = useT('roles_AddRole');
    const { setFieldValue } = useFormikContext();
    const [fieldProps, { error, touched }] = useField('key');
    return React.createElement(Input$1$1, Object.assign({ label: t('keyInputLabel') }, fieldProps, { onChange: (e) => {
            fieldProps.onChange(e);
            setFieldValue('shouldChangeKey', e.target.value.length === 0, false);
        }, error: !!error && touched, "data-test-id": "roleKeyBox", errorMessage: error }));
});
const RoleDescription = react.exports.memo(() => {
    const t = useT('roles_AddRole');
    const [fieldProps, { error, touched }] = useField('description');
    return React.createElement(Input$1$1, Object.assign({ label: t('descriptionInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": "roleDescriptionBox" }));
});
const RoleInherit = react.exports.memo(() => {
    const t = useT('roles_AddRole');
    const { injector } = useShadowDom();
    const { roles } = useRolesState();
    const [fieldProps, { error, touched }, { setValue }] = useField('inherit');
    const options = react.exports.useMemo(() => (roles !== null && roles !== void 0 ? roles : []).map((role) => ({ label: role.name, value: role.id })), [roles]);
    return React.createElement(Select$1$1, { label: t('inheritPermissionInputLabel'), name: 'inherit', placeholder: t('inheritPermissionInputPlaceholder'), value: fieldProps.value, onChange: (value) => setValue(value, true), errorMessage: touched ? error : undefined, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options });
});
const AddRoleForm = react.exports.forwardRef((props, ref) => {
    const t = useT('roles_AddRole');
    const { addRole } = useRolesActions();
    const { roles } = useRolesState();
    const initialValues = react.exports.useMemo(() => {
        var _a;
        return ({
            key: '',
            name: '',
            description: '',
            inherit: (_a = roles[0]) === null || _a === void 0 ? void 0 : _a.id,
            shouldChangeKey: true,
        });
    }, [roles]);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        name: validateNotEmpty(t('nameIsRequired')),
        key: validateNotEmpty(t('keyIsRequired')),
    }), [t]);
    const formikProps = {
        onSubmit: ({ key, name, description, inherit }) => new Promise((resolve, reject) => {
            var _a;
            const inheritedRole = roles.find(({ id }) => id === inherit);
            const callback = callbackToPromise(resolve, reject);
            addRole({
                key,
                name,
                description,
                permissions: (_a = inheritedRole === null || inheritedRole === void 0 ? void 0 : inheritedRole.permissions) !== null && _a !== void 0 ? _a : [],
                isDefault: false,
                level: 0,
                callback,
            });
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, { ref: ref },
                React.createElement(Grid, { container: true, spacing: 4, mb: 4 },
                    React.createElement(Grid, { item: true, xs: 6 },
                        React.createElement(RoleName, null)),
                    React.createElement(Grid, { item: true, xs: 6 },
                        React.createElement(RoleKey, null))),
                React.createElement(RoleDescription, null),
                React.createElement(RoleInherit, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "createBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('create'))));
    });
});
const AddRoleDialog = props => {
    const { injector } = useShadowDom();
    const t = useT('roles_AddRole');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title'), size: 'sm' }),
        React.createElement(AddRoleForm, Object.assign({}, props)));
};

const rolesTableColumns = (params) => {
    const { t, roles } = params;
    return [
        {
            id: 'actions',
            Header: t('actionsHeader'),
            accessor: ({ name, description }) => ({ title: name, description, multiLineDescription: true }),
            minWidth: 400,
            width: 400,
            maxWidth: 400,
            pivot: true,
            sortable: true,
            Cell: TableTextCell,
        },
        ...roles.map((role, index) => {
            return ({
                id: role.id,
                Header: React.createElement(Typography$1, { variant: 'tableSmallHeader' }, role.name),
                accessor: ({ id }) => ({
                    checked: role.permissions.includes(id),
                    containerStyle: { marginLeft: index === roles.length - 1 ? '.75rem' : undefined },
                }),
                width: 160,
                maxWidth: 160,
                Cell: TableSwitchCell,
            });
        }),
    ].filter(notNull);
};

const RolesTable = () => {
    const t = useT('roles');
    const { searching, searchQuery } = useTableSearch();
    const { loading, roles, permissions, permissionCategories } = useRolesState();
    const columns = react.exports.useMemo(() => rolesTableColumns({ t, roles, permissions }), [t, roles, permissions]);
    const rows = react.exports.useMemo(() => {
        if (!!searchQuery) {
            return permissions.filter((permission) => {
                var _a;
                return permission.name.toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1
                    || ((_a = permission.description) !== null && _a !== void 0 ? _a : '').toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1
                    || permission.key.toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1;
            });
        }
        return permissions;
    }, [permissions, searchQuery]);
    const categoriesRows = react.exports.useMemo(() => {
        const mapped = rows.reduce((p, n) => (Object.assign(Object.assign({}, p), { [n.id]: n })), {});
        return permissionCategories.concat().sort((a, b) => a.name.localeCompare(b.name))
            .map(category => {
            const fPermissions = category.permissionIds.map(permissionId => mapped[permissionId]).filter(notNull);
            if (fPermissions.length === 0) {
                return [];
            }
            return [{
                    __type: 'categoryRow',
                    id: category.id,
                    title: category.name,
                },
                ...fPermissions.sort((a, b) => a.name.localeCompare(b.name)),
            ];
        }).reduce((p, n) => [...p, ...n], []);
    }, [rows, permissionCategories]);
    const tablePlaceholderProps = react.exports.useMemo(() => {
        if (loading) {
            return null;
        }
        else if (searchQuery && rows.length === 0) {
            return {
                show: true,
                icon: React.createElement(SearchBigIcon, null),
                title: t('noResultFound'),
                description: t('noResultFoundDescription'),
            };
        }
        return null;
    }, [t, loading, searchQuery, rows.length]);
    return React.createElement(React.Fragment, null,
        React.createElement(Table, { forwardedKey: 'roles-table', columns: columns, data: categoriesRows, loading: loading, searching: searching, loadingText: searching ? t('searchingPlaceholder') : undefined }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))));
};

const RolesPage$1 = () => {
    const [searching, setSearching] = react.exports.useState(false);
    const [searchQuery, onSearch] = react.exports.useState('');
    const { roles } = useRolesState();
    const { loadRolesAndPermissions } = useRolesActions();
    react.exports.useEffect(() => {
        loadRolesAndPermissions({ silentLoading: roles.length > 0 });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadRolesAndPermissions]);
    const [addRoleDialog, handleCloseAddRole, handleOpenAddRole] = useDialogState();
    return React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(TableSearchContext.Provider, { value: { searching, searchQuery, onSearch, setSearching } },
            React.createElement(RolesHeader, { handleOpenAddRole: handleOpenAddRole }),
            React.createElement(Box, { mt: 6, flex: 1, display: 'flex', flexDirection: 'column' },
                React.createElement(RolesTable, null)),
            React.createElement(AddRoleDialog, { open: addRoleDialog, onClose: handleCloseAddRole })));
};
var RolesPage$2 = RolesPage$1;

var RolesPage = wrapPage(RolesPage$2, 'roles');

const AttemptsInput = react.exports.memo(() => {
    const t = useT('security_EditLockoutPolicy');
    const [fieldProps, { error, touched }] = useField('maxAttempts');
    return React.createElement(Input$1$1, Object.assign({}, fieldProps, { autoFocus: true, inputMode: 'decimal', label: t('attemptsInputLabel'), placeholder: t('attemptsInputPlaceholder'), error: !!error && touched, "data-test-id": "userLockoutBox", errorMessage: error }));
});
const EditMfaPolicyForm$1 = (props) => {
    const t = useT('security_EditLockoutPolicy');
    const { policy, saveSecurityPolicyLockout } = useLockoutPolicySettings();
    const initialValues = react.exports.useMemo(() => {
        var _a, _b;
        return ({
            id: policy === null || policy === void 0 ? void 0 : policy.id,
            enabled: (_a = policy === null || policy === void 0 ? void 0 : policy.enabled) !== null && _a !== void 0 ? _a : true,
            maxAttempts: (_b = policy === null || policy === void 0 ? void 0 : policy.maxAttempts) !== null && _b !== void 0 ? _b : 0,
        });
    }, [policy]);
    const formikProps = {
        onSubmit: ({ id, maxAttempts, enabled }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, props.onClose);
            saveSecurityPolicyLockout({ callback, id, maxAttempts: Number(maxAttempts), enabled });
        }),
        initialValues,
        validationSchema: validateSchema({
            maxAttempts: validatePositiveNumber(t('attemptsInputErrorMessage')),
        }),
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(AttemptsInput, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditLockoutPolicyDialog = props => {
    const { injector } = useShadowDom();
    const t = useT('security_EditLockoutPolicy');
    return React.createElement(Dialog$1, Object.assign({ "data-test-id": "edit-user-lockout-dialog", container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { dialogTitleDataTestId: "user-lockout-header", title: t('title'), size: 'sm' }),
        React.createElement(EditMfaPolicyForm$1, Object.assign({}, props)));
};

const MfaPolicySelect = react.exports.memo(() => {
    const t = useT('security_EditMfaPolicy');
    const [fieldProps, , { setValue }] = useField('enforceMFAType');
    const activeMfaTypes = useOptionalEnforceMfaTypes();
    const options = react.exports.useMemo(() => {
        return [{
                'data-test-id': 'DontForce',
                label: t('dontForceTitle'),
                value: MfaTypeEnum.DontForce,
                description: t('dontForceDescription'),
            }, {
                'data-test-id': 'Force',
                label: t('forceTitle'),
                value: MfaTypeEnum.Force,
                description: t('forceDescription'),
            }, {
                'data-test-id': 'ForceExceptSAML',
                label: t('forceExceptSAMLTitle'),
                value: MfaTypeEnum.ForceExceptSAML,
                description: t('forceExceptSAMLDescription')
            }].filter(({ value }) => activeMfaTypes.includes(value));
    }, [t, activeMfaTypes]);
    return React.createElement(RadioList, { items: options, name: fieldProps.name, value: fieldProps.value, onChange: (_e, value) => setValue(value, true) });
});
const EditMfaPolicyForm = (props) => {
    const t = useT('security_EditMfaPolicy');
    const { policy, saveSecurityPolicyMfa } = useMfaPolicySettings();
    const vendorMfaPolicy = useVendorMfaPolicySettings();
    const initialValues = react.exports.useMemo(() => {
        var _a, _b, _c;
        return ({
            id: policy === null || policy === void 0 ? void 0 : policy.id,
            enforceMFAType: (_c = (_a = policy === null || policy === void 0 ? void 0 : policy.enforceMFAType) !== null && _a !== void 0 ? _a : (_b = vendorMfaPolicy.policy) === null || _b === void 0 ? void 0 : _b.enforceMFAType) !== null && _c !== void 0 ? _c : MfaTypeEnum.DontForce,
        });
    }, [policy]);
    const formikProps = {
        onSubmit: ({ id, enforceMFAType }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, props.onClose);
            saveSecurityPolicyMfa({ callback, id, enforceMFAType });
        }),
        initialValues,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, { noPadding: true },
                React.createElement(MfaPolicySelect, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditMfaPolicyDialog = props => {
    const { injector } = useShadowDom();
    const t = useT('security_EditMfaPolicy');
    return React.createElement(Dialog$1, Object.assign({ "data-test-id": "edit-MFA-dialog", container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { dialogTitleDataTestId: "mfa-policy-header", title: t('title'), size: 'sm' }),
        React.createElement(EditMfaPolicyForm, Object.assign({}, props)));
};

const HistorySizeInput = react.exports.memo(() => {
    const t = useT('security_EditPasswordHistoryPolicy');
    const [fieldProps, { error }] = useField('historySize');
    return React.createElement(Input$1$1, Object.assign({}, fieldProps, { autoFocus: true, inputMode: 'decimal', label: t('sizeInputLabel'), placeholder: t('sizeInputPlaceholder'), error: !!error, "data-test-id": "userPasswordHistoryBox", errorMessage: error }));
});
const EditPasswordHistoryPolicyForm = (props) => {
    const t = useT('security_EditPasswordHistoryPolicy');
    const { policy, saveSecurityPolicyPasswordHistory } = usePasswordHistoryPolicySettings();
    const initialValues = react.exports.useMemo(() => {
        var _a, _b;
        return ({
            id: policy === null || policy === void 0 ? void 0 : policy.id,
            enabled: (_a = policy === null || policy === void 0 ? void 0 : policy.enabled) !== null && _a !== void 0 ? _a : true,
            historySize: (_b = policy === null || policy === void 0 ? void 0 : policy.historySize) !== null && _b !== void 0 ? _b : 0,
        });
    }, [policy]);
    const formikProps = {
        onSubmit: ({ id, historySize, enabled }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, props.onClose);
            saveSecurityPolicyPasswordHistory({ callback, id, historySize: Number(historySize), enabled });
        }),
        initialValues,
        validationSchema: validateSchema({
            historySize: validateHistorySize(t('sizeIsRequired'), t('sizeMustBeNumber'), t('sizeMustBeGt0'), t('sizeMustBelt10')),
        }),
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(HistorySizeInput, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "saveBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('save'))));
    });
};
const EditPasswordHistoryPolicyDialog = props => {
    const { injector } = useShadowDom();
    const t = useT('security_EditPasswordHistoryPolicy');
    return React.createElement(Dialog$1, Object.assign({ "data-test-id": 'password-history-dialog', dialogTitleDataTestId: 'password-history-header', container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('title'), size: 'sm' }),
        React.createElement(EditPasswordHistoryPolicyForm, Object.assign({}, props)));
};

const MfaSecurityPolicyValue = () => {
    const t = useT('security');
    const { loading, policy } = useMfaPolicySettings();
    const { vendorMfaPolicy } = useSecurityPolicyState();
    const activeMFATypes = useOptionalEnforceMfaTypes();
    const activeMFAPolicy = react.exports.useMemo(() => { var _a; return (policy === null || policy === void 0 ? void 0 : policy.enforceMFAType) && activeMFATypes.includes(policy.enforceMFAType) ? policy.enforceMFAType : (_a = vendorMfaPolicy.policy) === null || _a === void 0 ? void 0 : _a.enforceMFAType; }, [vendorMfaPolicy, policy, activeMFATypes]);
    let description;
    switch (activeMFAPolicy) {
        case 'Force':
            description = t('mfaPolicyForceDescription');
            break;
        case 'ForceExceptSAML':
            description = t('mfaPolicyForceExceptSAMLDescription');
            break;
        default:
            description = t('mfaPolicyDontForceDescription');
    }
    return (loading && !policy) ?
        React.createElement(Skeleton, { width: 80, height: 18 })
        :
            React.createElement(Typography$1, { "data-test-id": "mfa-description", variant: 'body1' }, description);
};
const LockoutSecurityPolicyValue = () => {
    const t = useT('security');
    const { loading, policy } = useLockoutPolicySettings();
    if (loading && !policy) {
        return React.createElement(Skeleton, { width: 80, height: 18 });
    }
    if (!policy) {
        return React.createElement(Typography$1, { variant: 'body1' }, t('lockoutNotConfigured'));
    }
    if (policy.enabled) {
        return React.createElement(Typography$1, { variant: 'body1' },
            t('lockoutEnabledMaxAttempts1'),
            " ",
            React.createElement("b", null, policy.maxAttempts),
            " ",
            t('lockoutEnabledMaxAttempts2'));
    }
    return React.createElement(Typography$1, { variant: 'body1' }, t('lockoutDisabled'));
};
const PasswordHistorySecurityPolicyValue = () => {
    const t = useT('security');
    const { loading, policy } = usePasswordHistoryPolicySettings();
    if (loading && !policy) {
        return React.createElement(Skeleton, { width: 80, height: 18 });
    }
    if (!policy) {
        return React.createElement(Typography$1, { variant: 'body1' }, t('passwordHistoryNotConfigured'));
    }
    if (policy.enabled) {
        return React.createElement(Typography$1, { variant: 'body1' },
            t('passwordHistoryEnabledHistorySize1'),
            " ",
            React.createElement("b", null, policy.historySize),
            " ",
            t('passwordHistoryEnabledHistorySize2'));
    }
    return React.createElement(Typography$1, { variant: 'body1' }, t('passwordHistoryDisabled'));
};
const getLockoutSecurityPolicyActions = (policy, save) => {
    if (policy) {
        return React.createElement(Switch$1$1, { checked: policy.enabled, onChange: (_, value) => save(Object.assign(Object.assign({}, policy), { enabled: value })) });
    }
    return undefined;
};
const getPasswordHistorySecurityPolicyActions = (policy, save) => {
    if (policy) {
        return React.createElement(Switch$1$1, { "data-test-id": "switch", checked: policy.enabled, onChange: (_, value) => save(Object.assign(Object.assign({}, policy), { enabled: value })) });
    }
    return undefined;
};
const BasicSettingsList = () => {
    const t = useT('security');
    const { loading: mfaLoading, policy: mfaPolicy } = useMfaPolicySettings(true);
    const { loading: lockoutLoading, policy: lockoutPolicy, saveSecurityPolicyLockout } = useLockoutPolicySettings(true);
    const { loading: passwordHistoryLoading, policy: passwordHistoryPolicy, saveSecurityPolicyPasswordHistory, } = usePasswordHistoryPolicySettings(true);
    const [editMfaPolicyDialog, handleCloseMfaPolicyDialog, handleOpenMfaPolicyDialog] = useDialogState();
    const [editLockoutPolicyDialog, handleCloseLockoutPolicyDialog, handleOpenLockoutPolicyDialog] = useDialogState();
    const [editPasswordHistoryPolicyDialog, handleClosePasswordHistoryPolicyDialog, handleOpenPasswordHistoryPolicyDialog] = useDialogState();
    const { loading: vendorMfaPolicyLoading } = useVendorMfaPolicySettings();
    const activeMfaTypes = useOptionalEnforceMfaTypes();
    const isMfaDisabled = react.exports.useMemo(() => {
        if (vendorMfaPolicyLoading) {
            return true;
        }
        if (mfaLoading && !mfaPolicy) {
            return true;
        }
        if (activeMfaTypes.length <= 1) {
            return true;
        }
        return false;
    }, [activeMfaTypes, mfaLoading, mfaPolicy]);
    const canEditSecurityPolicy = usePermission('fe.secure.write.securityPolicy');
    const items = react.exports.useMemo(() => [{
            id: 'mfa',
            title: t('mfaTitle'),
            value: React.createElement(MfaSecurityPolicyValue, null),
            disabled: isMfaDisabled,
            onEditClick: handleOpenMfaPolicyDialog,
            disabledRow: !canEditSecurityPolicy,
        }, {
            id: 'lockout',
            title: t('lockoutTitle'),
            value: React.createElement(LockoutSecurityPolicyValue, null),
            actions: getLockoutSecurityPolicyActions(lockoutPolicy, saveSecurityPolicyLockout),
            disabled: lockoutLoading && !lockoutPolicy,
            onEditClick: handleOpenLockoutPolicyDialog,
            disabledRow: !canEditSecurityPolicy,
        },
        {
            id: 'passwordHistory',
            title: t('passwordHistoryTitle'),
            value: React.createElement(PasswordHistorySecurityPolicyValue, null),
            actions: getPasswordHistorySecurityPolicyActions(passwordHistoryPolicy, saveSecurityPolicyPasswordHistory),
            disabled: passwordHistoryLoading && !passwordHistoryPolicy,
            onEditClick: handleOpenPasswordHistoryPolicyDialog,
            disabledRow: !canEditSecurityPolicy,
        }], [
        t,
        lockoutPolicy,
        passwordHistoryPolicy,
        lockoutLoading,
        passwordHistoryLoading,
        saveSecurityPolicyLockout,
        saveSecurityPolicyPasswordHistory,
        handleOpenMfaPolicyDialog,
        handleOpenLockoutPolicyDialog,
        handleOpenPasswordHistoryPolicyDialog,
        canEditSecurityPolicy,
        isMfaDisabled,
    ]);
    return React.createElement(React.Fragment, null,
        React.createElement(SettingsList, { title: t('subtitle'), items: items }),
        React.createElement(EditMfaPolicyDialog, { open: editMfaPolicyDialog, onClose: handleCloseMfaPolicyDialog }),
        React.createElement(EditLockoutPolicyDialog, { open: editLockoutPolicyDialog, onClose: handleCloseLockoutPolicyDialog }),
        React.createElement(EditPasswordHistoryPolicyDialog, { open: editPasswordHistoryPolicyDialog, onClose: handleClosePasswordHistoryPolicyDialog }));
};
var BasicSettingsList$1 = BasicSettingsList;

var ETimeFormat;
(function (ETimeFormat) {
    ETimeFormat["DAYS"] = "days";
    ETimeFormat["HOURS"] = "hours";
    ETimeFormat["MINUTES"] = "minutes";
})(ETimeFormat || (ETimeFormat = {}));
const TimeFormatLocalizedTitles = {
    [ETimeFormat.DAYS]: {
        plural: 'days',
        singular: 'day'
    },
    [ETimeFormat.HOURS]: {
        plural: 'hours',
        singular: 'hour'
    },
    [ETimeFormat.MINUTES]: {
        plural: 'minutes',
        singular: 'minute'
    }
};
const TimeFormatMultiplier = {
    [ETimeFormat.DAYS]: 60 * 60 * 24,
    [ETimeFormat.HOURS]: 60 * 60,
    [ETimeFormat.MINUTES]: 60,
};
const calculateTime = (time, timeFormat) => time * TimeFormatMultiplier[timeFormat];
const useTimeOptions = (count) => {
    const t = useT('security_SessionManagement');
    return react.exports.useMemo(() => Object.values(ETimeFormat).map((time) => ({ label: t(TimeFormatLocalizedTitles[time][count > 1 ? 'plural' : 'singular']), value: time })), [t, count]);
};
const getTimeAndFormat = (timeInSeconds) => {
    for (const format of Object.values(ETimeFormat)) {
        if (timeInSeconds % TimeFormatMultiplier[format] === 0) {
            return { timeout: timeInSeconds / TimeFormatMultiplier[format], timeFormat: format };
        }
    }
    return { timeout: timeInSeconds / TimeFormatMultiplier[ETimeFormat.MINUTES], timeFormat: ETimeFormat.MINUTES };
};
const sessionManagementFormValidation = (t) => {
    return create$1({
        sessionTimeoutConfiguration: create$1().shape({
            timeout: create$2().typeError(t('sessionTimeoutErrorMessage')).test('test calculated value', t('sessionTimeoutErrorMessage'), (_, { parent }) => {
                return TimeFormatMultiplier[parent.timeFormat] * parent.timeout >= (60 * 60 * 24); // 1 day in secs
            })
        }),
        sessionIdleTimeoutConfiguration: create$1().shape({
            timeout: create$2().typeError(t('idleSessionTimeoutErrorMessage')).test('test calculated value', t('idleSessionTimeoutErrorMessage'), (_, { parent }) => {
                return TimeFormatMultiplier[parent.timeFormat] * parent.timeout >= (60 * 5); // 5 minutes in secs
            })
        }),
        sessionConcurrentConfiguration: create$1().shape({
            maxSessions: validateNumber(t('concurrentSessionsTimeoutErrorMessage'), t('concurrentSessionsTimeoutErrorMessage')).min(1, t('concurrentSessionsTimeoutErrorMessage')),
        })
    });
};

const ConfirmDialogBody = ({ error, description, loading, onConfirm, onClose, confirmButtonText, cancelButtonText }) => {
    return (React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, null,
            React.createElement(Typography$1, { variant: "subtitle2Light" }, description),
            React.createElement(FormErrorDialogMessage, { message: error })),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(Box, { flex: 1 }),
            cancelButtonText &&
                React.createElement(Button$1, { "data-test-id": "cancel-btn", color: "inherit", variant: "text", onClick: onClose }, cancelButtonText),
            React.createElement(Button$1, { "data-test-id": "delete-btn", loading: loading, color: "primary", onClick: onConfirm }, confirmButtonText))));
};
const ConfirmDialog = (_a) => {
    var { onClose, title, open, dataTestId } = _a, props = __rest(_a, ["onClose", "title", "open", "dataTestId"]);
    const { injector } = useShadowDom();
    return (React.createElement(Dialog$1, { dataTestId: dataTestId, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, open: open, onClose: onClose, title: title },
        React.createElement(ConfirmDialogBody, Object.assign({}, props, { onClose: onClose }))));
};

const EnforceSessionPolicyDialog = ({ onClose, open, onConfirm }) => {
    const t = useT('security_SessionManagementDialog');
    const [submitted, setSubmitted] = react.exports.useState(false);
    const { loading, error } = useSessionsPolicyState();
    react.exports.useEffect(() => {
        if (submitted && !error && !loading) {
            onClose();
        }
    }, [submitted, error, loading, onClose]);
    const handleConfirm = react.exports.useCallback(() => {
        setSubmitted(true);
        onConfirm();
    }, [onConfirm, setSubmitted]);
    return (React.createElement(ConfirmDialog, { dataTestId: 'confirm_timeout_dialog', title: t('title'), confirmButtonText: t('confirm'), cancelButtonText: t('cancel'), description: t('description'), open: open, error: error, onClose: onClose, loading: !!loading, onConfirm: handleConfirm }));
};

const RowSkeleton$1 = () => React.createElement(Skeleton, { height: 120, width: '100%' });
const SessionsSettingsListSkeleton = () => {
    const t = useT('security_SessionManagement');
    return React.createElement(Grid, { container: true, direction: 'column' },
        React.createElement(Typography$1, { mt: 2, variant: 'subtitle1' }, t('sectionTitle')),
        React.createElement(RowSkeleton$1, null),
        React.createElement(RowSkeleton$1, null),
        React.createElement(RowSkeleton$1, null));
};

const ConfigBox = styled(Box)(({ theme }) => ({
    display: 'flex',
    flexDirection: 'row',
    alignItems: 'baseline',
    justifyContent: 'flex-start',
    gap: theme.spacing(4),
    padding: theme.spacing(0, 9, 4, 9),
}));
const ErrorBox = styled(Box)(({ theme }) => ({
    padding: theme.spacing(0, 9, 2, 9),
    marginTop: theme.spacing(-3),
}));
const TimeoutInput = styled(Input$1$1)(() => ({
    width: '6rem',
    margin: 0
}));
const TimeFormatSelect = styled(Select$1$1)(() => ({
    width: '12rem',
}));
const ConfigBoxWrapper = ({ FormComponent, errorMessage, showError }) => {
    return React.createElement(Grid, { container: true, display: 'flex', flexDirection: 'column' },
        React.createElement(Grid, { item: true },
            React.createElement(ConfigBox, null, FormComponent)),
        showError &&
            React.createElement(Grid, { item: true },
                React.createElement(ErrorBox, null,
                    React.createElement(FormHelperText, { error: true }, errorMessage))));
};
const SessionTimeoutConfigurationRow = ({ configKey, disabled }) => {
    const { injector } = useShadowDom();
    const [timeFormatFieldProps, { value: timeFormatFieldValue }] = useField(`${configKey}.timeFormat`);
    const [timeoutFieldProps, { value: timeoutFieldValue, error, touched }, { setValue: setTimeoutValue, setTouched: setTimeoutTouched }] = useField(`${configKey}.timeout`);
    const [, { value: fieldValue }, { setValue: setFieldValues }] = useField(configKey);
    const timeOptions = useTimeOptions(timeoutFieldValue);
    const onTimeoutChange = react.exports.useCallback((e) => {
        setTimeoutValue(e.currentTarget.value);
        setTimeoutTouched(true);
    }, [setTimeoutValue, setTimeoutTouched, timeFormatFieldValue]);
    const onTimeFormatChange = react.exports.useCallback((newFormat) => {
        setFieldValues(Object.assign(Object.assign({}, fieldValue), { timeFormat: newFormat }));
        setTimeoutTouched(true);
    }, [setFieldValues, setTimeoutTouched, fieldValue]);
    return React.createElement(ConfigBoxWrapper, { FormComponent: React.createElement(React.Fragment, null,
            React.createElement(TimeoutInput, Object.assign({}, timeoutFieldProps, { error: !!error && touched, onChange: onTimeoutChange, disabled: disabled, "data-test-id": `${configKey}_timeout_input` })),
            React.createElement(TimeFormatSelect, Object.assign({}, timeFormatFieldProps, { sx: { margin: 0 }, onChange: onTimeFormatChange, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: timeOptions, disabled: disabled, "data-test-id": `${configKey}_timeformat_input` }))), showError: (!!error && touched), errorMessage: error });
};
const SessionConcurrentConfigurationRow = ({ disabled }) => {
    const [maxSessionFieldProps, { error, touched }, { setValue: setMaxSessions }] = useField(`sessionConcurrentConfiguration.maxSessions`);
    const onMaxSessionsChange = react.exports.useCallback((e) => {
        const formValue = Number(e.currentTarget.value);
        setMaxSessions(formValue, true);
    }, [setMaxSessions]);
    return React.createElement(ConfigBoxWrapper, { FormComponent: React.createElement(TimeoutInput, Object.assign({}, maxSessionFieldProps, { disabled: disabled, onChange: onMaxSessionsChange })), showError: (!!error && touched), errorMessage: error });
};
const defaultValues = {
    sessionConcurrentConfiguration: {
        isActive: false,
        maxSessions: 10,
    },
    sessionIdleTimeoutConfiguration: {
        isActive: false,
        timeout: 5,
        timeFormat: ETimeFormat.MINUTES,
    },
    sessionTimeoutConfiguration: {
        isActive: false,
        timeout: 14,
        timeFormat: ETimeFormat.DAYS,
    }
};
const SessionsSettingsList = () => {
    const t = useT('security_SessionManagement');
    const [, { value: isSessionTimeoutActive }, { setValue: setSessionTimeoutToggled, setTouched: setSessionTimeoutToggleTouched }] = useField('sessionTimeoutConfiguration.isActive');
    const [, { value: isIdleSessionTimeoutActive }, { setValue: setIdleTimeoutToggled, setTouched: setIdleTimeoutToggleTouched }] = useField('sessionIdleTimeoutConfiguration.isActive');
    const [, { value: isConcurrentSessionActive }, { setValue: setConcurrentSessionToggled, setTouched: setConcurrentSessionToggleTouched }] = useField('sessionConcurrentConfiguration.isActive');
    const { loading } = useSessionPolicySettings();
    const { isSubmitting, isValid, dirty } = useFormikContext();
    const haveSecurityPolicyWritePermission = usePermission('fe.secure.write.securityPolicy');
    const isSaveButtonDisabled = react.exports.useMemo(() => !haveSecurityPolicyWritePermission ||
        isSubmitting ||
        loading ||
        !isValid ||
        !dirty, [isSubmitting, loading, isValid, dirty, haveSecurityPolicyWritePermission]);
    const onTimeoutToggle = react.exports.useCallback((_, toggled) => {
        setSessionTimeoutToggled(toggled);
        setSessionTimeoutToggleTouched(true);
    }, [setSessionTimeoutToggled, setSessionTimeoutToggleTouched]);
    const onIdleToggle = react.exports.useCallback((_, toggled) => {
        setIdleTimeoutToggled(toggled);
        setIdleTimeoutToggleTouched(true);
    }, [setIdleTimeoutToggled, setIdleTimeoutToggleTouched]);
    const onConcurrentToggle = react.exports.useCallback((_, toggled) => {
        setConcurrentSessionToggled(toggled);
        setConcurrentSessionToggleTouched(true);
    }, [setConcurrentSessionToggled, setConcurrentSessionToggleTouched]);
    const isFormDisabled = react.exports.useMemo(() => loading || isSubmitting || !haveSecurityPolicyWritePermission, [loading, isSubmitting, haveSecurityPolicyWritePermission]);
    const expandableItems = react.exports.useMemo(() => [
        {
            id: 'idle-row',
            title: t('idleSessionTimeoutTitle'),
            description: t('idleSessionTimeoutDescription'),
            actions: React.createElement(Switch$1$1, { checked: isIdleSessionTimeoutActive, onChange: onIdleToggle, disabled: isFormDisabled }),
            expandedRow: {
                expanded: isIdleSessionTimeoutActive,
                expandableRowComponent: React.createElement(SessionTimeoutConfigurationRow, { configKey: 'sessionIdleTimeoutConfiguration', disabled: isFormDisabled })
            },
        },
        {
            id: 'timeout-row',
            title: t('sessionTimeoutTitle'),
            description: t('sessionTimeoutDescription'),
            actions: React.createElement(Switch$1$1, { checked: isSessionTimeoutActive, onChange: onTimeoutToggle, disabled: isFormDisabled }),
            expandedRow: {
                expanded: isSessionTimeoutActive,
                expandableRowComponent: React.createElement(SessionTimeoutConfigurationRow, { configKey: 'sessionTimeoutConfiguration', disabled: isFormDisabled })
            }
        },
        {
            id: 'concurrent-row',
            title: t('concurrentSessionsTitle'),
            description: t('concurrentSessionsDescription'),
            actions: React.createElement(Switch$1$1, { checked: isConcurrentSessionActive, onChange: onConcurrentToggle, disabled: isFormDisabled }),
            expandedRow: {
                expanded: isConcurrentSessionActive,
                expandableRowComponent: React.createElement(SessionConcurrentConfigurationRow, { disabled: isFormDisabled })
            },
        }
    ], [onTimeoutToggle, onConcurrentToggle, onIdleToggle, isConcurrentSessionActive, isIdleSessionTimeoutActive, isSessionTimeoutActive, t]);
    return (React.createElement(SettingsList, { title: t('sectionTitle'), expandableItems: expandableItems, action: React.createElement(Button$1$1, { "data-test-id": "save-sessions-policy-btn", color: 'primary', disabled: isSaveButtonDisabled, type: 'submit' }, t('saveButton')) }));
};
const SessionsSettings = () => {
    const t = useT('security_SessionManagement');
    const [showConfirmPolicyDialog, handleClosePolicyDialog, handleOpenPolicyDialog] = useDialogState();
    const { configurations, loading, createOrUpdateSessionsPolicy } = useSessionPolicySettings(true);
    const { loadCurrentUserSession } = useSessionsActions();
    const { logout } = useLoginActions();
    const { currentSession } = useSessionsState();
    react.exports.useEffect(() => loadCurrentUserSession(), []);
    const initialValues = react.exports.useMemo(() => {
        var _a, _b, _c, _d, _e, _f, _g;
        const idleTimeoutCalculated = !!((_a = configurations.sessionIdleTimeoutConfiguration) === null || _a === void 0 ? void 0 : _a.timeout) && getTimeAndFormat(configurations.sessionIdleTimeoutConfiguration.timeout);
        const sessionTimeoutCalculated = !!((_b = configurations.sessionTimeoutConfiguration) === null || _b === void 0 ? void 0 : _b.timeout) && getTimeAndFormat(configurations.sessionTimeoutConfiguration.timeout);
        return ({
            sessionIdleTimeoutConfiguration: {
                isActive: !!((_c = configurations.sessionIdleTimeoutConfiguration) === null || _c === void 0 ? void 0 : _c.isActive),
                timeout: idleTimeoutCalculated ? idleTimeoutCalculated.timeout : defaultValues.sessionIdleTimeoutConfiguration.timeout,
                timeFormat: idleTimeoutCalculated ? idleTimeoutCalculated.timeFormat : defaultValues.sessionIdleTimeoutConfiguration.timeFormat
            },
            sessionTimeoutConfiguration: {
                isActive: !!((_d = configurations.sessionTimeoutConfiguration) === null || _d === void 0 ? void 0 : _d.isActive),
                timeout: sessionTimeoutCalculated ? sessionTimeoutCalculated.timeout : defaultValues.sessionTimeoutConfiguration.timeout,
                timeFormat: sessionTimeoutCalculated ? sessionTimeoutCalculated.timeFormat : defaultValues.sessionTimeoutConfiguration.timeFormat
            },
            sessionConcurrentConfiguration: {
                isActive: !!((_e = configurations.sessionConcurrentConfiguration) === null || _e === void 0 ? void 0 : _e.isActive),
                maxSessions: (_g = (_f = configurations.sessionConcurrentConfiguration) === null || _f === void 0 ? void 0 : _f.maxSessions) !== null && _g !== void 0 ? _g : defaultValues.sessionConcurrentConfiguration.maxSessions
            },
        });
    }, [configurations]);
    const submitForm = react.exports.useCallback((values, callback) => {
        const calculatedValues = {
            sessionConcurrentConfiguration: { isActive: values.sessionConcurrentConfiguration.isActive, maxSessions: values.sessionConcurrentConfiguration.maxSessions },
            sessionIdleTimeoutConfiguration: { isActive: values.sessionIdleTimeoutConfiguration.isActive, timeout: calculateTime(values.sessionIdleTimeoutConfiguration.timeout, values.sessionIdleTimeoutConfiguration.timeFormat) },
            sessionTimeoutConfiguration: { isActive: values.sessionTimeoutConfiguration.isActive, timeout: calculateTime(values.sessionTimeoutConfiguration.timeout, values.sessionTimeoutConfiguration.timeFormat) },
        };
        createOrUpdateSessionsPolicy(Object.assign(Object.assign({}, calculatedValues), { callback: callback }));
    }, [createOrUpdateSessionsPolicy, logout]);
    const handleSubmit = react.exports.useCallback((values, { setSubmitting, setTouched }) => {
        const currentSessionWillExpireDate = (currentSession === null || currentSession === void 0 ? void 0 : currentSession.createdAt) && new Date(new Date(currentSession.createdAt).getTime() + (calculateTime(values.sessionTimeoutConfiguration.timeout * 1000, values.sessionTimeoutConfiguration.timeFormat)));
        const willSessionExpireAfterConfirm = currentSessionWillExpireDate && currentSessionWillExpireDate < new Date(Date.now());
        if (willSessionExpireAfterConfirm) {
            handleOpenPolicyDialog();
        }
        else {
            submitForm(values, () => {
                setTouched({});
                setSubmitting(false);
            });
        }
    }, [currentSession, submitForm, handleOpenPolicyDialog]);
    const validationSchema = react.exports.useCallback(() => sessionManagementFormValidation(t), [t]);
    return (React.createElement(Formik, { enableReinitialize: true, initialValues: initialValues, onSubmit: handleSubmit, validationSchema: validationSchema }, ({ values, setSubmitting, submitCount }) => loading && submitCount === 0 ? React.createElement(SessionsSettingsListSkeleton, null) : React.createElement(React.Fragment, null,
        React.createElement(Form, null,
            React.createElement(SessionsSettingsList, null)),
        React.createElement(EnforceSessionPolicyDialog, { onClose: () => {
                handleClosePolicyDialog();
                setSubmitting(false);
            }, onConfirm: () => {
                submitForm(values, () => logout());
            }, open: showConfirmPolicyDialog }))));
};
var SessionsSettingsList$1 = SessionsSettings;

const SecurityPage$1 = () => {
    return React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(Box, { display: 'flex', flexDirection: 'column' },
            React.createElement(BasicSettingsList$1, null)),
        React.createElement(Box, { mt: 6, display: 'flex', flexDirection: 'column' },
            React.createElement(SessionsSettingsList$1, null)));
};
var SecurityPage$2 = SecurityPage$1;

var SecurityPage = wrapPage(SecurityPage$2, 'security');

const SsoHeader = ({ handleOpenNewConfiguration }) => {
    const t = useT('sso_Header');
    const canCreateNewConfiguration = usePermission('fe.secure.write.samlConfiguration');
    return React.createElement(Grid, { container: true, spacing: 4, alignItems: 'center' },
        React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
            React.createElement(Box, null, t('title'))),
        React.createElement(Grid, { item: true, xs: true }),
        canCreateNewConfiguration && React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": "CreateNewSsoConfigBtn", onClick: handleOpenNewConfiguration }, t('addNew'))));
};

var SamlVendors;
(function (SamlVendors) {
    SamlVendors["Saml"] = "saml";
    SamlVendors["Oidc"] = "oidc";
})(SamlVendors || (SamlVendors = {}));
var ConfigSaml;
(function (ConfigSaml) {
    ConfigSaml["manual"] = "manual";
    ConfigSaml["auto"] = "auto";
})(ConfigSaml || (ConfigSaml = {}));
const IDPS = [
    { value: SamlVendors.Saml, label: 'SAML' },
    { value: SamlVendors.Oidc, label: 'Open ID Connect' },
];
const defaultSamlVendor = SamlVendors.Saml;

const SsoTableColumns = ({ onChangeStatus, rolesMap, container, t, hasWritePermission, forcePermissions, showConfigureSSOMessage }) => {
    return [
        {
            Header: t('domainsColumnName'),
            Cell: TableTextCell,
            accessor: ({ domains }) => ({ description: domains === null || domains === void 0 ? void 0 : domains.map(({ domain }) => domain).join(', ') }),
            minWidth: forcePermissions ? 280 : 180
        },
        {
            Header: t('idpColumnName'),
            Cell: TableTextCell,
            accessor: ({ type }) => { var _a; return ({ description: (_a = IDPS.find((idp) => idp.value === type)) === null || _a === void 0 ? void 0 : _a.label }); },
        },
        forcePermissions && {
            Header: t('rolesColumnName'),
            Cell: TableChipsCell,
            accessor: ({ roleIds }) => { var _a; return ({ items: (_a = roleIds === null || roleIds === void 0 ? void 0 : roleIds.map((v) => ({ text: rolesMap[v] }))) !== null && _a !== void 0 ? _a : [], max: 2, container }); },
            minWidth: 280
        },
        {
            id: 'status',
            Header: t('statusColumnName'),
            Cell: TableSwitchCellLeft,
            accessor: (ssoConfig) => {
                const isStep1Checked = !!ssoConfig.publicCertificate || !!ssoConfig.oidcClientId;
                const isStep2Checked = ssoConfig.domains.some(({ validated }) => validated);
                const isStep3Checked = !!ssoConfig.roleIds.length;
                const canEnableDisableSSO = hasWritePermission && isStep1Checked && isStep2Checked && (isStep3Checked || !forcePermissions);
                return {
                    checked: canEnableDisableSSO && ssoConfig.enabled,
                    onChange: () => {
                        if (canEnableDisableSSO) {
                            onChangeStatus(ssoConfig);
                        }
                        else {
                            showConfigureSSOMessage();
                        }
                    }
                };
            },
            maxWidth: 100,
            minWidth: 100,
        },
    ].filter(notNull);
};
const useSSOTableRowActions = ({ container, handleOpenDeleteConfig, handleOpenEditConfig, hasWritePermission, hasDeletePermission, }) => {
    const t = useT('sso_Table');
    return react.exports.useMemo(() => (row) => {
        const items = [];
        const handleEditConfig = () => {
            handleOpenEditConfig(row);
        };
        const handleDeleteConfig = () => {
            handleOpenDeleteConfig(row);
        };
        if (hasWritePermission) {
            items.push({
                text: t('editSSOConfig'),
                onClick: handleEditConfig,
                icon: React.createElement(EditIcon, { "data-test-id": 'editBtn' }),
            });
        }
        if (hasDeletePermission) {
            items.push({
                negative: true,
                text: t('deleteSSOConfig'),
                onClick: handleDeleteConfig,
                icon: React.createElement(DeleteIcon, { "data-test-id": 'deleteBtn' }),
            });
        }
        return { items, container };
    }, [container, handleOpenDeleteConfig, handleOpenEditConfig, hasDeletePermission, hasWritePermission, t]);
};

const DeleteSSOConfigurationForm = ({ onClose, ssoConfig }) => {
    const t = useT('sso_Table');
    const { deleteSSOConfiguration } = useSSOActions();
    const { loaders: { DELETE_SSO_CONFIGURATION: loading }, errors: { DELETE_SSO_CONFIGURATION: error } } = useSSOState();
    const handleDeleteSSOConfig = react.exports.useCallback(() => {
        const callback = (success) => {
            if (success) {
                onClose();
            }
        };
        deleteSSOConfiguration({ ssoConfigId: ssoConfig.id, callback });
    }, [deleteSSOConfiguration, onClose]);
    return (React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, null,
            React.createElement(Typography$1, { variant: 'subtitle2Light' }, t('areYouSureDeleteSSOConfig')),
            React.createElement(FormErrorDialogMessage, { message: error })),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(Box, { flex: 1 }),
            React.createElement(Button$1, { "data-test-id": "cancelBtn", color: "inherit", variant: "text", onClick: onClose }, t('cancel')),
            React.createElement(Button$1, { "data-test-id": "deleteBtn", loading: loading, color: "danger", onClick: handleDeleteSSOConfig }, t('deleteSSOConfig')))));
};
const DeleteSSOConfigurationDialog = (_a) => {
    var { ssoConfig } = _a, props = __rest(_a, ["ssoConfig"]);
    const { injector } = useShadowDom();
    const t = useT('sso_Table');
    return (React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('deleteSSOConfigTitle') }),
        React.createElement(DeleteSSOConfigurationForm, Object.assign({ ssoConfig: ssoConfig }, props))));
};

const SSODialogContext = react.exports.createContext({
    stepNumber: 0,
    handleClose: () => { },
    handleOpen: () => { },
    handleNextStep: () => { },
    handlePrevStep: () => { },
    currentSSOConfiguration: {},
    setCurrentSSOConfigurationId: (id) => { },
    isFirstStep: true,
    isLastStep: false,
    steps: []
});
const useSSODialog = () => react.exports.useContext(SSODialogContext);
const SSODialogProvider = ({ children, steps, handleClose, handleOpen, initialSSOConfigurationId }) => {
    const [stepNumber, setStepNumber] = react.exports.useState(0);
    const [currentSSOConfigurationId, setCurrentSSOConfigurationId] = react.exports.useState(initialSSOConfigurationId);
    const { ssoConfigurations } = useSSOState();
    const { isLastStep, isFirstStep } = react.exports.useMemo(() => ({ isLastStep: stepNumber === steps.length - 1, isFirstStep: stepNumber === 0 }), [stepNumber, steps]);
    const handleNextStep = react.exports.useCallback(() => {
        if (!isLastStep) {
            setStepNumber((step) => step + 1);
        }
        else {
            handleClose();
        }
    }, [setStepNumber, isLastStep]);
    const handlePrevStep = react.exports.useCallback(() => {
        if (!isFirstStep) {
            setStepNumber((step) => step - 1);
        }
        else {
            handleClose();
        }
    }, [setStepNumber, isFirstStep]);
    return (React.createElement(SSODialogContext.Provider, { value: react.exports.useMemo(() => ({
            stepNumber,
            handleClose,
            handleOpen,
            handlePrevStep,
            handleNextStep,
            currentSSOConfiguration: ssoConfigurations.find((config) => config.id === currentSSOConfigurationId),
            setCurrentSSOConfigurationId,
            isFirstStep,
            isLastStep,
            steps,
        }), [
            setCurrentSSOConfigurationId,
            stepNumber,
            handleClose,
            handleOpen,
            handlePrevStep,
            handleNextStep,
            setStepNumber,
            currentSSOConfigurationId,
            ssoConfigurations,
            isFirstStep,
            isLastStep,
            steps,
        ]) }, children));
};

const ssoConfigureIdpFormValidation = ({ t }) => {
    return create$1().shape({
        configFile: create$3().when('samlVendor', {
            is: SamlVendors.Saml,
            then: create$3().when('configSaml', { is: 'auto', then: validateFile(t('metadataFileIsRequired')) }),
        }),
        ssoEndpoint: create$3().when('configSaml', {
            is: 'manual',
            then: create$3().when('samlVendor', {
                is: SamlVendors.Saml,
                then: validateUrl(t('endpointIsRequired'), t('endpointUrlIsInvalid')),
                otherwise: validateUrl(t('issuerUrlIsRequired'), t('issuerUrlIsInvalid')),
            }),
        }),
        publicCertificate: create$3().when('configSaml', {
            is: 'manual',
            then: create$3().when('samlVendor', {
                is: SamlVendors.Saml,
                then: validateNotEmpty(t('publicCertificateIsRequired')),
            }),
        }),
        oidcClientId: create$3().when('configSaml', {
            is: 'manual',
            then: create$3().when('samlVendor', {
                is: SamlVendors.Oidc,
                then: validateNotEmpty(t('clientIdIsRequired')),
            }),
        }),
        oidcSecret: create$3().when('configSaml', {
            is: 'manual',
            then: create$3().when('samlVendor', {
                is: SamlVendors.Oidc,
                then: validateNotEmpty(t('secretIsRequired')),
            }),
        }),
    });
};
const ssoManageAuthorizationValidation = (t) => {
    return create$1().shape({
        roleIds: create().min(1, t('rolesIsRequired')),
        rolesGroups: create().of(create$1().shape({ group: create$4().required(), roleIds: create().of(create$4()).min(1) })),
        addedGroups: create().of(create$1().shape({ group: create$4().required(), roleIds: create().of(create$4()).min(1) })),
    });
};

const SsoFooter = (props) => {
    const t = useT('sso_Table');
    const { isValid, isSubmitting, onCancel, onNext, showSkipButton, onSkip, approveButtonText } = props;
    const { handlePrevStep, isFirstStep, isLastStep } = useSSODialog();
    const handleCancelButton = react.exports.useCallback(() => {
        if (onCancel) {
            onCancel();
        }
        else {
            handlePrevStep();
        }
    }, [onCancel, handlePrevStep]);
    return React.createElement(React.Fragment, null,
        React.createElement(Button$1, { "data-test-id": "cancelBtn", color: "inherit", variant: "text", type: "reset", onClick: handleCancelButton }, isFirstStep ? t('cancel') : t('back')),
        React.createElement(Box, { flex: 1 }),
        React.createElement(Box, { display: 'flex' },
            showSkipButton && React.createElement(Button$1, { "data-test-id": 'skipBtn', onClick: onSkip, color: 'inherit', variant: "text" }, t('skip')),
            React.createElement(Button$1, { "data-test-id": 'approveBtn', disabled: !isValid, loading: isSubmitting, color: "primary", type: "submit", onClick: onNext }, approveButtonText !== null && approveButtonText !== void 0 ? approveButtonText : (isLastStep ? t('done') : t('proceed')))));
};

const useValidateWellKnownDebounced = ({ value, setError }) => {
    const t = useT('sso_ConfigureIdp');
    const debouncedValue = useDebounce(value, 500);
    const wellKnownError = t('ssoWellKnownError');
    useAsyncEffect(() => {
        if (!value) {
            setError(t('issuerUrlIsRequired'));
        }
        else {
            setError(wellKnownError);
        }
    }, [value, setError, wellKnownError, t]);
    react.exports.useEffect(() => {
        const controller = new AbortController();
        const abortSignal = controller.signal;
        if (debouncedValue) {
            validateWellKnown(debouncedValue, abortSignal).then((verified) => setError(verified ? '' : wellKnownError));
        }
        return () => controller.abort();
        // eslint-disable-next-line
    }, [debouncedValue]);
};
const IssuerUrlInput = styled(Input$1$1) `
  .MuiInputBase-adornedEnd {
    .MuiSvgIcon-root {
      ${({ theme, error }) => error && `color: ${theme.palette.error.main}`};
      ${({ theme, success }) => success && `color: ${theme.palette.success.main}`};
    }
  }
`;
const AcsUrlField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, { error, touched }] = useField('acsUrl');
    return React.createElement(Input$1$1, Object.assign({ label: t('acsUrlInputLabel') }, fieldProps, { errorMessage: error, error: !!error && touched, disabled: true }));
};
const EntityIdField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, { error, touched }] = useField('spEntityId');
    return React.createElement(Input$1$1, Object.assign({ label: t('entityIdInputLabel') }, fieldProps, { errorMessage: error, error: !!error && touched, disabled: true }));
};
const SsoEndpointField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, { error, touched }] = useField('ssoEndpoint');
    return (React.createElement(Input$1$1, Object.assign({ "data-tets-id": "ssoEndPointBox", label: t('endpointInputLabel') }, fieldProps, { errorMessage: error, error: !!error && touched, placeholder: t('endpointInputPlaceholder') })));
};
const IssuerUrlField = ({ setError, error }) => {
    const [fieldProps, { touched, error: formikError }] = useField({ name: 'ssoEndpoint' });
    const t = useT('sso_ConfigureIdp');
    useValidateWellKnownDebounced({ setError, value: fieldProps.value });
    return React.createElement(IssuerUrlInput, Object.assign({ "data-test-id": "issuerUrlBox", endAdornment: touched && (!!error) ? React.createElement(CheckCircleFilledIcon, null) : React.createElement(WarningIcon, null), label: t('issuerUrlInputLabel'), errorMessage: (touched && formikError) || error, error: !!((touched && formikError) || error), success: !(formikError || error), tip: t('issuerUrlInputHelpMessage') }, fieldProps));
};
const RedirectUriField = () => {
    var _a;
    const t = useT('sso_ConfigureIdp');
    const { oidcRedirectUrl } = useAuthRoutes();
    const { origin } = window.location;
    const defaultRedirectUri = `${origin}${oidcRedirectUrl}`;
    const { oidcConfiguration } = useSSOState();
    return React.createElement(Input$1$1, { label: t('redirectUriInputLabel'), value: (_a = oidcConfiguration === null || oidcConfiguration === void 0 ? void 0 : oidcConfiguration.redirectUri) !== null && _a !== void 0 ? _a : defaultRedirectUri, disabled: true });
};
const OidcClientIdField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, { error, touched }] = useField('oidcClientId');
    return (React.createElement(Input$1$1, Object.assign({ "data-test-id": "clientIDBox", label: t('clientIdInputLabel') }, fieldProps, { errorMessage: error, error: !!error && touched, placeholder: t('clientIdInputPlaceholder') })));
};
const PublicSertificateField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, { error, touched }] = useField('publicCertificate');
    return (React.createElement(Input$1$1, Object.assign({ "data-tets-id": "publicCertificateBox", multiline: true, rows: 4, label: t('publicCertificateInputLabel') }, fieldProps, { errorMessage: error, error: !!error && touched, placeholder: t('publicCertificateInputPlaceholder') })));
};
const OidcSecretField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, { error, touched }] = useField('oidcSecret');
    return (React.createElement(InputPassword$1, Object.assign({ "data-test-id": "secretBox", label: t('secretInputLabel') }, fieldProps, { errorMessage: error, error: !!error && touched, placeholder: t('secretInputPlaceholder') })));
};
const IdpField = () => {
    const t = useT('sso_ConfigureIdp');
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue }] = useField('samlVendor');
    const [, , { setValue: setConfigSaml }] = useField('configSaml');
    const handleOnChange = react.exports.useCallback((value) => {
        setValue(value, true);
        setConfigSaml(ConfigSaml.manual);
    }, [setValue, setConfigSaml]);
    return (React.createElement(Select$1$1, { "data-test-id": "ssoSelectIdpDrop", label: t('idpSelectLabel'), name: fieldProps.name, value: fieldProps.value, onChange: handleOnChange, errorMessage: touched ? error : undefined, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: IDPS }));
};
const ConfigSamlField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, , { setValue }] = useField('configSaml');
    const handleSetValue = react.exports.useCallback(() => {
        const value = fieldProps.value === ConfigSaml.manual ? ConfigSaml.auto : ConfigSaml.manual;
        setValue(value);
    }, [fieldProps, setValue]);
    return React.createElement(Box, { mb: 4 },
        React.createElement(RadioGroup, { row: true, defaultValue: "manual", onChange: handleSetValue },
            React.createElement(FormControlLabel, { "data-test-id": "autoBtn", value: "auto", control: React.createElement(Radio, null), label: t('radioAutomaticLabel') }),
            React.createElement(FormControlLabel, { "data-test-id": "menualBtn", value: "manual", control: React.createElement(Radio, null), label: t('radioManualLabel') })));
};
const DropZoneField = () => {
    const t = useT('sso_ConfigureIdp');
    const [fieldProps, { error, touched }, { setValue, setError, setTouched }] = useField('configFile');
    const handleSetValue = react.exports.useCallback((files) => {
        setTouched(true);
        if (!files.length) {
            setError(t('metadataFileTypeErrorMessage'));
        }
        else {
            setError(null);
            setValue(files);
        }
    }, [setValue]);
    return (React.createElement(React.Fragment, null,
        React.createElement(Box, { "data-test-id": "metadataFileBox", marginBottom: "8px" },
            React.createElement(Typography$1, { color: touched && !!error ? 'error' : undefined, variant: "label" }, t('metadataFileLabel'))),
        React.createElement(DropZoneElement, { "data-test-id": "metadataFileBox", fileType: ".xml", value: fieldProps.value, onDrop: handleSetValue, description: t('metadataFileDescription') }),
        touched && !!error && React.createElement(FormErrorDialogMessage, { message: error })));
};

const SsoConfigureIdpBottomInputs = React.memo(({ samlVendor, setIssuerUrlError, issuerUrlError }) => {
    return (samlVendor === SamlVendors.Oidc ? (React.createElement(React.Fragment, null,
        React.createElement(IssuerUrlField, { error: issuerUrlError, setError: setIssuerUrlError }),
        React.createElement(OidcClientIdField, null),
        React.createElement(OidcSecretField, null),
        React.createElement(RedirectUriField, null))) : (React.createElement(React.Fragment, null,
        React.createElement(SsoEndpointField, null),
        React.createElement(PublicSertificateField, null))));
});
const SsoConfigureIdpForm = () => {
    const t = useT('sso_ConfigureIdp');
    const { saveSSOConfigurationV2, updateSSOConfiguration, saveSSOConfigurationByMetadata, updateSSOConfigurationByMetadata } = useSSOActions();
    const { currentSSOConfiguration, setCurrentSSOConfigurationId, handleNextStep } = useSSODialog();
    const { samlMetadata } = useSSOState();
    const [issuerUrlError, setIssuerUrlError] = react.exports.useState('');
    const initialSamlVendor = react.exports.useMemo(() => Object.values(SamlVendors).includes(currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.type)
        ? currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.type
        : defaultSamlVendor, [currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.type]);
    const validationSchema = react.exports.useMemo(() => ssoConfigureIdpFormValidation({ t }), [t]);
    const initialValues = react.exports.useMemo(() => {
        var _a, _b, _c, _d;
        return (Object.assign(Object.assign({ samlVendor: initialSamlVendor, configFile: undefined, configSaml: ConfigSaml.manual }, currentSSOConfiguration), { acsUrl: (_a = currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.acsUrl) !== null && _a !== void 0 ? _a : (_b = samlMetadata === null || samlMetadata === void 0 ? void 0 : samlMetadata.configuration) === null || _b === void 0 ? void 0 : _b.acsUrl, spEntityId: (_c = currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.spEntityId) !== null && _c !== void 0 ? _c : (_d = samlMetadata === null || samlMetadata === void 0 ? void 0 : samlMetadata.configuration) === null || _d === void 0 ? void 0 : _d.spEntityId }));
    }, [currentSSOConfiguration, samlMetadata, initialSamlVendor]);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, (data) => {
                setCurrentSSOConfigurationId(data.id);
                handleNextStep();
            });
            const isEditMode = !!currentSSOConfiguration;
            const { samlVendor, configSaml } = values;
            const isOidcConfiguration = samlVendor === SamlVendors.Oidc;
            if (configSaml === 'auto' && !isOidcConfiguration) {
                const payload = { configFile: values.configFile[0], callback };
                if (isEditMode) {
                    updateSSOConfigurationByMetadata(Object.assign({ ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id }, payload));
                }
                else {
                    saveSSOConfigurationByMetadata(payload);
                }
            }
            else {
                const { ssoEndpoint, publicCertificate, oidcClientId, oidcSecret } = values;
                const payload = {
                    ssoEndpoint,
                    type: samlVendor,
                    publicCertificate: isOidcConfiguration ? undefined : publicCertificate,
                    oidcClientId: isOidcConfiguration ? oidcClientId : undefined,
                    oidcSecret: isOidcConfiguration ? oidcSecret : undefined,
                    callback
                };
                if (isEditMode) {
                    updateSSOConfiguration(Object.assign(Object.assign({}, payload), { ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id }));
                }
                else {
                    saveSSOConfigurationV2(Object.assign(Object.assign({}, payload), { enabled: false }));
                }
            }
        }),
        initialValues,
        validationSchema,
        validateOnMount: true
    };
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ values, isValid, formError, isSubmitting }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(Box, null,
                    React.createElement(IdpField, null),
                    values.samlVendor !== SamlVendors.Oidc &&
                        React.createElement(React.Fragment, null,
                            React.createElement(AcsUrlField, null),
                            React.createElement(EntityIdField, null),
                            React.createElement(ConfigSamlField, null)),
                    values.configSaml === ConfigSaml.auto && values.samlVendor === SamlVendors.Saml
                        ? React.createElement(DropZoneField, null)
                        : React.createElement(SsoConfigureIdpBottomInputs, { samlVendor: values.samlVendor, issuerUrlError: issuerUrlError, setIssuerUrlError: setIssuerUrlError })),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(SsoFooter, { isValid: isValid && (values.samlVendor !== SamlVendors.Oidc || !issuerUrlError), isSubmitting: isSubmitting }))));
    }));
};

const DomainFields = ({ ssoDomain }) => {
    const t = useT('sso_ClaimDomain');
    const [fieldProps, { error, touched, value }] = useField('domain');
    const { currentSSOConfiguration } = useSSODialog();
    const recordValue = react.exports.useMemo(() => currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.generatedVerification, [currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.generatedVerification]);
    const recordName = react.exports.useMemo(() => `_saml-domain-challenge.${value}`, [value]);
    return React.createElement(React.Fragment, null,
        React.createElement(Input$1$1, Object.assign({ label: t('domainInputLabel') }, fieldProps, { "data-test-id": "domainNameBox", errorMessage: error, error: !!error && touched, placeholder: t('domainInputPlaceholder') })),
        React.createElement(Collapse$1, { in: (ssoDomain === null || ssoDomain === void 0 ? void 0 : ssoDomain.domain) === value, mountOnEnter: true, unmountOnExit: true },
            React.createElement(Typography$1, { variant: "subtitle2" }, t('claimDomainText')),
            React.createElement("br", null),
            React.createElement(InputCopy$1, { "data-test-id": "ssoRecordNameLabel", label: t('recordNameLabel'), readOnly: true, value: recordName !== null && recordName !== void 0 ? recordName : '' }),
            React.createElement(InputCopy$1, { "data-test-id": "ssoRecordValueLabel", label: t('recordValueLabel'), readOnly: true, value: recordValue !== null && recordValue !== void 0 ? recordValue : '' })));
};

const AddDomainButton = styled(Button$1) `
  align-self: flex-start;
`;
const DomainInput = styled(Input$1$1) `
  margin-bottom: 0;
  margin-right: 0.5rem;
  flex: 1;
  .MuiInputBase-adornedEnd {
    .MuiSvgIcon-root {
      ${({ theme, error }) => error && `color: ${theme.palette.error.main}`};
      ${({ theme, success }) => success && `color: ${theme.palette.success.main}`};
    }
  }
`;
const DeleteIconStyle = styled(DeleteIcon)(({ theme }) => ({
    color: theme.palette.grey[500],
    width: '1rem',
    height: '1rem',
}));
const EditIconStyle = styled(EditIcon)(({ theme }) => ({
    color: theme.palette.grey[500],
    width: '1rem',
    height: '1rem',
}));
const IconButtonStyle = styled(IconButton) `
  width: 2rem;
  height: 2rem;
`;
const DomainListContainer = styled(Box)(({ theme }) => ({
    paddingBottom: theme.spacing(2),
    marginBottom: theme.spacing(4),
    borderBottom: `1px solid ${theme.palette.grey[300]}`
}));
const SSOClaimDomainList = ({ onAddDomain, onEditDomain, hideDomainList }) => {
    var _a;
    const { currentSSOConfiguration, handlePrevStep } = useSSODialog();
    const { deleteSSODomain } = useSSOActions();
    const hasWritePermission = usePermission('fe.secure.write.samlConfiguration');
    const hasDeletePermission = usePermission('fe.secure.delete.samlConfiguration');
    const handleDeleteDomain = react.exports.useCallback((domainId) => {
        const callback = () => {
            if ((currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.domains.length) === 1) {
                handlePrevStep();
            }
        };
        deleteSSODomain({ ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id, domainId, callback });
    }, [deleteSSODomain, currentSSOConfiguration]);
    return (React.createElement(React.Fragment, null,
        React.createElement(DomainListContainer, null, (_a = currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.domains) === null || _a === void 0 ? void 0 : _a.map((ssoDomain) => React.createElement(Box, { key: ssoDomain.id, mb: 2, display: 'flex', alignItems: 'center' },
            React.createElement(DomainInput, { "data-test-id": ssoDomain.domain, endAdornment: ssoDomain.validated ? React.createElement(CheckCircleFilledIcon, null) : React.createElement(WarningIcon, null), error: !ssoDomain.validated, success: ssoDomain.validated, value: ssoDomain.domain, disabled: true }),
            hasWritePermission && hasDeletePermission && React.createElement(IconButtonStyle, { onClick: () => onEditDomain(ssoDomain) },
                React.createElement(EditIconStyle, null)),
            hasDeletePermission && React.createElement(IconButtonStyle, { onClick: () => handleDeleteDomain(ssoDomain.id) },
                React.createElement(DeleteIconStyle, null))))),
        React.createElement(AddDomainButton, { "data-test-id": "addGroupBtn", onClick: onAddDomain, type: 'button', size: 'small', color: 'secondary' }, "Add another domain")));
};

const SsoClaimDomainForm = (props) => {
    const t = useT('sso_ClaimDomain');
    const [ssoDomain, setSSODomain] = react.exports.useState(props.domain);
    const { saveSSODomain, validateSSODomainV2, deleteSSODomain } = useSSOActions();
    const { currentSSOConfiguration, handleNextStep } = useSSODialog();
    const [isDomainListShown, setIsDomainListShown] = react.exports.useState((currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.domains.length) > 0);
    const initialValues = react.exports.useMemo(() => ({
        domain: (ssoDomain === null || ssoDomain === void 0 ? void 0 : ssoDomain.domain) || '',
    }), [ssoDomain]);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        domain: validateDomain(t('domainIsRequired'), t('domainMustBeValid')),
    }), [t]);
    const formikProps = {
        onSubmit: ({ domain }) => new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
            const callback = callbackToPromise(resolve, reject, showDomainList);
            const saveDomain = () => {
                saveSSODomain({
                    ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id,
                    domain,
                    callback: (data, error) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        else if (data) {
                            setSSODomain(data);
                            resolve();
                        }
                    }
                });
            };
            if (ssoDomain && ssoDomain.domain === domain) {
                validateSSODomainV2({ callback, domainId: ssoDomain.id, ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id });
            }
            else if (ssoDomain) {
                deleteSSODomain({ ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id, domainId: ssoDomain.id, callback: saveDomain });
            }
            else {
                saveDomain();
            }
        })),
        enableReinitialize: true,
        initialValues,
        validationSchema: isDomainListShown ? undefined : validationSchema,
    };
    const showDomainList = react.exports.useCallback(() => {
        setIsDomainListShown(true);
    }, []);
    const hideDomainList = react.exports.useCallback(() => {
        setIsDomainListShown(false);
    }, []);
    const handleEditDomain = react.exports.useCallback((ssoDomain) => {
        hideDomainList();
        setSSODomain(ssoDomain);
    }, [hideDomainList, setSSODomain]);
    const handleAddDomain = react.exports.useCallback(() => {
        hideDomainList();
        setSSODomain(undefined);
    }, [hideDomainList, setSSODomain]);
    if (isDomainListShown) {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(SSOClaimDomainList, { hideDomainList: hideDomainList, onAddDomain: handleAddDomain, onEditDomain: handleEditDomain })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(SsoFooter, { isValid: true, isSubmitting: false, onNext: handleNextStep }))));
    }
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ formError, isSubmitting, values }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(DomainFields, { ssoDomain: ssoDomain }),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(SsoFooter, { onCancel: (currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.domains.length) > 1 ? showDomainList : undefined, isValid: true, isSubmitting: isSubmitting, showSkipButton: (ssoDomain === null || ssoDomain === void 0 ? void 0 : ssoDomain.domain) === values.domain, onSkip: showDomainList, approveButtonText: (ssoDomain === null || ssoDomain === void 0 ? void 0 : ssoDomain.domain) === values.domain ? t('validate') : t('proceed') }))));
    }));
};

const ArrowsIconStyled = styled(DoubleArrowRightIcon)(({ theme }) => ({
    width: '0.5rem',
    height: '0.5rem',
    color: theme.palette.grey[500],
}));
const GroupNameField = react.exports.memo(({ error, errorMessage, group, handleGroupChange }) => {
    return React.createElement(Input$1$1, { error: error, errorMessage: errorMessage, value: group, onChange: handleGroupChange });
}, shallowEqual$1('error', 'errorMessage', 'group', 'handleGroupChange'));
const RolesField$1 = react.exports.memo(({ roles, handleRolesChange, groupId, error }) => {
    const t = useT('sso_ManageAuthorization');
    const { injector } = useShadowDom();
    const user = useAuthUser();
    const allRoles = useAuthTeamState(state => state.roles);
    const accessRoles = checkRoleAccess(allRoles, user);
    const options = react.exports.useMemo(() => (accessRoles !== null && accessRoles !== void 0 ? accessRoles : []).map(role => ({ label: role.name, value: role.id, withCheckbox: true })), [accessRoles]);
    return React.createElement(Select$1$1, { error: error, errorMessage: t('rolesGroupsMappingError'), name: `${groupId}_roleIds`, multi: true, oneLineMulti: true, placeholder: t('rolesInputPlaceholder'), value: roles, onChange: handleRolesChange, options: options, optionType: "tree", container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl });
}, shallowEqual$1('roles', 'handleRolesChange', 'groupId', 'error'));
const DeleteGroupButton = react.exports.memo(({ onDelete }) => {
    return React.createElement(IconButton, { onClick: () => onDelete() },
        React.createElement(Box, { component: DeleteIcon, width: "1rem", height: "1rem", color: "#ADBCD2" }));
}, shallowEqual$1('onDelete'));
const RolesGroup = ({ groupId }) => {
    var _a, _b;
    const t = useT('sso_ManageAuthorization');
    const { values, setFieldValue, setFieldError } = useFormikContext();
    const fieldValue = react.exports.useMemo(() => values.rolesGroups.find((group) => group.id === groupId), [values.rolesGroups, groupId]);
    const isGroupNameUnique = react.exports.useMemo(() => values.rolesGroups.filter(({ group }) => group === (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.group)).length < 2, [values.rolesGroups, fieldValue]);
    react.exports.useEffect(() => {
        if (!isGroupNameUnique) {
            setFieldError('rolesGroups', t('rolesGroupsNameDuplicateError'));
        }
    }, [isGroupNameUnique, setFieldError, t]);
    const handleGroupNameChange = react.exports.useCallback((e) => {
        const groupIdx = values.rolesGroups.findIndex((group) => group.id === groupId);
        const newRolesGroupsArray = values.rolesGroups.map((oldValue, currIdx) => currIdx === groupIdx ? Object.assign(Object.assign({}, oldValue), { group: e.target.value }) : oldValue);
        setFieldValue('rolesGroups', newRolesGroupsArray);
    }, [setFieldValue, values.rolesGroups, groupId]);
    const handleRolesChange = react.exports.useCallback((newValue) => {
        const changedGroups = [];
        const groupIdx = values.rolesGroups.findIndex((group) => group.id === groupId);
        const newrolesGroups = values.rolesGroups.map((oldValue, currIdx) => {
            let rolesGroup = oldValue;
            if (currIdx === groupIdx) {
                rolesGroup = Object.assign(Object.assign({}, oldValue), { roleIds: newValue });
                changedGroups.push(rolesGroup);
            }
            return rolesGroup;
        });
        setFieldValue('rolesGroups', newrolesGroups);
        setFieldValue('changedGroups', changedGroups);
    }, [setFieldValue, values.rolesGroups, values.changedGroups, groupId]);
    const deleteGroup = react.exports.useCallback(() => {
        const newDeletedGroupsArr = [...values.deletedGroups, groupId];
        const newGroupsArr = values.rolesGroups.filter((group) => !newDeletedGroupsArr.includes(group.id));
        setFieldValue('deletedGroups', newDeletedGroupsArr);
        setFieldValue('rolesGroups', newGroupsArr);
    }, [setFieldValue, groupId, values.rolesGroups, values.deletedGroups]);
    return React.createElement(Grid, { container: true, alignItems: 'baseline', justifyContent: "space-between", spacing: 2 },
        React.createElement(Grid, { item: true, xs: 5 },
            React.createElement(GroupNameField, { group: (_a = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.group) !== null && _a !== void 0 ? _a : '', handleGroupChange: handleGroupNameChange, error: !isGroupNameUnique || (!!fieldValue && fieldValue.group.length < 1), errorMessage: isGroupNameUnique ? t('rolesGroupsNameEmptyError') : t('rolesGroupsNameDuplicateError') })),
        React.createElement(Grid, { item: true, xs: 1, display: "flex", justifyContent: "center" },
            React.createElement(ArrowsIconStyled, null)),
        React.createElement(Grid, { item: true, xs: 5 },
            React.createElement(RolesField$1, { roles: (_b = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.roleIds) !== null && _b !== void 0 ? _b : [], error: fieldValue && fieldValue.roleIds.length < 1, handleRolesChange: handleRolesChange, groupId: groupId })),
        React.createElement(Grid, { item: true, xs: 1, display: "flex", justifyContent: "center" },
            React.createElement(DeleteGroupButton, { onDelete: deleteGroup })));
};
const NewRolesGroup = ({ idx }) => {
    var _a, _b;
    const t = useT('sso_ManageAuthorization');
    const { values, setFieldValue, setFieldError } = useFormikContext();
    const fieldValue = react.exports.useMemo(() => values.addedGroups[idx], [idx, values.addedGroups]);
    const isGroupNameUnique = react.exports.useMemo(() => [...values.rolesGroups, ...values.addedGroups].filter(({ group }) => group === (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.group)).length < 2, [values, fieldValue]);
    react.exports.useEffect(() => {
        if (!isGroupNameUnique) {
            setFieldError('addedGroups', 'Group name must be unique');
        }
    }, [isGroupNameUnique, setFieldError]);
    const handleGroupNameChange = react.exports.useCallback((e) => {
        const newRolesGroupsArray = values.addedGroups.map((oldValue, currIdx) => currIdx === idx ? Object.assign(Object.assign({}, oldValue), { group: e.target.value }) : oldValue);
        setFieldValue('addedGroups', newRolesGroupsArray);
    }, [setFieldValue, values.addedGroups, idx]);
    const handleRolesChange = react.exports.useCallback((newValue) => {
        const newrolesGroups = values.addedGroups.map((oldValue, currIdx) => currIdx === idx ? Object.assign(Object.assign({}, oldValue), { roleIds: newValue }) : oldValue);
        setFieldValue('addedGroups', newrolesGroups);
    }, [setFieldValue, values.addedGroups, idx]);
    const deleteGroup = react.exports.useCallback(() => {
        const newGroupsArr = values.addedGroups.filter((group, index) => idx !== index);
        setFieldValue('addedGroups', newGroupsArr);
    }, [setFieldValue, idx, values.addedGroups]);
    return React.createElement(Grid, { container: true, alignItems: 'baseline', justifyContent: "space-between", spacing: 2 },
        React.createElement(Grid, { item: true, xs: 5 },
            React.createElement(GroupNameField, { group: (_a = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.group) !== null && _a !== void 0 ? _a : '', handleGroupChange: handleGroupNameChange, error: !isGroupNameUnique || (!!fieldValue && fieldValue.group.length < 1), errorMessage: isGroupNameUnique ? t('rolesGroupsNameEmptyError') : t('rolesGroupsNameDuplicateError') })),
        React.createElement(Grid, { item: true, xs: 1, display: "flex", justifyContent: "center" },
            React.createElement(ArrowsIconStyled, null)),
        React.createElement(Grid, { item: true, xs: 5 },
            React.createElement(RolesField$1, { roles: (_b = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.roleIds) !== null && _b !== void 0 ? _b : [], error: fieldValue && fieldValue.roleIds.length < 1, handleRolesChange: handleRolesChange, groupId: `${idx}` })),
        React.createElement(Grid, { item: true, xs: 1, display: "flex", justifyContent: "center" },
            React.createElement(DeleteGroupButton, { onDelete: deleteGroup })));
};

const AddMappingButton = styled(Button$1) `
  &.MuiButton-root {
    justify-content: space-between;
    height: 2rem;
    margin-top: 1rem;
    display: flex;
    padding: 1rem;
    align-self: flex-start;
    .MuiSvgIcon-root {
      padding-right: .5rem;
    }
  }
`;
const TableHeadRowGrid = styled(Grid) `
  background-color: #F5F6F8;
  padding: 0.75rem 2rem;
  border-bottom: 1px solid #E5EAF3;
`;
const TableBodyGrid = styled(Grid) `
  padding: 1rem 1rem 1rem 2rem;
`;
const AddIconStyle = styled(AddIcon) `
  width: 0.75rem;
  height: 0.75rem,
`;
const AddIconButton = styled(Button$1) `
  margin-bottom: 1rem;
  margin-left: 2rem;
  minWidth: 0;
  width: fit-content;
  padding: 0.75rem;
  color: #ADBCD2;
`;
const GroupsTable = react.exports.memo(({ addGroup }) => {
    var _a;
    const { values } = useFormikContext();
    const t = useT('sso_ManageAuthorization');
    return React.createElement(Box, { mt: 3, flex: 1, border: '1px solid #E5EAF3', borderRadius: '0.25rem', display: 'flex', flexDirection: 'column' },
        React.createElement(TableHeadRowGrid, { container: true },
            React.createElement(Grid, { item: true, xs: 6 },
                React.createElement(Typography$1, { variant: 'label' },
                    " ",
                    t('group'))),
            React.createElement(Grid, { item: true, xs: 6 },
                React.createElement(Typography$1, { marginLeft: '0.75rem', variant: 'label' },
                    " ",
                    t('roles')))),
        React.createElement(TableBodyGrid, { container: true },
            values.rolesGroups.map((g) => React.createElement(RolesGroup, { "data-test-id": "groupBox", groupId: g.id })), (_a = values.addedGroups) === null || _a === void 0 ? void 0 :
            _a.map((g, idx) => React.createElement(NewRolesGroup, { idx: idx }))),
        React.createElement(AddIconButton, { "data-test-id": "addGroupBtn", onClick: addGroup, type: 'button', size: 'small', color: 'secondary' },
            React.createElement(AddIconStyle, null)));
}, shallowEqual$1('addGroup'));
const findNewGroups = (existingGroups, newGroups) => {
    const existingGroupsIds = existingGroups.map(({ id }) => id);
    const groupsToAdd = newGroups.filter((g) => !existingGroupsIds.includes(g.id));
    return groupsToAdd;
};
const RolesGroupsTable = () => {
    const t = useT('sso_ManageAuthorization');
    const { rolesGroups } = useSSOState();
    const { values, setFieldValue } = useFormikContext();
    react.exports.useEffect(() => {
        const existingGroupsIds = [...values.rolesGroups.map(({ id }) => id), ...values.deletedGroups];
        const isNewGroupAdded = rolesGroups === null || rolesGroups === void 0 ? void 0 : rolesGroups.some(({ id }) => !existingGroupsIds.includes(id));
        if (isNewGroupAdded) {
            const newGroup = findNewGroups(values.rolesGroups, rolesGroups !== null && rolesGroups !== void 0 ? rolesGroups : []);
            let newFieldValue = [...values.rolesGroups];
            if (newGroup) {
                newFieldValue = newFieldValue.concat(newGroup);
            }
            setFieldValue('rolesGroups', newFieldValue.filter((group) => !values.deletedGroups.includes(group.id)));
        }
    }, [values, rolesGroups, setFieldValue]);
    const shouldShowTable = react.exports.useMemo(() => [...values.addedGroups, ...values.rolesGroups].length > 0, [values]);
    const addGroup = react.exports.useCallback(() => {
        const newAddedGroupsValue = [...values.addedGroups];
        newAddedGroupsValue.push({ group: '', roleIds: [] });
        setFieldValue('addedGroups', newAddedGroupsValue);
    }, [values.addedGroups, setFieldValue]);
    return React.createElement(React.Fragment, null,
        React.createElement(Typography$1, { marginTop: '2rem', fontSize: '1rem', variant: 'label' }, t('rolesGroupsMappingTitle')),
        React.createElement(Typography$1, { fontWeight: '600', color: 'GrayText', variant: 'subtitle2Light' }, t('rolesGroupsMappingDescription')),
        shouldShowTable ?
            React.createElement(GroupsTable, { addGroup: addGroup })
            :
                React.createElement(AddMappingButton, { "data-test-id": "addMappingBtn", color: 'secondary', onClick: addGroup, type: 'button', size: 'small' }, t('ssoAddMapping')));
};

const isAllGroupNamesUnique = (values) => {
    const uniquedValues = values.rolesGroups.reduce((acc, { group }) => (acc.includes(group) ? acc : [...acc, group]), []);
    return uniquedValues.length === values.rolesGroups.length;
};
const InputTipIcon = styled(InfoIcon) `
  &.MuiSvgIcon-root {
    width: 0.75rem !important;
    height: 0.75rem !important;
    fill: #ADBCD2;
  }
`;
const SsoManageAuthorizationForm = () => {
    const t = useT('sso_ManageAuthorization');
    const { setSSODefaultRoles, setSSOGroups, updateSSOGroups } = useSSOActions();
    const { currentSSOConfiguration, handleNextStep } = useSSODialog();
    const { injector } = useShadowDom();
    const initialValues = react.exports.useMemo(() => {
        var _a, _b;
        return ({
            roleIds: (_a = currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.roleIds) !== null && _a !== void 0 ? _a : [],
            rolesGroups: (_b = currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.groups) !== null && _b !== void 0 ? _b : [],
            deletedGroups: [],
            addedGroups: [],
            changedGroups: [],
        });
    }, []);
    const formikProps = {
        onSubmit: (values) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject, handleNextStep);
            setSSOGroups({
                ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id,
                groupsToAdd: values.addedGroups,
                groupsToDelete: values.deletedGroups,
                callback: (data, error) => {
                    if (error) {
                        reject(error);
                        return;
                    }
                    else if (data) {
                        updateSSOGroups({ ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id, changedGroups: values.changedGroups });
                        setSSODefaultRoles({ ssoConfigId: currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.id, roleIds: values === null || values === void 0 ? void 0 : values.roleIds, callback });
                    }
                },
            });
        }),
        initialValues,
        validationSchema: ssoManageAuthorizationValidation(t),
        validateOnMount: true,
    };
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ formError, isSubmitting, isValid, values }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, { style: { maxHeight: '55vh' } },
                React.createElement(React.Fragment, null,
                    React.createElement(Box, { display: "flex", alignItems: "center", width: "fit-content" },
                        React.createElement(Typography$1, { variant: "label", paddingBottom: "0.25rem" }, t('selectRolesLabel')),
                        React.createElement(Popup$1, { action: "hover", mountNode: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, placement: "right", arrow: true, trigger: React.createElement(Box, { display: "flex", marginLeft: "0.5rem", marginBottom: "0.25rem" },
                                React.createElement(InputTipIcon, null)) },
                            React.createElement(Typography$1, { color: "#3C4A5A", variant: "subtitle2Light" }, t('selectRolesHelpMessage')))),
                    React.createElement(RolesField$4, { label: "", placeholder: t('rolesInputPlaceholder') }),
                    (currentSSOConfiguration === null || currentSSOConfiguration === void 0 ? void 0 : currentSSOConfiguration.type) === SamlVendors.Saml && React.createElement(RolesGroupsTable, null),
                    React.createElement(FormErrorDialogMessage, { message: formError }))),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(SsoFooter, { isValid: isValid || !isAllGroupNamesUnique(values), isSubmitting: isSubmitting }))));
    }));
};

const StepperStyle = styled(Stepper$1) `
  padding: ${({ theme }) => theme.spacing(4)};
`;
const MultiStepForm = () => {
    const { stepNumber, steps } = useSSODialog();
    return React.createElement(React.Fragment, null,
        React.createElement(StepperStyle, { activeStep: stepNumber }, steps.map(({ label }) => (React.createElement(Step$1, { key: label },
            React.createElement(StepLabel$1, null, label))))),
        steps[stepNumber].component);
};
const SsoConfigurationDialogForm = ({ open, handleOpen, handleClose, initialSSOConfigurationId }) => {
    const { injector } = useShadowDom();
    const { policy } = usePublicPolicySettings();
    const t = useT('sso');
    const steps = react.exports.useMemo(() => {
        return [
            {
                component: React.createElement(SsoConfigureIdpForm, null),
                label: t('stepOneTitle'),
            },
            {
                component: React.createElement(SsoClaimDomainForm, null),
                label: t('stepTwoTitle'),
            },
            ...((policy === null || policy === void 0 ? void 0 : policy.forcePermissions) ?
                [{
                        component: React.createElement(SsoManageAuthorizationForm, null),
                        label: t('stepThreeTitle'),
                    }]
                : []),
        ];
    }, [policy === null || policy === void 0 ? void 0 : policy.forcePermissions]);
    return (React.createElement(Dialog$1, { topGravity: false, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, title: 'Configure SSO', open: open, onClose: handleClose },
        React.createElement(SSODialogProvider, { steps: steps, handleOpen: handleOpen, handleClose: handleClose, initialSSOConfigurationId: initialSSOConfigurationId },
            React.createElement(MultiStepForm, null))));
};

const SsoTable = ({ showConfigureSSOMessage }) => {
    var _a;
    const t = useT('sso_Table');
    const { injector } = useShadowDom();
    const { roles } = useAuthTeamState();
    const rolesMap = useRolesMap(roles);
    const { ssoConfigurations: ssoConfigurationsData, loaders: { LOAD_SSO_CONFIGURATIONS: loading } } = useSSOState();
    const { updateSSOConfiguration } = useSSOActions();
    const { policy, loading: loadingPolicy } = usePublicPolicySettings();
    const [deleteConfigDialog, handleCloseDeleteSSOConfig, handleOpenDeleteSSOConfig, ssoConfigToDelete] = useDialogState();
    const [editSSOConfigDialogOpen, handleCloseEditSSOConfig, handleOpenEditSSOConfig, ssoConfigToEdit] = useDialogState();
    const hasWritePermission = usePermission('fe.secure.write.samlConfiguration');
    const hasDeletePermission = usePermission('fe.secure.delete.samlConfiguration');
    const handleChangeStatus = react.exports.useCallback((ssoConfig) => {
        updateSSOConfiguration({ ssoConfigId: ssoConfig.id, enabled: !ssoConfig.enabled });
    }, [updateSSOConfiguration]);
    const columns = react.exports.useMemo(() => SsoTableColumns({
        container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl,
        forcePermissions: !loadingPolicy && (policy === null || policy === void 0 ? void 0 : policy.forcePermissions),
        onChangeStatus: handleChangeStatus,
        rolesMap,
        hasWritePermission,
        showConfigureSSOMessage,
        t,
    }), [t, handleChangeStatus, showConfigureSSOMessage, rolesMap, injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, policy, loadingPolicy, hasWritePermission]);
    const getRowActions = useSSOTableRowActions({
        container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl,
        handleOpenEditConfig: handleOpenEditSSOConfig,
        handleOpenDeleteConfig: handleOpenDeleteSSOConfig,
        hasWritePermission,
        hasDeletePermission,
    });
    const tablePlaceholderProps = react.exports.useMemo(() => {
        if (loading) {
            return null;
        }
        if (!ssoConfigurationsData.length) {
            return {
                show: true,
                icon: React.createElement(SSOIcon, null),
                title: t('noSSOConfigsYet'),
                description: t('noSSOConfigsYetDescription'),
            };
        }
        return null;
    }, [loading, ssoConfigurationsData, t]);
    return (React.createElement(React.Fragment, null,
        React.createElement(Table, { loading: !!loading, container: (_a = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl) !== null && _a !== void 0 ? _a : document.body, columns: columns, data: ssoConfigurationsData, getRowActions: getRowActions }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))),
        React.createElement(DeleteSSOConfigurationDialog, { open: deleteConfigDialog, onClose: handleCloseDeleteSSOConfig, ssoConfig: ssoConfigToDelete }),
        React.createElement(SsoConfigurationDialogForm, { open: editSSOConfigDialogOpen, handleClose: handleCloseEditSSOConfig, handleOpen: handleOpenEditSSOConfig, initialSSOConfigurationId: ssoConfigToEdit === null || ssoConfigToEdit === void 0 ? void 0 : ssoConfigToEdit.id })));
};

const SsoPage = () => {
    const { loadRoles } = useAuthTeamActions();
    const [isConfigureSSOMessage, setIsConfigureSSOMessage] = react.exports.useState(false);
    const [addSSOConfigDialogOpen, handleCloseAddSSOConfig, handleOpenAddSSOConfig] = useDialogState();
    const t = useT('sso');
    const showConfigureSSOMessage = react.exports.useCallback(() => {
        setIsConfigureSSOMessage(true);
    }, [setIsConfigureSSOMessage]);
    const hideConfigureSSOMessage = react.exports.useCallback(() => {
        setIsConfigureSSOMessage(false);
    }, [setIsConfigureSSOMessage]);
    react.exports.useEffect(() => {
        loadRoles();
    }, [loadRoles]);
    return React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(Collapse$1, { in: isConfigureSSOMessage },
            React.createElement(Box, { mb: 8 },
                React.createElement(Alert$1$1, { onClose: hideConfigureSSOMessage, severity: 'warning' }, t('enableAlert')))),
        React.createElement(SsoHeader, { handleOpenNewConfiguration: handleOpenAddSSOConfig }),
        React.createElement(Box, { mt: 9, flex: 1, display: 'flex', flexDirection: 'column' },
            React.createElement(SsoTable, { showConfigureSSOMessage: showConfigureSSOMessage })),
        React.createElement(SsoConfigurationDialogForm, { open: addSSOConfigDialogOpen, handleOpen: handleOpenAddSSOConfig, handleClose: handleCloseAddSSOConfig }));
};
var SsoPage$1 = SsoPage;

var MultipleSsoPage = wrapPage(SsoPage$1, 'sso');

class UserMapCache {
    constructor() {
        this.mapIds = {};
        this.mapEmails = {};
    }
    static getInstance() {
        if (!UserMapCache.instance) {
            UserMapCache.instance = new UserMapCache();
        }
        return UserMapCache.instance;
    }
    static getUserById(userId, users) {
        const map = this.getInstance().mapIds;
        if (!map[userId]) {
            map[userId] = {
                data: null,
                loading: true,
            };
            map[userId].promise = new Promise((resolve) => {
                const userFromTeams = users === null || users === void 0 ? void 0 : users.find(u => u.id === userId);
                if (userFromTeams) {
                    map[userId].data = Object.assign(Object.assign({}, userFromTeams), { profilePictureUrl: userFromTeams.profileImageUrl });
                    map[userId].loading = false;
                    map[userId].promise = undefined;
                    this.getInstance().mapEmails[userFromTeams.email] = map[userId];
                    resolve(userFromTeams);
                    return;
                }
                api.auth.getUserById({ userId })
                    .then((user) => {
                    map[userId].data = user;
                    map[userId].loading = false;
                    map[userId].promise = undefined;
                    this.getInstance().mapEmails[user.email] = map[userId];
                    resolve(user);
                })
                    .catch((e) => {
                    map[userId].data = null;
                    map[userId].loading = false;
                    map[userId].promise = undefined;
                    resolve(null);
                });
            });
        }
        const { loading, promise, data } = map[userId];
        if (loading && promise != null) {
            return promise;
        }
        return new Promise((resolve) => resolve(data));
    }
    static getUserByEmail(email, users) {
        const map = this.getInstance().mapEmails;
        if (!map[email]) {
            map[email] = {
                data: null,
                loading: true,
            };
            map[email].promise = new Promise((resolve) => {
                const userFromTeams = users === null || users === void 0 ? void 0 : users.find(u => u.email === email);
                if (userFromTeams) {
                    map[email].data = Object.assign(Object.assign({}, userFromTeams), { profilePictureUrl: userFromTeams.profileImageUrl });
                    map[email].loading = false;
                    map[email].promise = undefined;
                    this.getInstance().mapIds[userFromTeams.id] = map[email];
                    resolve(userFromTeams);
                    return;
                }
                api.teams.loadUsers({ filter: [{ id: 'searchFilter', value: email }], pageSize: 1, pageOffset: 0 })
                    .then((users) => {
                    if (users.items.length > 0) {
                        const user = users.items[0];
                        map[email].data = Object.assign(Object.assign({}, user), { profilePictureUrl: user.profileImageUrl });
                        map[email].loading = false;
                        map[email].promise = undefined;
                        this.getInstance().mapIds[user.id] = map[email];
                        resolve(user);
                    }
                    else {
                        map[email].data = null;
                        map[email].loading = false;
                        map[email].promise = undefined;
                        resolve(null);
                    }
                })
                    .catch((e) => {
                    map[email].data = null;
                    map[email].loading = false;
                    map[email].promise = undefined;
                    resolve(null);
                });
            });
        }
        const { loading, promise, data } = map[email];
        if (loading && promise != null) {
            return promise;
        }
        return new Promise((resolve) => resolve(data));
    }
}

const TableUserCell = react.exports.memo(({ value: { userId, email, name } }) => {
    const [currentUser, setCurrentUser] = react.exports.useState(null);
    const users = useAuthTeamState(state => state.users);
    react.exports.useEffect(() => {
        if (userId) {
            UserMapCache.getUserById(userId, users).then(setCurrentUser);
        }
        else if (email) {
            UserMapCache.getUserByEmail(email, users).then(setCurrentUser);
        }
    }, [userId, email, users, setCurrentUser]);
    return React.createElement(TableUserAvatarCell, { value: currentUser !== null && currentUser !== void 0 ? currentUser : { name: name !== null && name !== void 0 ? name : 'Unknown', email: email !== null && email !== void 0 ? email : '' } });
}, shallowEqual$1('value.userId', 'value.email'));

const ApiTokensTableColumns = ({ t, container, rolesMap, isPermissionsAndRolesDisabled }) => [
    {
        Header: t('clientIdHeader'),
        accessor: ({ clientId, description }) => ({ title: description, description: clientId, copyValue: clientId }),
        minWidth: 370,
        maxWidth: 370,
        Cell: TableCopyCell,
    },
    ...isPermissionsAndRolesDisabled ? [] : [{
            Header: t('rolesHeader'),
            accessor: ({ roleIds }) => { var _a; return ({ items: (_a = roleIds === null || roleIds === void 0 ? void 0 : roleIds.map(v => ({ text: rolesMap[v] }))) !== null && _a !== void 0 ? _a : [], max: 1, container }); },
            minWidth: 200,
            Cell: TableChipsCell,
        }],
    {
        Header: t('createdOnHeader'),
        accessor: ({ createdAt }) => ({ date: createdAt }),
        width: 140,
        maxWidth: 140,
        Cell: TableDateCell,
    },
    {
        Header: t('createdByHeader'),
        accessor: ({ createdByUserId }) => ({ userId: createdByUserId }),
        minWidth: 260,
        Cell: TableUserCell,
    },
];
const ApiTokenTableRowActions = ({ t, container, handleOpenDeleteToken, }) => (row) => {
    const items = [
        {
            icon: React.createElement(DeleteIcon, { "data-test-id": "deleteApiBtn" }),
            onClick: () => handleOpenDeleteToken(row.clientId),
            text: t('deleteApiTokenAction'),
            negative: true,
        },
    ];
    return { items, container };
};

const DeleteApiTokenDialog$1 = ({ onClose, open, token = '' }) => {
    const t = useT('apiTokens_DeleteToken');
    const [submitted, setSubmitted] = react.exports.useState(false);
    const { loaders: { DELETE_API_TOKEN: loading }, errors: { DELETE_API_TOKEN: error }, } = useApiTokensState();
    const { deleteTenantApiToken, setApiTokensError, setApiTokensLoader } = useApiTokensActions();
    react.exports.useEffect(() => {
        setApiTokensError({ key: ApiStateKeys.DELETE_API_TOKEN, value: false });
        setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: false });
    }, [setApiTokensError, setApiTokensLoader]);
    react.exports.useEffect(() => {
        if (submitted && !error && !loading) {
            onClose();
        }
    }, [submitted, error, loading, onClose]);
    const handleDeleteApiToken = react.exports.useCallback(() => {
        deleteTenantApiToken(token);
        setSubmitted(true);
    }, [token, setSubmitted, deleteTenantApiToken]);
    return (React.createElement(DeleteDialog, { dataTestId: 'deleteApiBtn', title: t('title'), cancelButtonText: t('cancel'), deleteButtonText: t('delete'), description: React.createElement(React.Fragment, null,
            t('areYouSureDeleteApiToken1'),
            " ",
            React.createElement("strong", null,
                "(Token: ",
                token,
                ")"),
            "? ",
            t('areYouSureDeleteApiToken2')), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleDeleteApiToken }));
};

const ApiTokensTable = () => {
    const t = useT('apiTokens');
    const { injector } = useShadowDom();
    const container = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl;
    const { roles } = useAuthTeamState();
    const { apiTokensDataTenant: tokensData, searchValue, loaders: { LOAD_API_TOKENS: loading } } = useApiTokensState();
    const rolesMap = useRolesMap(roles);
    const { policy, loading: loadingPolicy } = usePublicPolicySettings();
    const isPermissionsAndRolesDisabled = react.exports.useMemo(() => !loadingPolicy && !(policy === null || policy === void 0 ? void 0 : policy.forcePermissions), [loadingPolicy, policy]);
    const [deleteTokenDialog, handleCloseDeleteToken, handleOpenDeleteToken, deleteApiTokenData] = useDialogState();
    const rows = react.exports.useMemo(() => {
        if (!!searchValue) {
            return tokensData.filter((token) => token.description.indexOf(searchValue) !== -1 || token.clientId.indexOf(searchValue) !== -1);
        }
        return tokensData;
    }, [tokensData, searchValue]);
    const columns = react.exports.useMemo(() => ApiTokensTableColumns({
        t,
        rolesMap,
        container,
        isPermissionsAndRolesDisabled,
    }), [container, rolesMap, t, isPermissionsAndRolesDisabled]);
    const getRowActions = react.exports.useMemo(() => ApiTokenTableRowActions({
        t,
        container,
        handleOpenDeleteToken,
    }), [t, container, handleOpenDeleteToken]);
    const tablePlaceholderProps = react.exports.useMemo(() => {
        if (loading) {
            return null;
        }
        else if (!searchValue && rows.length === 0) {
            return {
                show: true,
                icon: React.createElement(APITokenIcon, null),
                title: t('noApiTokensYet'),
                description: t('noApiTokensYetDescription'),
            };
        }
        else if (searchValue && rows.length === 0) {
            return {
                show: true,
                icon: React.createElement(SearchBigIcon, null),
                title: t('noResultFound'),
                description: t('noResultFoundDescription'),
            };
        }
        return null;
    }, [t, loading, searchValue, rows.length]);
    return React.createElement(React.Fragment, null,
        React.createElement(Table, { "data-test-id": "table", columns: columns, data: rows, getRowActions: getRowActions, loading: !!loading }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))),
        React.createElement(DeleteApiTokenDialog$1, { "data-test-id": "deleteTokenBox", open: deleteTokenDialog, onClose: handleCloseDeleteToken, token: deleteApiTokenData }));
};

const ApiTokensHeader = ({ handleOpenAddToken }) => {
    const t = useT('apiTokens');
    const { setApiTokensState } = useApiTokensActions();
    const handleSearchChanged = react.exports.useCallback((e) => setApiTokensState({ searchValue: e.target.value }), [setApiTokensState]);
    const canAddTenantToken = usePermission('fe.secure.write.tenantApiTokens');
    return React.createElement(Grid, { container: true, spacing: 4 },
        React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
            React.createElement(Box, null,
                React.createElement(Input$1$1, { "data-test-id": "serachBox", endAdornment: React.createElement(SearchIcon, null), onChange: handleSearchChanged, placeholder: t('searchInputPlaceholder') }))),
        React.createElement(Grid, { item: true, xs: true }),
        canAddTenantToken && React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": "generateTokenBtn", onClick: handleOpenAddToken }, t('generateTokenButton'))));
};

const AddTokenSuccessForm$1 = react.exports.forwardRef((props, ref) => {
    const t = useT('apiTokens_AddToken');
    const { successDialog: { clientId, secret } } = useApiTokensState();
    return React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, { ref: ref },
            React.createElement(Alert$1, { sx: { marginBottom: 4 }, color: "info" }, t('copyAndSaveId')),
            React.createElement(InputCopyField, { label: t('clientId'), value: clientId !== null && clientId !== void 0 ? clientId : '' }),
            React.createElement(InputCopyField, { label: t('secretKey'), value: secret !== null && secret !== void 0 ? secret : '' })),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(Button$1, { "data-test-id": "doneBtn", color: 'secondary', onClick: props.onClose, type: 'reset' }, t('done'))));
});
const DescriptionField$1 = react.exports.memo(() => {
    const t = useT('apiTokens_AddToken');
    const [fieldProps, { error, touched }] = useField('description');
    return React.createElement(Input$1$1, Object.assign({ label: t('descriptionInputLabel'), "data-test-id": "descriptionBox" }, fieldProps, { autoFocus: true, error: !!error && touched, errorMessage: error, autoComplete: 'description' }));
});
const AddTokenForm$1 = react.exports.forwardRef((props, ref) => {
    const t = useT('apiTokens_AddToken');
    const { addTenantApiToken } = useApiTokensActions();
    const { policy } = usePublicPolicySettings();
    const initialValues = react.exports.useMemo(() => ({
        description: '',
        roleIds: [],
    }), []);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        description: validateNotEmpty(t('descriptionIsRequired')),
        roleIds: create().min((policy === null || policy === void 0 ? void 0 : policy.forcePermissions) ? 1 : 0, t('rolesIsRequired')),
    }), [t, policy === null || policy === void 0 ? void 0 : policy.forcePermissions]);
    const formikProps = {
        onSubmit: ({ description, roleIds }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            addTenantApiToken({ description, roleIds, callback });
        }),
        initialValues,
        validationSchema,
    };
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, { ref: ref },
                React.createElement(DescriptionField$1, null),
                (policy === null || policy === void 0 ? void 0 : policy.forcePermissions) && React.createElement(RolesField$4, { label: t('rolesInputLabel'), placeholder: t('rolesInputPlaceholder') }),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancelBtn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "createBtn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('create'))));
    });
});
const AddTokenSteper$1 = props => {
    const { successDialog: { open } } = useApiTokensState();
    return React.createElement(React.Fragment, null,
        React.createElement(Slide$1, { in: !open, appear: false, exit: false, unmountOnExit: true, direction: !open ? 'left' : 'right' },
            React.createElement(AddTokenForm$1, Object.assign({}, props))),
        React.createElement(Slide$1, { in: open, mountOnEnter: true, unmountOnExit: true, direction: open ? 'left' : 'right' },
            React.createElement(AddTokenSuccessForm$1, Object.assign({}, props))));
};
const AddTokenDialog$1 = props => {
    const { injector } = useShadowDom();
    const t = useT('apiTokens_AddToken');
    const { successDialog: { open } } = useApiTokensState();
    const title = open ? t('successTitle') : t('title');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: title, size: 'sm' }),
        React.createElement(AddTokenSteper$1, Object.assign({}, props)));
};

const ApiTokensPage$1 = () => {
    const { loadRoles } = useAuthTeamActions();
    const { loadApiTokens, setApiTokensState } = useApiTokensActions();
    const { apiTokensDataTenant } = useApiTokensState();
    const [addTokenDialog, handleCloseAddToken, handleOpenAddToken] = useDialogState();
    react.exports.useEffect(() => {
        const queryObject = { pageOffset: 0, filter: [], silentLoading: apiTokensDataTenant.length > 0 };
        loadRoles();
        loadApiTokens(queryObject);
        return () => loadApiTokens(queryObject);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadApiTokens, loadRoles]);
    const onDialogCloseHandler = react.exports.useCallback(() => {
        handleCloseAddToken();
        setTimeout(() => setApiTokensState({ successDialog: { clientId: '', secret: '', open: false } }), 400);
    }, [handleCloseAddToken, setApiTokensState]);
    return (React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(ApiTokensHeader, { handleOpenAddToken: handleOpenAddToken }),
        React.createElement(Box, { mt: 6, flex: 1, display: 'flex', flexDirection: 'column' },
            React.createElement(ApiTokensTable, null)),
        React.createElement(AddTokenDialog$1, { open: addTokenDialog, onClose: onDialogCloseHandler })));
};
var ApiTokensPage$2 = ApiTokensPage$1;

var ApiTokensPage = wrapPage(ApiTokensPage$2, 'apiTokens');

const AuditLogsHeader = () => {
    const t = useT('auditLogs');
    const prevSearch = react.exports.useRef({ search: null });
    const [search, setSearch] = react.exports.useState('');
    const { loadAuditLogs, exportAuditsCsv } = useAuditsActions();
    const { filter: filters, sort } = useAuditLogsState();
    const searchValue = useDebounce(search, 500);
    const filterOnly = react.exports.useMemo(() => { var _a; return (_a = filters === null || filters === void 0 ? void 0 : filters.filter((f) => f.id !== 'filter')) !== null && _a !== void 0 ? _a : []; }, [filters]);
    const handlerOnSetFilter = react.exports.useCallback((values) => {
        loadAuditLogs({
            pageOffset: 0,
            sort,
            filter: values,
        });
    }, [loadAuditLogs, sort]);
    const AuditsDownloadIcon = styled(default_1)(({ theme }) => ({
        color: theme.palette.grey[500],
    }));
    const handlerSearch = react.exports.useCallback((e) => {
        setSearch(e.target.value);
    }, [setSearch]);
    react.exports.useEffect(() => {
        prevSearch.current.search !== null &&
            prevSearch.current.search !== searchValue &&
            handlerOnSetFilter([...filterOnly, { id: 'filter', value: searchValue.toLowerCase() }]);
        prevSearch.current.search = searchValue;
    }, [searchValue, handlerOnSetFilter, filterOnly, prevSearch]);
    return React.createElement(Grid, { container: true, spacing: 4, justifyContent: "space-between" },
        React.createElement(Grid, { item: true, xs: 8, sm: 6, md: 4 },
            React.createElement(Box, null,
                React.createElement(Input$1$1, { "data-test-id": "Search", endAdornment: React.createElement(SearchIcon, null), onChange: handlerSearch, placeholder: t('searchInputPlaceholder') }))),
        React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": "Download", size: "small", color: "inherit", onClick: () => exportAuditsCsv() },
                React.createElement(Box, { component: AuditsDownloadIcon, sx: { height: '0.75rem', width: '0.75rem', marginRight: '0.75rem', marginTop: '0.125rem' } }),
                t('downloadCsvPrimaryButton'))));
};

const FilterBody = styled(Box)(({ theme }) => ({
    margin: '8px -16px 16px -16px',
    padding: '15px 16px',
    borderBottom: `1px solid ${theme.palette.grey[300]}`,
    borderTop: `1px solid ${theme.palette.grey[300]}`,
}));
const Selector = styled(Select$1$1)({
    '& .MuiOutlinedInput-root': {
        minWidth: '100%',
    },
});
const AlphaNumericFilter = ({ value, onChange }) => {
    const [inputState, setInputState] = react.exports.useState(`${value !== null && value !== void 0 ? value : ''}`);
    return (React.createElement(Input$1$1, { autoFocus: true, fullWidth: true, onChange: (e) => {
            setInputState(e.target.value);
            onChange(e.target.value);
        }, value: inputState }));
};
const SeverityFilter = ({ value, onChange }) => {
    const [selectState, setSelectState] = react.exports.useState(severityOptions[0].value);
    const { injector } = useShadowDom();
    react.exports.useEffect(() => {
        onChange(selectState);
        if (value) {
            setSelectState(severityOptions.filter((o) => o.value === value)[0].value);
        }
        // eslint-disable-next-line
    }, []);
    const handleSelect = react.exports.useCallback((value) => {
        setSelectState(value);
        onChange(value);
    }, [setSelectState, onChange]);
    return (React.createElement(Selector, { container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, fullWidth: true, size: "small", placeholder: "select", value: selectState, onChange: (value) => handleSelect(value), options: severityOptions }));
};
const TimeStampFilter = ({ value, onChange }) => {
    const [selectState, setSelectState] = react.exports.useState(value ? timeOptions.filter((f) => f.value === getTimeDiff(value))[0].value : timeOptions[0].value);
    const { injector } = useShadowDom();
    const handleSelect = react.exports.useCallback((value) => {
        setSelectState(value);
        onChange(value);
    }, [onChange, setSelectState]);
    return (React.createElement(Selector, { container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, fullWidth: true, size: "small", placeholder: "select", value: selectState, onChange: handleSelect, options: timeOptions }));
};
const Filter = ({ closePopup, value, setFilterValue, type, name }) => {
    const t = useT('auditLogs');
    const [state, setState] = react.exports.useState('');
    const filter = react.exports.useMemo(() => {
        switch (type) {
            case 'Timestamp':
                return React.createElement(TimeStampFilter, { value: value === null || value === void 0 ? void 0 : value.$gt, onChange: (value) => setState(value) });
            case 'Severity':
                return React.createElement(SeverityFilter, { value: value, onChange: (value) => setState(value) });
            default:
                return React.createElement(AlphaNumericFilter, { value: value, onChange: (value) => setState(value) });
        }
    }, [type, value, setState]);
    const handleFilter = react.exports.useCallback((e) => {
        e.preventDefault();
        getFilterType(type) === 'input'
            ? !!state.trim() && setFilterValue(state)
            : setFilterValue(type === 'Timestamp' ? getFilterTime(state) : state);
    }, [type, state, setFilterValue]);
    const FilterFooter = react.exports.useCallback(() => {
        return (React.createElement(Grid, { container: true, spacing: 2, paddingBottom: 1 },
            React.createElement(Grid, { item: true, xs: 6 },
                React.createElement(Button$1, { "data-test-id": "cancelBtn", type: "button", color: "inherit", size: "small", fullWidth: true, onClick: () => {
                        !!value && setFilterValue(null);
                        closePopup === null || closePopup === void 0 ? void 0 : closePopup();
                    } }, value ? t('clear') : t('cancel'))),
            React.createElement(Grid, { item: true, xs: 6 },
                React.createElement(Button$1, { "data-test-id": "submit-btn", size: "small", type: "submit", fullWidth: true, color: "primary" }, t('filter')))));
    }, [setFilterValue, closePopup, t, value]);
    return (React.createElement(Box, null,
        React.createElement("form", { onSubmit: (e) => {
                handleFilter(e);
                closePopup === null || closePopup === void 0 ? void 0 : closePopup();
            } },
            React.createElement(Typography$1, { variant: "tableFilterTitle" },
                t('filterBy'),
                " ",
                getFilterName(name)),
            React.createElement(FilterBody, null, filter),
            React.createElement(FilterFooter, null))));
};

const AuditLogsTableColumns = ({ columnsMetadata, container }) => {
    return columnsMetadata.filter(c => c.showInTable).map(c => {
        switch (c.type) {
            case 'Timestamp':
                return {
                    id: c.name,
                    Header: c.displayName,
                    accessor: (row) => ({ date: row[c.name] }),
                    Cell: TableDateCell,
                    Filter: c.filterable
                        ? ({ value, setFilterValue, closePopup }) => (React.createElement(Filter, { name: c.name, value: value, setFilterValue: setFilterValue, closePopup: closePopup, type: c.type }))
                        : undefined,
                    width: 160,
                    maxWidth: 160,
                    sortable: c.sortable,
                };
            case 'Email':
                return {
                    id: c.name,
                    Header: c.displayName,
                    accessor: (row) => ({ email: row[c.name], name: row['user'] }),
                    Cell: TableUserCell,
                    Filter: c.filterable
                        ? ({ value, setFilterValue, closePopup }) => (React.createElement(Filter, { name: c.name, value: value, setFilterValue: setFilterValue, closePopup: closePopup, type: c.type }))
                        : undefined,
                    width: 280,
                    maxWidth: 280,
                    sortable: c.sortable,
                };
            case 'IpAddress':
                return {
                    id: c.name,
                    Header: c.displayName,
                    accessor: (row) => ({ ip: row[c.name], container, getIpMetadata }),
                    Cell: TableIpCell,
                    Filter: c.filterable
                        ? ({ value, setFilterValue, closePopup }) => (React.createElement(Filter, { name: c.name, value: value, setFilterValue: setFilterValue, closePopup: closePopup, type: c.type }))
                        : undefined,
                    width: 280,
                    maxWidth: 280,
                    sortable: c.sortable,
                };
            case 'Json':
                return {
                    id: c.name,
                    Header: c.displayName,
                    accessor: (row) => ({ json: Array.isArray(row[c.name]) ? row[c.name] : [row[c.name]], container }),
                    Cell: TableJsonCell,
                    width: 150,
                    maxWidth: 150,
                    sortable: c.sortable,
                };
            case 'Severity':
                return {
                    id: c.name,
                    Header: c.displayName,
                    accessor: (row) => ({ label: row[c.name], severity: getSeverityByName(row[c.name]) }),
                    Cell: TableSeverityCell,
                    Filter: c.filterable
                        ? ({ value, setFilterValue, closePopup }) => (React.createElement(Filter, { name: c.name, value: value, setFilterValue: setFilterValue, closePopup: closePopup, type: c.type }))
                        : undefined,
                    width: 150,
                    maxWidth: 150,
                    sortable: c.sortable,
                };
            default:
                return {
                    id: c.name,
                    Header: c.displayName,
                    accessor: (row) => ({ description: row[c.name], container }),
                    Cell: TableTextCell,
                    Filter: c.filterable
                        ? ({ value, setFilterValue, closePopup }) => (React.createElement(Filter, { name: c.name, value: value, setFilterValue: setFilterValue, closePopup: closePopup, type: c.type }))
                        : undefined,
                    minWidth: 220,
                    sortable: c.sortable,
                };
        }
    }).filter(c => !!c);
};

const AuditLogsTable = () => {
    var _a, _b;
    const t = useT('auditLogs');
    const { injector } = useShadowDom();
    const { searching } = useTableSearch();
    const { loadAuditLogs } = useAuditsActions();
    const { columns: columnsMetadata } = useAuditsMetadataState();
    const _c = useAuditLogsState(), { loading, totalPages, pageOffset, pageSize, sort, filter: filters } = _c, auditLogsState = __rest(_c, ["loading", "totalPages", "pageOffset", "pageSize", "sort", "filter"]);
    const logs = (_a = auditLogsState === null || auditLogsState === void 0 ? void 0 : auditLogsState.logs) !== null && _a !== void 0 ? _a : [];
    const columns = react.exports.useMemo(() => {
        var _a;
        return AuditLogsTableColumns({
            columnsMetadata: columnsMetadata !== null && columnsMetadata !== void 0 ? columnsMetadata : [],
            container: (_a = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl) !== null && _a !== void 0 ? _a : document.body,
        });
    }, [t, columnsMetadata, injector === null || injector === void 0 ? void 0 : injector.adminPortalEl]);
    const onPageChange = react.exports.useCallback((_, page) => {
        loadAuditLogs({ pageOffset: pageSize * (page - 1) });
    }, [loadAuditLogs, pageSize]);
    const handlerSortChange = react.exports.useCallback((sortBy) => {
        loadAuditLogs({
            pageOffset: 0,
            sort: sortBy,
            filter: filters,
        });
    }, [loadAuditLogs, filters]);
    const handlerFilterChange = react.exports.useCallback((_filters) => {
        loadAuditLogs({
            pageOffset: 0,
            sort,
            filter: _filters,
        });
    }, [loadAuditLogs, sort]);
    const tablePlaceholderProps = react.exports.useMemo(() => {
        if (loading) {
            return null;
        }
        else if (logs.length === 0) {
            return {
                show: true,
                icon: React.createElement(SearchBigIcon, null),
                title: t('noResultFound'),
                description: t('noResultFoundDescription'),
            };
        }
        return null;
    }, [t, loading, logs.length]);
    const moreInfoColumns = columnsMetadata === null || columnsMetadata === void 0 ? void 0 : columnsMetadata.filter(c => str2bool(c.showInMoreInfo));
    const TableExpandRow = react.exports.useCallback((row) => {
        const rowToDisplay = {};
        moreInfoColumns === null || moreInfoColumns === void 0 ? void 0 : moreInfoColumns.filter(c => !!row.original[c.name]).forEach(c => {
            if (c.type === 'Timestamp') {
                const date = new Date(row.original[c.name]);
                if (!isValid$2(date)) {
                    return rowToDisplay[c.displayName] = '-';
                }
                return rowToDisplay[c.displayName] = format$1(date, 'dd/MM/yyyy hh:mm:ss bb');
            }
            return rowToDisplay[c.displayName] = row.original[c.name];
        });
        return React.createElement(TableExpandableRow, { row: rowToDisplay });
    }, [moreInfoColumns]);
    return React.createElement(React.Fragment, null,
        React.createElement(Table, { container: (_b = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl) !== null && _b !== void 0 ? _b : document.body, columns: columns, data: logs, loading: loading, searching: searching, loadingText: searching ? t('searchingPlaceholder') : undefined, totalPages: totalPages, pageOffset: Math.floor(pageOffset / pageSize), sortBy: sort, filters: filters, onSortChange: handlerSortChange, onFilterChange: handlerFilterChange, renderExpandedComponent: !(moreInfoColumns === null || moreInfoColumns === void 0 ? void 0 : moreInfoColumns.length) ? undefined : TableExpandRow, onPageChange: onPageChange }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))));
};

const SubHeaderChip = styled(Chip)({
    marginRight: '0.75rem',
});
const ChipsContainer = styled(Box)({
    marginTop: '1rem',
});
const AuditLogsSubHeader = () => {
    const { sort, filter } = useAuditLogsState();
    const { loadAuditLogs } = useAuditsActions();
    const handleFilterDelete = react.exports.useCallback((id) => {
        loadAuditLogs({
            pageOffset: 0,
            sort,
            filter: filter.filter(f => f.id !== id),
        });
    }, [loadAuditLogs, sort, filter]);
    const chipLabel = react.exports.useCallback((id, value) => {
        if (typeof value === 'object') {
            return React.createElement(Box, { display: 'flex', alignItems: 'center' },
                getFilterName(id),
                ": ",
                React.createElement(Typography$1, { variant: 'tableFilterChipInfo', marginLeft: '5px' }, format$1(new Date(Date.parse(value.$gt)), 'yyyy/MM/dd h:mm a')));
        }
        return React.createElement(Box, { display: 'flex', alignItems: 'center' },
            getFilterName(id),
            ": ",
            React.createElement(Typography$1, { variant: 'tableFilterChipInfo', marginLeft: '5px' }, value));
    }, []);
    return (React.createElement(ChipsContainer, null, filter.filter(f => f.id !== 'filter').map(f => React.createElement(SubHeaderChip, { label: chipLabel(f.id, f.value), key: f.value, onDelete: () => handleFilterDelete(f.id), deleteIcon: React.createElement(CrossBtnIcon, null) }))));
};

const AuditLogsPage$1 = () => {
    var _a;
    const [searching, setSearching] = react.exports.useState(false);
    const [searchQuery, onSearch] = react.exports.useState('');
    const auditLogsState = useAuditLogsState();
    const logs = (_a = auditLogsState === null || auditLogsState === void 0 ? void 0 : auditLogsState.logs) !== null && _a !== void 0 ? _a : [];
    const { loadAuditLogs } = useAuditLogsActions();
    react.exports.useEffect(() => {
        const queryObject = { pageOffset: 0, sort: [{ id: 'createdAt', desc: true }], silentLoading: logs.length > 0 };
        loadAuditLogs(queryObject);
        return () => loadAuditLogs(queryObject);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadAuditLogs]);
    return React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(TableSearchContext.Provider, { value: { searching, searchQuery, onSearch, setSearching } },
            React.createElement(AuditLogsHeader, null),
            React.createElement(AuditLogsSubHeader, null),
            React.createElement(Box, { mt: 1, flex: 1, display: 'flex', flexDirection: 'column' },
                React.createElement(AuditLogsTable, null))));
};
var AuditLogsPage$2 = AuditLogsPage$1;

var AuditLogsPage = wrapPage(AuditLogsPage$2, 'auditLogs');

//TODO change data test id from doneBtn to done-btn
//TODO change data test id from clientId to copy-client-id-box moved it to the component
//TODO change data test id from secretKey to copy-secret-key-box moved it to the component
const AddTokenSuccessForm = react.exports.forwardRef((props, ref) => {
    const t = useT('personalTokens_AddToken');
    const { successDialog: { clientId, secret } } = useApiTokensState();
    return React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, { ref: ref },
            React.createElement(Alert$1, { sx: { marginBottom: 4 }, color: "info" }, t('copyAndSaveId')),
            React.createElement(InputCopyField, { testId: "copy-client-id", label: t('clientId'), value: clientId !== null && clientId !== void 0 ? clientId : '' }),
            React.createElement(InputCopyField, { testId: "copy-secret-key", label: t('secretKey'), value: secret !== null && secret !== void 0 ? secret : '' })),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(Button$1, { "data-test-id": "done-btn", color: 'secondary', onClick: props.onClose, type: 'reset' }, t('done'))));
});
//TODO change data test id from descriptionBox to description-box
const DescriptionField = react.exports.memo(() => {
    const t = useT('personalTokens_AddToken');
    const [fieldProps, { error, touched }] = useField('description');
    return React.createElement(Input$1$1, Object.assign({ label: t('descriptionInputLabel'), "data-test-id": "description-box" }, fieldProps, { autoFocus: true, error: !!error && touched, errorMessage: error, autoComplete: 'description' }));
});
const AddTokenForm = react.exports.forwardRef((props, ref) => {
    const t = useT('personalTokens_AddToken');
    const { addUserApiToken } = useApiTokensActions();
    const initialValues = react.exports.useMemo(() => ({
        description: '',
    }), []);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        description: validateNotEmpty(t('descriptionIsRequired')),
    }), [t]);
    const formikProps = {
        onSubmit: ({ description }) => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            addUserApiToken({ description, callback });
        }),
        initialValues,
        validationSchema,
    };
    //TODO change data test id from cancelBtn to cancel-btn
    //TODO change data test id from createBtn to create-btn
    return React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, { ref: ref },
                React.createElement(DescriptionField, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancel-btn", color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "create-btn", disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, t('create'))));
    });
});
const AddTokenSteper = props => {
    const { successDialog: { open } } = useApiTokensState();
    return React.createElement(React.Fragment, null,
        React.createElement(Slide$1, { in: !open, appear: false, exit: false, unmountOnExit: true, direction: !open ? 'left' : 'right' },
            React.createElement(AddTokenForm, Object.assign({}, props))),
        React.createElement(Slide$1, { in: open, mountOnEnter: true, unmountOnExit: true, direction: open ? 'left' : 'right' },
            React.createElement(AddTokenSuccessForm, Object.assign({}, props))));
};
const AddTokenDialog = props => {
    const { injector } = useShadowDom();
    const t = useT('personalTokens_AddToken');
    const { successDialog: { open } } = useApiTokensState();
    const title = open ? t('successTitle') : t('title');
    return React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: title, size: 'sm' }),
        React.createElement(AddTokenSteper, Object.assign({}, props)));
};

const PersonalTokensHeader = ({ handleOpenAddToken }) => {
    const t = useT('personalTokens');
    const { setApiTokensState } = useApiTokensActions();
    const handleSearchChanged = react.exports.useCallback((e) => setApiTokensState({ searchValue: e.target.value }), [setApiTokensState]);
    //TODO change data test id from searchBox to search-box
    //TODO change data test id from generateToken to generate-token
    return React.createElement(Grid, { container: true, spacing: 4 },
        React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
            React.createElement(Box, null,
                React.createElement(Input$1$1, { "data-test-id": "search-box", endAdornment: React.createElement(SearchIcon, null), onChange: handleSearchChanged, placeholder: t('searchInputPlaceholder') }))),
        React.createElement(Grid, { item: true, xs: true }),
        React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": "generate-token", onClick: handleOpenAddToken }, t('generateTokenButton'))));
};

const PersonalTokensTableColumns = ({ t }) => [
    {
        Header: t('clientIdHeader'),
        accessor: ({ clientId, description }) => ({ title: description, description: clientId, copyValue: clientId, testId: 'client-id' }),
        minWidth: 400,
        Cell: TableCopyCell,
    },
    {
        Header: t('createdOnHeader'),
        accessor: ({ createdAt }) => ({ date: createdAt }),
        width: 250,
        maxWidth: 250,
        Cell: TableDateCell,
    },
];
const PersonalTokenTableRowActions = ({ t, container, handleOpenDeleteToken, }) => (row) => {
    const items = [
        {
            icon: React.createElement(DeleteIcon, { "data-test-id": "delete-token" }),
            onClick: () => handleOpenDeleteToken(row.clientId),
            text: t('deleteApiTokenAction'),
            negative: true,
        },
    ];
    return { items, container };
};

const DeleteApiTokenDialog = ({ onClose, open, token = '' }) => {
    const t = useT('personalTokens_DeleteToken');
    const [submitted, setSubmitted] = react.exports.useState(false);
    const { loaders: { DELETE_API_TOKEN: loading }, errors: { DELETE_API_TOKEN: error }, } = useApiTokensState();
    const { deleteUserApiToken, setApiTokensError, setApiTokensLoader } = useApiTokensActions();
    react.exports.useEffect(() => {
        setApiTokensError({ key: ApiStateKeys.DELETE_API_TOKEN, value: false });
        setApiTokensLoader({ key: ApiStateKeys.DELETE_API_TOKEN, value: false });
    }, [setApiTokensError, setApiTokensLoader]);
    react.exports.useEffect(() => {
        if (submitted && !error && !loading) {
            onClose();
        }
    }, [submitted, error, loading, onClose]);
    const handleDeleteApiToken = react.exports.useCallback(() => {
        deleteUserApiToken(token);
        setSubmitted(true);
    }, [token, setSubmitted, deleteUserApiToken]);
    return (React.createElement(DeleteDialog, { dataTestId: 'deleteApiBtn', title: t('title'), cancelButtonText: t('cancel'), deleteButtonText: t('delete'), description: React.createElement(React.Fragment, null,
            t('areYouSureDeleteApiToken1'),
            " ",
            React.createElement("strong", null,
                "(Token: ",
                token,
                ")"),
            "? ",
            t('areYouSureDeleteApiToken2')), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleDeleteApiToken }));
};

const PersonalTokensTable = () => {
    const t = useT('personalTokens');
    const { injector } = useShadowDom();
    const container = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl;
    const { apiTokensDataUser: tokensData, searchValue, loaders: { LOAD_API_TOKENS: loading } } = useApiTokensState();
    const [deleteTokenDialog, handleCloseDeleteToken, handleOpenDeleteToken, deleteApiTokenData] = useDialogState();
    const rows = react.exports.useMemo(() => {
        if (!!searchValue) {
            return tokensData.filter((token) => token.description.indexOf(searchValue) !== -1 || token.clientId.indexOf(searchValue) !== -1);
        }
        return tokensData;
    }, [tokensData, searchValue]);
    const columns = react.exports.useMemo(() => PersonalTokensTableColumns({ t }), [t]);
    const getRowActions = react.exports.useMemo(() => PersonalTokenTableRowActions({
        t,
        container,
        handleOpenDeleteToken,
    }), [t, container, handleOpenDeleteToken]);
    const tablePlaceholderProps = react.exports.useMemo(() => {
        if (loading) {
            return null;
        }
        else if (!searchValue && rows.length === 0) {
            return {
                show: true,
                icon: React.createElement(APITokenIcon, null),
                title: t('noApiTokensYet'),
                description: t('noApiTokensYetDescription'),
                testId: 'empty-table-personal-tokens'
            };
        }
        else if (searchValue && rows.length === 0) {
            return {
                show: true,
                icon: React.createElement(SearchBigIcon, null),
                title: t('noResultFound'),
                description: t('noResultFoundDescription'),
                testId: 'empty-search-personal-tokens'
            };
        }
        return null;
    }, [t, loading, searchValue, rows.length]);
    return React.createElement(React.Fragment, null,
        React.createElement(Table, { columns: columns, data: rows, getRowActions: getRowActions, loading: !!loading }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))),
        React.createElement(DeleteApiTokenDialog, { open: deleteTokenDialog, onClose: handleCloseDeleteToken, token: deleteApiTokenData }));
};

const PersonalTokensPage$1 = () => {
    const { loadRoles } = useAuthTeamActions();
    const { loadApiTokens, setApiTokensState } = useApiTokensActions();
    const { apiTokensDataUser } = useApiTokensState();
    const [addTokenDialog, handleCloseAddToken, handleOpenAddToken] = useDialogState();
    react.exports.useEffect(() => {
        const queryObject = { pageOffset: 0, filter: [], silentLoading: apiTokensDataUser.length > 0 };
        loadRoles();
        loadApiTokens(queryObject);
        return () => loadApiTokens(queryObject);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadApiTokens, loadRoles]);
    const onDialogCloseHandler = react.exports.useCallback(() => {
        handleCloseAddToken();
        setTimeout(() => setApiTokensState({ successDialog: { clientId: '', secret: '', open: false } }), 400);
    }, [handleCloseAddToken, setApiTokensState]);
    return (React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(PersonalTokensHeader, { handleOpenAddToken: handleOpenAddToken }),
        React.createElement(Box, { mt: 6, flex: 1, display: 'flex', flexDirection: 'column' },
            React.createElement(PersonalTokensTable, null)),
        React.createElement(AddTokenDialog, { open: addTokenDialog, onClose: onDialogCloseHandler })));
};
var PersonalTokensPage$2 = PersonalTokensPage$1;

var PersonalTokensPage = wrapPage(PersonalTokensPage$2, 'personalTokens');

styled(Skeleton) `
  &.MuiSkeleton-root {
    height: ${({ theme }) => theme.spacing(12)};
    width: 100%;
    transform: scale(1, 1);
    margin-bottom: ${({ theme }) => theme.spacing(2)};
  }
`;
const BoxSkeleton = styled(Skeleton) `
  &.MuiSkeleton-root {
    width: 100%;
    transform: scale(1, 1);
    margin-bottom: ${({ theme }) => theme.spacing(4)};
  }
`;

const CurrentPlanComponentSkeleton = () => {
    return (React.createElement(Grid, { container: true },
        React.createElement(Grid, { item: true, xs: true, p: 0 },
            React.createElement(Skeleton, { height: 52, width: '80%' }),
            React.createElement(Skeleton, { height: 24, width: '60%' }),
            React.createElement(Skeleton, { height: 32, width: '100%' })),
        React.createElement(Grid, { item: true, container: true, xs: true, p: 0, direction: 'column' },
            React.createElement(Grid, { container: true, mb: 12, justifyContent: 'flex-end' },
                React.createElement(Grid, { item: true, mr: 6 },
                    React.createElement(BoxSkeleton, { height: 40, width: 132 })),
                React.createElement(Grid, { item: true },
                    React.createElement(BoxSkeleton, { height: 40, width: 132 }))))));
};

const INVOICE_DATE_FORMAT = 'MMM dd, yyyy';
const BILLING_INFORMATION_PLAN_DATE_FORMAT = 'MMM dd, yyyy';
const DATE_FILENAME_FORMAT = 'ddMMyyyy';

const useSubscriptionPermissions = (permission) => {
    return usePermission(permission || 'fe.subscriptions.write.*');
};
const useBillingMetadata = () => {
    var _a, _b, _c, _d;
    const { summary, plan } = useBillingInformation();
    const { vendorPublicConfig } = useVendorPublicConfig();
    const { subscription } = useSubscription();
    const { plans } = usePlans();
    const now = Date.now();
    const { cancellation, status, trialEnd } = subscription || {};
    const willBeCanceled = (cancellation === null || cancellation === void 0 ? void 0 : cancellation.policy) === ISubscriptionCancellationPolicy.AT_PERIOD_END;
    const isCanceled = status === ISubscriptionStatus.CANCELED;
    const isDefaultPlan = (summary === null || summary === void 0 ? void 0 : summary.defaultPlanId) === (summary === null || summary === void 0 ? void 0 : summary.currentPlanId);
    const isTrialing = status === ISubscriptionStatus.TRIALING;
    const isInTrialPeriod = trialEnd && new Date(trialEnd).getTime() > now;
    const isExternallyManaged = (summary === null || summary === void 0 ? void 0 : summary.externallyManaged) || false;
    const hasPaymentMethod = !!(summary === null || summary === void 0 ? void 0 : summary.paymentMethodId);
    const isFreePlan = ((_b = (_a = plan === null || plan === void 0 ? void 0 : plan.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes('free')) || ((_d = (_c = plan === null || plan === void 0 ? void 0 : plan.description) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === null || _d === void 0 ? void 0 : _d.includes('free'));
    const plansAmount = plans === null || plans === void 0 ? void 0 : plans.length;
    const isSingularPlan = plansAmount === 1;
    const defaultPlanId = summary === null || summary === void 0 ? void 0 : summary.defaultPlanId;
    const hasTrialEnded = status === ISubscriptionStatus.TRIAL_ENDED;
    const currentPlanIndex = plans.findIndex((p) => p.id === (plan === null || plan === void 0 ? void 0 : plan.id));
    const canDowngrade = currentPlanIndex <= 0 || (vendorPublicConfig === null || vendorPublicConfig === void 0 ? void 0 : vendorPublicConfig.allowPlanDowngrade);
    const canUpgrade = currentPlanIndex < plansAmount - 1;
    const canCancel = !!(vendorPublicConfig === null || vendorPublicConfig === void 0 ? void 0 : vendorPublicConfig.allowPlanCancellation);
    return react.exports.useMemo(() => ({
        isCanceled,
        willBeCanceled,
        isDefaultPlan,
        isTrialing,
        isInTrialPeriod,
        isExternallyManaged,
        hasPaymentMethod,
        isFreePlan,
        isSingularPlan,
        defaultPlanId,
        hasTrialEnded,
        canDowngrade,
        canUpgrade,
        canCancel,
    }), [
        isCanceled,
        willBeCanceled,
        isDefaultPlan,
        isTrialing,
        isInTrialPeriod,
        isExternallyManaged,
        hasPaymentMethod,
        isFreePlan,
        isSingularPlan,
        defaultPlanId,
        hasTrialEnded,
        canDowngrade,
        canUpgrade,
        canCancel,
    ]);
};

const CanceledChip = () => {
    const t = useT('subscriptions_CurrentPlan');
    return React.createElement(StatusChip, { status: 'error', withIcons: false, label: t('canceled') });
};

const TrialingChip = () => {
    const t = useT('subscriptions_CurrentPlan');
    return React.createElement(StatusChip, { status: 'default', withIcons: false, label: t('trialing') });
};

const TrialEndedChip = () => {
    const t = useT('subscriptions_CurrentPlan');
    return React.createElement(StatusChip, { status: 'error', withIcons: false, label: t('trialEnded') });
};

const subscriptionStatusChipMap = {
    [ISubscriptionStatus.INCOMPLETE]: null,
    [ISubscriptionStatus.ACTIVE]: null,
    [ISubscriptionStatus.TRIALING]: TrialingChip,
    [ISubscriptionStatus.CANCELED]: CanceledChip,
    [ISubscriptionStatus.TRIAL_ENDED]: TrialEndedChip,
    [ISubscriptionStatus.EXPIRED]: null,
};

const PlanDetailsStatusChip = () => {
    const { subscription } = useSubscription();
    const { willBeCanceled } = useBillingMetadata();
    let Component = (subscription === null || subscription === void 0 ? void 0 : subscription.status) && subscriptionStatusChipMap[subscription.status];
    if (willBeCanceled) {
        Component = subscriptionStatusChipMap[ISubscriptionStatus.CANCELED];
    }
    if (!Component) {
        return null;
    }
    return React.createElement(Component, null);
};

const PlanDetails = () => {
    const t = useT('subscriptions_CurrentPlan');
    const { plan } = useBillingInformation();
    const { subscription } = useSubscription();
    const { isTrialing, isExternallyManaged, isFreePlan, willBeCanceled, hasTrialEnded } = useBillingMetadata();
    const { name = t('unknownPlan'), price = 0, currency = 'usd', description: priceDescription } = plan || {};
    const priceString = `${toCurrencySymbol(currency)}${toPriceDisplay(price)}`;
    let description = '';
    if (!isExternallyManaged) {
        if (isTrialing && (subscription === null || subscription === void 0 ? void 0 : subscription.trialEnd)) {
            description = t('yourPlanIsTrialing', {
                periodEnd: format(new Date(subscription === null || subscription === void 0 ? void 0 : subscription.trialEnd), BILLING_INFORMATION_PLAN_DATE_FORMAT),
            });
        }
        else if ((subscription === null || subscription === void 0 ? void 0 : subscription.currentPeriodEnd) && !isFreePlan && !hasTrialEnded) {
            description = t(willBeCanceled ? 'yourPlanWillBeCanceled' : 'yourPlanWillBeRenewed', {
                periodEnd: format(new Date(subscription === null || subscription === void 0 ? void 0 : subscription.currentPeriodEnd), BILLING_INFORMATION_PLAN_DATE_FORMAT),
            });
        }
    }
    return (React.createElement(Grid, { container: true, direction: 'column' },
        React.createElement(Grid, { item: true, container: true, alignItems: 'center', mb: 4 },
            React.createElement(Grid, { item: true, pr: 2 },
                React.createElement(Typography$1, { variant: 'h3' }, name)),
            React.createElement(Grid, { item: true, pt: 3 },
                React.createElement(PlanDetailsStatusChip, null))),
        React.createElement(Grid, { item: true, mb: !description ? 0 : 10 },
            React.createElement(Typography$1, { variant: 'subtitle1' }, priceDescription ? React.createElement(TextBreakLine, { text: priceDescription }) : t('priceSubtitle', { price: priceString }))),
        description && (React.createElement(Grid, { item: true },
            React.createElement(Typography$1, { variant: 'body2' }, description)))));
};

const RowActionButtons = ({ main, secondary }) => {
    return (React.createElement(Grid, { item: true, container: true, xs: true, p: 0, direction: 'column' },
        React.createElement(Grid, { container: true, mb: 12, justifyContent: 'flex-end' },
            React.createElement(Grid, { item: true, mr: 6 }, main),
            React.createElement(Grid, { item: true }, secondary))));
};

const SelectPlanButton = ({ onClick }) => {
    const t = useT('subscriptions_CurrentPlan');
    return (React.createElement(Button$1, { "data-test-id": 'updateButton', variant: "contained", color: "primary", onClick: onClick }, t('updateButton')));
};

const RenewDialogBody = () => {
    const t = useT('subscriptions_Renewal');
    const { subscription } = useSubscription();
    const endDate = (subscription === null || subscription === void 0 ? void 0 : subscription.currentPeriodEnd) ? format(new Date(subscription === null || subscription === void 0 ? void 0 : subscription.currentPeriodEnd), BILLING_INFORMATION_PLAN_DATE_FORMAT)
        : t('unknownDate');
    return (React.createElement(Typography$1, { variant: 'body1' }, t('description', { renewalDate: endDate })));
};

const RenewDialogFooter = ({ onClose }) => {
    const { loading, error } = useSubscriptionRenewal();
    const { renewSubscription } = useBillingInformationActions();
    return (React.createElement(SubscriptionDialogFooter, { cancel: { onClick: onClose, disabled: loading }, confirm: { loading, disabled: !!error, onClick: renewSubscription, text: 'confirm' } }));
};

const RenewDialog = ({ open, onClose }) => {
    const { injector } = useShadowDom();
    const t = useT('subscriptions');
    return (React.createElement(Dialog$1, { open: open, onClose: onClose, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, title: t('dialogRenewalTitle'), size: "sm" },
        React.createElement(Dialog$1.Body, null,
            React.createElement(RenewDialogBody, null)),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(RenewDialogFooter, { onClose: onClose }))));
};

const RenewButton = () => {
    const t = useT('subscriptions_CurrentPlan');
    const [isOpen, closeDialog, openDialog] = useDialogState();
    const { loading } = useSubscriptionRenewal();
    return (React.createElement(React.Fragment, null,
        React.createElement(Button$1, { loading: loading, "data-test-id": 'renewButton', variant: "contained", color: "primary", onClick: openDialog }, t('renewButton')),
        React.createElement(RenewDialog, { open: isOpen, onClose: closeDialog })));
};

const BillingActionMainButton = ({ openPlanSelect }) => {
    const { isCanceled, willBeCanceled, canDowngrade, canUpgrade, isTrialing, hasTrialEnded } = useBillingMetadata();
    if (isCanceled || willBeCanceled) {
        return React.createElement(RenewButton, null);
    }
    else if (isTrialing || hasTrialEnded || canDowngrade || canUpgrade) {
        return React.createElement(SelectPlanButton, { onClick: openPlanSelect });
    }
    return null;
};

const CancelDialogFooter = ({ onClose }) => {
    const { loading, error } = useSubscriptionCancellation();
    const { cancelSubscription } = useBillingInformationActions();
    const cancel = react.exports.useMemo(() => ({
        onClick: onClose,
        disabled: loading,
    }), [onClose, loading]);
    const confirm = react.exports.useMemo(() => ({
        onClick: cancelSubscription,
        disabled: !!error,
        color: 'danger',
        text: 'confirm',
        loading,
    }), [cancelSubscription, error, loading]);
    return (React.createElement(SubscriptionDialogFooter, { cancel: cancel, confirm: confirm }));
};

const CancelDialogBody = () => {
    const t = useT('subscriptions_Cancellation');
    const { subscription } = useSubscription();
    const { error } = useSubscriptionCancellation();
    const endDate = (subscription === null || subscription === void 0 ? void 0 : subscription.currentPeriodEnd) ? format(new Date(subscription === null || subscription === void 0 ? void 0 : subscription.currentPeriodEnd), BILLING_INFORMATION_PLAN_DATE_FORMAT)
        : t('unknownDate');
    return (React.createElement(React.Fragment, null,
        error && (React.createElement(Alert$1, { "data-test-id": error, severity: "error" }, error)),
        React.createElement(Typography$1, { variant: 'body1' }, t('description', { expirationDate: endDate }))));
};

const CancelDialog = ({ open, onClose }) => {
    const { injector } = useShadowDom();
    const t = useT('subscriptions');
    return (React.createElement(Dialog$1, { open: open, onClose: onClose, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, title: t('dialogCancellationTitle'), size: "sm" },
        React.createElement(Dialog$1.Body, null,
            React.createElement(CancelDialogBody, null)),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(CancelDialogFooter, { onClose: onClose }))));
};

const PlanContainer = styled(Grid)(({ theme }) => ({
    padding: theme.spacing(6, 0),
    borderBottom: `1px solid ${theme.palette.grey[300]}`,
    '&:last-child': {
        borderBottom: 'none',
    },
    justifyContent: 'space-between',
    alignContent: 'center',
    alignItems: 'center',
}));
const PlanTitle = styled(Grid)(({ theme }) => ({
    color: theme.palette.grey[800],
    fontWeight: 'bold',
    fontSize: theme.typography.pxToRem(16),
    lineHeight: theme.typography.pxToRem(24),
    marginBottom: theme.spacing(2),
}));
const PlanPrice = styled(Grid)(({ theme }) => ({
    color: theme.palette.grey[700],
    fontSize: theme.typography.pxToRem(12),
    lineHeight: theme.typography.pxToRem(16),
    marginBottom: theme.spacing(2),
}));
const PlanDescription = styled(Grid)(({ theme }) => ({
    color: theme.palette.grey[700],
    fontSize: theme.typography.pxToRem(12),
    lineHeight: theme.typography.pxToRem(16),
    marginBottom: theme.spacing(2),
}));
const PlanSelectedCheckedIcon = styled(CheckedIcon)(({ theme }) => ({
    color: theme.palette.success.main,
    fontSize: theme.typography.pxToRem(12),
    lineHeight: theme.typography.pxToRem(16),
    marginRight: theme.spacing(2),
}));
const PlanSelectedText = styled('span')(({ theme }) => ({
    color: theme.palette.grey[800],
    fontSize: theme.typography.pxToRem(12),
    lineHeight: theme.typography.pxToRem(16),
}));
const SelectPlanItem = (props) => {
    const { isSelected, title, description, price, onClick } = props;
    const handleClick = react.exports.useCallback(() => onClick(), [onClick]);
    const t = useT('subscriptions_DialogSelection');
    return (React.createElement(PlanContainer, { container: true },
        React.createElement(Grid, { item: true, alignContent: 'center' },
            React.createElement(PlanTitle, null, title),
            React.createElement(PlanPrice, { "data-test-id": price },
                React.createElement(TextBreakLine, { text: price })),
            React.createElement(PlanDescription, null, description)),
        React.createElement(Grid, { item: true }, isSelected ? (React.createElement(Grid, { container: true, justifyContent: 'space-between', alignContent: 'center', alignItems: 'center', padding: 4 },
            React.createElement(PlanSelectedCheckedIcon, null),
            React.createElement(PlanSelectedText, null, t('currentPlan')))) : (React.createElement(Button$1, { "data-test-id": 'continueBtn-' + title, type: 'button', color: 'secondary', onClick: handleClick }, t('continue'))))));
};

const SelectPlan = ({ onSelectPlan }) => {
    const t = useT('subscriptions_DialogSelection');
    const { plans } = usePlans();
    const { summary } = useBillingInformation();
    const { isTrialing } = useBillingMetadata();
    const { currentPlanId: selectedPlanId } = summary || {};
    const displayPlans = react.exports.useMemo(() => plans.slice(0, 5), [plans]);
    const planSelectionItems = react.exports.useMemo(() => displayPlans.map(({ id, name, description, currency, price, recurringInterval }) => (React.createElement(SelectPlanItem, { key: id, isSelected: !!selectedPlanId && id === selectedPlanId && !isTrialing, title: name, description: !!description ? '' : description, price: description ||
            t('selectPlanPricePerRecurringInterval', {
                price: toPriceDisplay(price),
                currency: toCurrencySymbol(currency),
                interval: recurringInterval,
            }), onClick: () => onSelectPlan(id) }))), [displayPlans, selectedPlanId, onSelectPlan, t, isTrialing]);
    return (React.createElement(Grid, { container: true, direction: 'column' }, planSelectionItems));
};

const SelectDialogFooter = ({ onClose }) => {
    return (React.createElement(SubscriptionDialogFooter, { cancel: { onClick: onClose } }));
};

const SelectDialogBody = ({ onSelectPlan, onClose }) => {
    const { error, plans, fetching: planFetching } = usePlans();
    const loading = react.exports.useMemo(() => plans.length === 0 && planFetching, [plans, planFetching]);
    return (React.createElement(React.Fragment, null,
        React.createElement(Dialog$1.Body, null,
            error && (React.createElement(Grid, { p: 4 },
                React.createElement(Alert$1, { severity: "error" }, error))),
            loading ? (React.createElement(BoxLoader, { height: 220 })) : (React.createElement(SelectPlan, { onSelectPlan: onSelectPlan }))),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(SelectDialogFooter, { onClose: onClose }))));
};

const CheckoutDialogContent = ({ planId, onClose, onSuccess, onError }) => {
    const { plans } = usePlans();
    const { isTrialing } = useBillingMetadata();
    const hasPlanSelection = plans.length > 1 && !isTrialing;
    const initPlanId = react.exports.useMemo(() => { var _a; return planId && ((_a = plans.find((plan) => plan.id === planId)) === null || _a === void 0 ? void 0 : _a.id); }, [planId, plans]);
    const [checkoutPlanId, setCheckoutPlanId] = React.useState(initPlanId || null);
    react.exports.useEffect(() => {
        setCheckoutPlanId(initPlanId || null);
    }, [initPlanId]);
    const handlePlanSelection = react.exports.useCallback((planId) => {
        setCheckoutPlanId(planId);
    }, []);
    const goBack = react.exports.useCallback(() => {
        if (hasPlanSelection) {
            setCheckoutPlanId(null);
        }
        else {
            onClose();
        }
    }, [hasPlanSelection, onClose]);
    const handleSuccess = react.exports.useCallback(() => {
        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();
    }, [onSuccess]);
    const handleError = react.exports.useCallback((msg) => {
        onError === null || onError === void 0 ? void 0 : onError(msg);
    }, [onError]);
    if (!checkoutPlanId) {
        return React.createElement(SelectDialogBody, { onSelectPlan: handlePlanSelection, onClose: onClose });
    }
    return (React.createElement(CheckoutDialogBody, { planId: checkoutPlanId, onClose: goBack, onSuccess: handleSuccess, onError: handleError }));
};

const CheckoutDialog = (_a) => {
    var { planId, open, onClose, onSuccess, onError } = _a, props = __rest(_a, ["planId", "open", "onClose", "onSuccess", "onError"]);
    const t = useT('subscriptions');
    const handleSuccess = react.exports.useCallback(() => {
        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();
    }, [onSuccess]);
    const handleError = react.exports.useCallback((msg) => {
        onError === null || onError === void 0 ? void 0 : onError(msg);
    }, [onError]);
    return (React.createElement(Dialog$1, Object.assign({}, props, { open: open, onClose: onClose, title: t('dialogCheckoutTitle'), size: 'sm' }),
        React.createElement(CheckoutDialogContent, { planId: planId, onSuccess: handleSuccess, onError: handleError, onClose: onClose })));
};

const EmailField$1 = () => {
    const t = useT('subscriptions');
    return React.createElement(Field, { "data-test-id": "email", autoComplete: "street-address", name: 'email', placeholder: t('emailInputPlaceholder'), label: t('emailInputLabel') });
};
const CustomCountryField = () => {
    const t = useT('subscriptions');
    return React.createElement(CountryField, { label: t('countryInputLabel'), countryCode: true, placeholder: t('countryInputPlaceholder') });
};
const Address1Field = () => {
    const t = useT('subscriptions');
    return React.createElement(Field, { "data-test-id": "address1", autoComplete: "street-address", name: 'addressLine1', placeholder: t('address1InputPlaceholder'), label: t('address1InputLabel') });
};
const Address2Field = () => {
    const t = useT('subscriptions');
    return React.createElement(Field, { "data-test-id": "address2", autoComplete: "address-level3", name: 'addressLine2', placeholder: t('address2InputPlaceholder'), label: t('address2InputLabel') });
};
const CityField = () => {
    const t = useT('subscriptions');
    return React.createElement(Field, { "data-test-id": "city", autoComplete: "address-level2", name: 'city', placeholder: t('cityInputPlaceholder'), label: t('cityInputLabel') });
};
const StateField = () => {
    const t = useT('subscriptions');
    return React.createElement(Field, { "data-test-id": "state", autoComplete: "address-level1", name: 'state', placeholder: t('stateInputPlaceholder'), label: t('stateInputLabel') });
};
const PostcodeField = () => {
    const t = useT('subscriptions');
    return React.createElement(Field, { "data-test-id": "postalCode", autoComplete: "postal-code", name: 'postalCode', placeholder: t('postCodeInputPlaceholder'), label: t('postCodeInputLabel') });
};
const SubscriptionUpdateBillingDetailsDialogBody = ({ onClose }) => {
    const t = useT('subscriptions');
    const { profile } = useProfileState();
    const { paymentMethod, loading, error } = usePaymentMethod();
    const { updatePaymentMethodBillingDetails, setError } = usePaymentMethodActions();
    const { billingDetails, id = '' } = paymentMethod !== null && paymentMethod !== void 0 ? paymentMethod : {};
    const { email = (profile === null || profile === void 0 ? void 0 : profile.email) || '', address } = billingDetails !== null && billingDetails !== void 0 ? billingDetails : {};
    const { addressLine1 = '', addressLine2 = '', city = '', state = '', postalCode = '', country = '' } = address !== null && address !== void 0 ? address : {};
    const initialValues = react.exports.useMemo(() => ({
        email,
        addressLine1,
        addressLine2,
        city,
        state,
        postalCode,
        country,
    }), [email, addressLine1, addressLine2, city, state, postalCode, country]);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        email: validateEmail(t('emailMustBeValid'), t('emailIsRequired')),
        postalCode: validationPostCodeOptional(t('postCodeIsInvalid')),
    }), [t]);
    const formikProps = {
        onSubmit: (_a, { setSubmitting }) => {
            var { email } = _a, address = __rest(_a, ["email"]);
            const callback = (success) => (success ? onClose() : setSubmitting(false));
            updatePaymentMethodBillingDetails({
                id,
                email,
                address,
                callback,
            });
        },
        initialValues,
        validationSchema,
    };
    const handleClose = react.exports.useCallback(() => {
        onClose();
        setError(null);
    }, [onClose, setError]);
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                error && (React.createElement(Grid, { mb: 5 },
                    React.createElement(Alert$1, { severity: "error" }, error))),
                React.createElement(EmailField$1, null),
                React.createElement(Address1Field, null),
                React.createElement(Address2Field, null),
                React.createElement(Grid, { container: true, spacing: 4, mb: 4 },
                    React.createElement(Grid, { item: true, xs: 6 },
                        React.createElement(CityField, null)),
                    React.createElement(Grid, { item: true, xs: 6 },
                        React.createElement(StateField, null))),
                React.createElement(Grid, { container: true, spacing: 4 },
                    React.createElement(Grid, { item: true, xs: 6 },
                        React.createElement(PostcodeField, null)),
                    React.createElement(Grid, { item: true, xs: 6 },
                        React.createElement(CustomCountryField, null)))),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(SubscriptionDialogFooter, { cancel: { onClick: handleClose, disabled: isSubmitting || loading }, confirm: { loading: isSubmitting || loading, disabled: !canSubmit, type: 'submit', text: 'update' } }))));
    }));
};

const SubscriptionUpdateBillingDetailsDialog = ({ open, onClose }) => {
    const t = useT('subscriptions');
    const { injector } = useShadowDom();
    return (React.createElement(Dialog$1, { open: open, onClose: onClose, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, title: t('dialogUpdateBillingDetailsTitle'), size: "sm" },
        React.createElement(SubscriptionUpdateBillingDetailsDialogBody, { onClose: onClose })));
};

const SubscriptionUpdatePaymentMethodDialogFooter = ({ loading, onCancel }) => {
    const { valid, onSubmit } = useSubscriptionFormContext();
    const handleConfirm = react.exports.useCallback(() => {
        if (onSubmit) {
            onSubmit();
        }
    }, [onSubmit]);
    const handleCancel = react.exports.useCallback(() => onCancel(), [onCancel]);
    return (React.createElement(SubscriptionDialogFooter, { cancel: { onClick: handleCancel, disabled: loading }, confirm: { onClick: handleConfirm, loading, disabled: !valid, text: 'update' } }));
};

const SubscriptionUpdatePaymentMethodDialogBody = ({ onClose }) => {
    const t = useT('subscriptions');
    const { loading, error } = usePaymentMethod();
    const { submitPaymentMethod, submitPaymentMethodError, submitPaymentMethodSuccess } = usePaymentMethodActions();
    const handleSubmit = react.exports.useCallback(() => {
        submitPaymentMethod();
    }, [submitPaymentMethod]);
    const handleError = react.exports.useCallback((error) => {
        submitPaymentMethodError(error);
    }, [submitPaymentMethodError]);
    const handleSuccess = react.exports.useCallback(() => {
        submitPaymentMethodSuccess();
        onClose();
    }, [onClose, submitPaymentMethodSuccess]);
    return (React.createElement(SubscriptionFormContextProvider, null,
        React.createElement(Dialog$1.Body, { noPadding: true },
            error && (React.createElement(Grid, { p: 4 },
                React.createElement(Alert$1, { severity: "error" }, error))),
            React.createElement(DialogSectionBox, { title: t('paymentMethodTitle') },
                React.createElement(Grid, { container: true, p: 4 },
                    React.createElement(PaymentMethodForm, { mode: "update", onError: handleError, onSubmit: handleSubmit, onSuccess: handleSuccess })))),
        React.createElement(Dialog$1.Footer, null,
            React.createElement(SubscriptionUpdatePaymentMethodDialogFooter, { loading: loading, onCancel: onClose }))));
};

const SubscriptionUpdatePaymentMethodDialog = ({ open, onClose }) => {
    const { injector } = useShadowDom();
    const t = useT('subscriptions');
    return (React.createElement(Dialog$1, { open: open, onClose: onClose, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, title: t('updatePaymentMethod'), size: "sm" },
        React.createElement(SubscriptionUpdatePaymentMethodDialogBody, { onClose: onClose })));
};

const CancelButton = () => {
    const t = useT('subscriptions_CurrentPlan');
    const [isOpen, closeDialog, openDialog] = useDialogState();
    return (React.createElement(React.Fragment, null,
        React.createElement(Button$1, { "data-test-id": 'cancelButton', variant: "contained", color: "secondary", onClick: openDialog }, t('cancelButton')),
        React.createElement(CancelDialog, { open: isOpen, onClose: closeDialog })));
};

const BillingActionSecondaryButton = () => {
    const { isCanceled, willBeCanceled, isTrialing, hasPaymentMethod, isFreePlan, isSingularPlan, hasTrialEnded, canCancel, } = useBillingMetadata();
    if (!canCancel ||
        isSingularPlan ||
        isFreePlan ||
        (isTrialing && !hasPaymentMethod) ||
        isCanceled ||
        willBeCanceled ||
        hasTrialEnded) {
        return null;
    }
    return React.createElement(CancelButton, null);
};

const BillingActions = () => {
    const { injector } = useShadowDom();
    const { defaultPlanId } = useBillingMetadata();
    const { confirmed } = useCheckout();
    const [{ isOpen, selectedPlanId }, setState] = react.exports.useState({
        isOpen: false,
    });
    react.exports.useEffect(() => {
        if (confirmed) {
            setState({ isOpen: false, selectedPlanId: defaultPlanId });
        }
    }, [confirmed, defaultPlanId]);
    const handleOpenSelection = react.exports.useCallback(() => {
        setState({
            isOpen: true,
        });
    }, []);
    const handleOpenCheckout = react.exports.useCallback(() => {
        setState({
            isOpen: true,
            selectedPlanId: defaultPlanId,
        });
    }, [defaultPlanId]);
    const handleCloseCheckout = react.exports.useCallback(() => {
        setState(prevState => (Object.assign(Object.assign({}, prevState), { isOpen: false })));
    }, []);
    const main = react.exports.useMemo(() => React.createElement(BillingActionMainButton, { openCheckout: handleOpenCheckout, openPlanSelect: handleOpenSelection }), [handleOpenCheckout, handleOpenSelection]);
    const secondary = react.exports.useMemo(() => React.createElement(BillingActionSecondaryButton, null), []);
    return React.createElement(React.Fragment, null,
        React.createElement(RowActionButtons, { main: main, secondary: secondary }),
        React.createElement(CheckoutDialog, { open: isOpen, onClose: handleCloseCheckout, planId: selectedPlanId, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }));
};

const CurrentPlan = () => {
    const { fetching } = useBillingInformation();
    const { fetching: fetchingPlans } = usePlans();
    const hasWritePermission = useSubscriptionPermissions('fe.subscriptions.write.*');
    const { isExternallyManaged } = useBillingMetadata();
    if (fetching || fetchingPlans) {
        return React.createElement(CurrentPlanComponentSkeleton, null);
    }
    else {
        return (React.createElement(Grid, { container: true, p: 0 },
            React.createElement(Grid, { item: true, xs: true },
                React.createElement(PlanDetails, null)),
            React.createElement(Grid, { item: true }, hasWritePermission && !isExternallyManaged && React.createElement(BillingActions, null))));
    }
};

const CardNarrow = styled(Card)(({ theme }) => ({
    padding: 0,
    margin: 0,
}));
const DetailSectionBox = ({ title, children }) => {
    return (React.createElement(Grid, { mb: 6 },
        React.createElement(Typography$1, { variant: 'subtitle1', mb: 4 }, title),
        React.createElement(CardNarrow, null, children)));
};

const CurrentPlanBox = ({ children }) => {
    const t = useT('subscriptions_CurrentPlan');
    return (React.createElement(DetailSectionBox, { title: t('title') },
        React.createElement(Grid, { container: true, p: 8 }, children)));
};

const CurrentPlanComponent = () => {
    const { fetching, loading } = useBillingInformation();
    const isLoading = react.exports.useMemo(() => fetching || loading, [fetching, loading]);
    return React.createElement(CurrentPlanBox, null, isLoading ? React.createElement(CurrentPlanComponentSkeleton, null) : React.createElement(CurrentPlan, null));
};

const RowSkeleton = styled(Skeleton) `
  &.MuiSkeleton-root {
    height: ${({ theme }) => theme.spacing(12)};
    width: 100%;
    transform: scale(1, 1);
    margin-bottom: ${({ theme }) => theme.spacing(2)};
  }
`;
const TableSkeleton = react.exports.forwardRef(({ title = true, rows = 3, cols = 1 }, ref) => {
    const table = react.exports.useMemo(() => {
        const range = Array.from({ length: rows }, (v, i) => i);
        const colsRange = Array.from({ length: cols }, (v, i) => i);
        return range.map(row => React.createElement(Grid, { container: true, key: row, spacing: 4 }, row === 0 ? React.createElement(Grid, { item: true, xs: true },
            React.createElement(RowSkeleton, null)) :
            colsRange.map(col => React.createElement(Grid, { key: col, item: true, xs: true },
                React.createElement(RowSkeleton, null)))));
    }, [rows, cols]);
    return React.createElement(Box, { ref: ref },
        title && React.createElement(Box, { marginBottom: 1 },
            React.createElement(Skeleton, { width: 200, height: 40 })),
        table);
});
TableSkeleton.defaultProps = {
    title: true,
};

const InvoicesListComponentSkeleton = () => (React.createElement(Box, { p: 4 },
    React.createElement(TableSkeleton, { rows: 5, title: false, cols: 4 })));

const InvoicesListBox = ({ children }) => {
    const t = useT('subscriptions');
    return React.createElement(DetailSectionBox, { title: t('invoices') }, children);
};

const InvoicesTable = styled(Table)(({ theme }) => ({}));
const AmountChipCell = ({ value }) => {
    return (React.createElement(Box, { maxWidth: '100%' },
        React.createElement(Grid, { container: true, alignItems: 'center', justifyItems: 'center' },
            React.createElement(Grid, { item: true },
                React.createElement(Typography$1, { variant: 'tableTitleCell' }, value.amount)),
            React.createElement(Grid, { item: true, ml: 4, pt: 2 }, value.status === 'paid' && React.createElement(StatusChip, { label: 'Paid', status: 'success', withIcons: false })))));
};
const invoicesTableColumns = [
    {
        Header: 'Billing Date',
        id: 'billingDate',
        accessor: ({ billingDate }) => ({ date: billingDate, format: INVOICE_DATE_FORMAT, withAgo: false }),
        Cell: TableDateCell,
    },
    {
        Header: 'Amount',
        id: 'amount',
        accessor: ({ amount, status }) => ({
            amount,
            status,
        }),
        Cell: AmountChipCell,
    },
];
const InvoiceList = () => {
    const t = useT('subscriptions');
    const { injector } = useShadowDom();
    const container = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl;
    const { loading, invoices } = useInvoices();
    const { downloadInvoice } = useInvoicesActions();
    const handleInvoiceDownload = react.exports.useCallback((invoice) => {
        downloadInvoice({
            invoiceId: invoice.id,
            filename: `invoice_${format$1(invoice.billingDate || new Date(), DATE_FILENAME_FORMAT)}`,
        });
    }, [downloadInvoice]);
    const tableData = react.exports.useMemo(() => invoices.map((invoice, index) => ({
        id: invoice.id,
        billingDate: invoice.paymentDate,
        status: invoice.paid ? 'paid' : '',
        isDefault: index === 0,
        amount: `$${invoice.totalAmount}`,
    })), [invoices]);
    return (React.createElement(Box, null,
        React.createElement(InvoicesTable, { inline: true, autoHeight: false, loading: loading, columns: invoicesTableColumns, data: tableData, contentMaxHeight: {
                maxHeight: '24rem',
            }, getRowActions: (row) => ({
                items: [
                    {
                        icon: React.createElement(PdfIcon, { "data-test-id": 'DownloadPdf' }),
                        onClick: () => handleInvoiceDownload(row),
                        text: t('downloadPdf'),
                        negative: false,
                    },
                ],
                container,
            }) })));
};

const InvoicesListComponent = () => {
    const { fetching, error } = useInvoices();
    return (React.createElement(InvoicesListBox, null, fetching ? (React.createElement(InvoicesListComponentSkeleton, null)) : error ? (React.createElement(Alert$1, { severity: 'error' }, error)) : (React.createElement(InvoiceList, null))));
};

const BillingDetailsComponentSkeleton = () => (React.createElement(Grid, { container: true, p: 0, m: 0 },
    React.createElement(Skeleton, { height: '32px', width: '100%' })));

const UpdateBillingMethod = styled(Grid)(({ theme }) => ({
    display: 'flex',
    alignItems: 'center',
    cursor: 'pointer',
    svg: {
        marginLeft: theme.spacing(4),
        width: '0.75rem',
        height: '0.75rem',
        color: theme.palette.grey[500],
    },
}));
const BillingDetails = () => {
    var _a, _b;
    const t = useT('subscriptions_Billing');
    const [isOpen, closeDialog, openDialog] = useDialogState();
    const { paymentMethod } = usePaymentMethod();
    const { email, name } = (_a = paymentMethod === null || paymentMethod === void 0 ? void 0 : paymentMethod.billingDetails) !== null && _a !== void 0 ? _a : {};
    return (React.createElement(Grid, { container: true, p: 0, alignItems: "center" },
        React.createElement(Grid, { item: true, xs: true },
            React.createElement(Typography$1, { variant: "label" }, (_b = email !== null && email !== void 0 ? email : name) !== null && _b !== void 0 ? _b : '')),
        React.createElement(Grid, { item: true },
            React.createElement(UpdateBillingMethod, { item: true, onClick: openDialog },
                React.createElement(Typography$1, { variant: "body1" }, t('title')),
                React.createElement(EditIcon, null))),
        React.createElement(SubscriptionUpdateBillingDetailsDialog, { open: isOpen, onClose: closeDialog })));
};

const BillingDetailsBox = ({ children }) => {
    const t = useT('subscriptions_Billing');
    return (React.createElement(DetailSectionBox, { title: t('title') },
        React.createElement(Grid, { container: true, p: 6 }, children)));
};

const BillingDetailsComponent = () => {
    const { fetching, paymentMethod } = usePaymentMethod();
    if (!fetching && !(paymentMethod === null || paymentMethod === void 0 ? void 0 : paymentMethod.id)) {
        return null;
    }
    return React.createElement(BillingDetailsBox, null, fetching ? React.createElement(BillingDetailsComponentSkeleton, null) : React.createElement(BillingDetails, null));
};

const PaymentMethodComponentSkeleton = () => (React.createElement(Grid, { container: true, p: 0, m: 0 },
    React.createElement(Skeleton, { height: '32px', width: '100%' })));

const PaymentMethodBox = ({ children }) => {
    const t = useT('subscriptions');
    return (React.createElement(DetailSectionBox, { title: t('paymentMethodTitle') },
        React.createElement(Grid, { container: true, p: 6 }, children)));
};

const PaymentMethodDisplay = () => {
    const [isOpen, closeDialog, openDialog] = useDialogState();
    const { paymentMethod } = usePaymentMethod();
    return React.createElement(React.Fragment, null,
        React.createElement(PaymentMethodSelect, Object.assign({}, (paymentMethod || {}), { onUpdate: openDialog })),
        React.createElement(SubscriptionUpdatePaymentMethodDialog, { open: isOpen, onClose: closeDialog }));
};

const PaymentMethodComponent = () => {
    const { fetching } = usePaymentMethod();
    return (React.createElement(PaymentMethodBox, null, fetching ? React.createElement(PaymentMethodComponentSkeleton, null) : React.createElement(PaymentMethodDisplay, null)));
};

const BillingComponent = () => {
    return (React.createElement(React.Fragment, null,
        React.createElement(PaymentMethodComponent, null),
        React.createElement(BillingDetailsComponent, null)));
};

const SubscriptionSections = () => {
    const { isExternallyManaged, hasPaymentMethod } = useBillingMetadata();
    const permitted = useSubscriptionPermissions('fe.subscriptions.write.*');
    const hasBilling = !isExternallyManaged && hasPaymentMethod && permitted;
    return react.exports.useMemo(() => (React.createElement(React.Fragment, null,
        React.createElement(CurrentPlanComponent, null),
        hasBilling && (React.createElement(React.Fragment, null,
            React.createElement(BillingComponent, null),
            React.createElement(InvoicesListComponent, null))))), [hasBilling]);
};

const SubscriptionPageSkeleton = () => {
    return (React.createElement(PageWrapper, null,
        React.createElement(CurrentPlanBox, null,
            React.createElement(CurrentPlanComponentSkeleton, null))));
};

const ExternallyManagedAlert = () => {
    const t = useT('subscriptions');
    const { summary } = useBillingInformation();
    if (summary === null || summary === void 0 ? void 0 : summary.externallyManaged) {
        return React.createElement(Box, { mb: 6 },
            React.createElement(Alert$1, { severity: 'warning' }, t('externallyManaged')));
    }
    return null;
};

const SubscriptionPageContainer = () => {
    const { loadPaymentMethod } = usePaymentMethodActions();
    const { loadInvoices } = useInvoicesActions();
    const { loadPlans } = usePlansActions();
    const { error: paymentProviderError } = usePaymentProvider();
    const { error: billingInformationError } = useBillingInformation();
    const error = react.exports.useMemo(() => paymentProviderError || billingInformationError, [paymentProviderError, billingInformationError]);
    react.exports.useEffect(() => {
        loadInvoices();
        loadPaymentMethod();
        loadPlans();
    }, [loadInvoices, loadPaymentMethod, loadPlans]);
    return (React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' }, error ? (React.createElement(Alert$1, { "data-test-id": 'subscription-page-error', severity: 'error' }, error)) : (React.createElement(React.Fragment, null,
        React.createElement(ExternallyManagedAlert, null),
        React.createElement(SubscriptionSections, null)))));
};

const SubscriptionPageBillingWrapper = () => {
    const { loadBillingInformation } = useBillingInformationActions();
    const { loadVendorPublicConfiguration } = useVendorPublicConfigActions();
    const { fetching: fetchingBillingInformation } = useBillingInformation();
    const { fetching: fetchingVendorPublicConfig } = useVendorPublicConfig();
    react.exports.useEffect(() => {
        loadBillingInformation();
        loadVendorPublicConfiguration();
    }, [loadBillingInformation, loadVendorPublicConfiguration]);
    if (fetchingBillingInformation || fetchingVendorPublicConfig) {
        return React.createElement(SubscriptionPageSkeleton, null);
    }
    return React.createElement(SubscriptionPageContainer, null);
};

const SubscriptionPage$1 = () => {
    const { loadPaymentConfiguration } = usePaymentProviderActions();
    const { profile } = useProfileState();
    const { fetching, loading } = usePaymentProvider();
    react.exports.useEffect(() => {
        if (profile === null || profile === void 0 ? void 0 : profile.tenantId) {
            loadPaymentConfiguration();
        }
    }, [profile, loadPaymentConfiguration]);
    if (fetching || loading) {
        return React.createElement(SubscriptionPageSkeleton, null);
    }
    return React.createElement(SubscriptionPageBillingWrapper, null);
};
var SubscriptionPage$2 = SubscriptionPage$1;

var SubscriptionPage = wrapPage(SubscriptionPage$2, 'subscriptions');

const WebhooksHeader = ({ handleOpenInviteUser }) => {
    const t = useT('webhooks');
    const { onSearch } = useTableSearch();
    const [search, setSearch] = react.exports.useState('');
    const debounceSearch = useDebounce(search);
    useAsyncEffect(() => onSearch(debounceSearch), [debounceSearch]);
    const hasWritePermission = usePermission('fe.connectivity.write.webhook');
    return (React.createElement(Grid, { container: true, spacing: 4 },
        React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
            React.createElement(Box, null,
                React.createElement(Input$1$1, { "data-test-id": "search-box", endAdornment: React.createElement(SearchIcon, null), placeholder: t('searchInputPlaceholder'), onChange: (e) => setSearch(e.target.value) }))),
        React.createElement(Grid, { item: true, xs: true }),
        hasWritePermission && React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": "add-webhook-btn", onClick: handleOpenInviteUser }, t('addWebhook')))));
};

const filterCategories = (categories, channelMap) => 
// eslint-disable-next-line react-hooks/rules-of-hooks
react.exports.useMemo(() => {
    if (categories && channelMap) {
        return categories
            .map((cat) => {
            var _a;
            return (Object.assign(Object.assign({}, cat), { events: (_a = cat.events) === null || _a === void 0 ? void 0 : _a.filter(({ key }) => channelMap.some(({ key: eventKey }) => eventKey === key)) }));
        })
            .filter(({ events }) => !!(events === null || events === void 0 ? void 0 : events.length))
            .map((cat, index) => (Object.assign(Object.assign({}, cat), { index })));
    }
    return undefined;
}, [categories, channelMap]);
const selectedEvents = createSelector((events) => events, (events) => events === null || events === void 0 ? void 0 : events.reduce((acc, curr) => {
    if (/\.\*$/.test(curr)) {
        const val = curr.replace(/\.\*$/, '');
        !acc.names.includes(val) && acc.names.push(val);
    }
    else if (!acc.eventKeys.includes(curr)) {
        acc.eventKeys.push(curr);
    }
    return acc;
}, { names: [], eventKeys: [] }));
const getCategoriesEventsArray = (categories, eventKeys) => {
    return categories.map((category) => {
        if (category.events && eventKeys.includes(category.id)) {
            return category.events.map((e) => e.id);
        }
        return undefined;
    }).flat(1).filter(Boolean);
};

const NameField = () => {
    const t = useT('webhooks_AddEditWebhook');
    const [fieldProps, { error, touched }] = useField('name');
    return (React.createElement(Input$1$1, Object.assign({ "data-test-id": "webhookNameBox", label: t('nameInputLabel') }, fieldProps, { autoFocus: true, error: !!error && touched, errorMessage: error, autoComplete: "given-name", placeholder: t('nameInputPlaceholder') })));
};
const UrlField = () => {
    const t = useT('webhooks_AddEditWebhook');
    const [fieldProps, { error, touched }] = useField('url');
    return React.createElement(Input$1$1, Object.assign({ "data-test-id": "webhookUrlBox", label: t('urlInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, placeholder: t('urlInputPlaceholder') }));
};
const SecretKeyField = () => {
    const t = useT('webhooks_AddEditWebhook');
    const [fieldProps, { error, touched }] = useField('secretKey');
    return React.createElement(Input$1$1, Object.assign({ "data-test-id": "secretKeyBox", label: t('secretKeyInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, placeholder: t('secretKeyInputPlaceholder') }));
};
const EventsField = () => {
    var _a;
    const t = useT('webhooks_AddEditWebhook');
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue, setTouched }] = useField('events');
    const { categories } = useConnectivityState();
    const options = react.exports.useMemo(() => (categories !== null && categories !== void 0 ? categories : []).map(({ name, id, events }, categoryIdx) => {
        const categoryId = id !== null && id !== void 0 ? id : `${name.replace(/\s/g, '_')}_${categoryIdx}`;
        return {
            label: name,
            value: categoryId,
            category: true,
            withCheckbox: true,
            categoryItems: events.map(({ displayName, key, id }, eventIdx) => {
                return { label: displayName, value: id !== null && id !== void 0 ? id : `${categoryId}_${key}_${eventIdx}`, withCheckbox: true };
            }),
        };
    }), [categories]);
    return (React.createElement(SelectTree$1, { "data-test-id": 'webhookEvents', label: t('eventsInputLabel'), name: "events", clearable: true, placeholder: t('eventsInputPlaceholder'), value: (_a = fieldProps === null || fieldProps === void 0 ? void 0 : fieldProps.value) !== null && _a !== void 0 ? _a : [], container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options, onChange: (value) => {
            setValue(value, true);
            setTouched(true);
        }, error: !!error && touched, errorMessage: error }));
};
const AddWebhookForm = ({ onClose }) => {
    const t = useT('webhooks_AddEditWebhook');
    const { cleanError, postDataAction } = useConnectivityActions();
    const { categories } = useConnectivityState();
    const initialValues = react.exports.useMemo(() => ({
        name: '',
        url: '',
        secretKey: '',
        events: [],
    }), []);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        name: validateNotEmpty(t('nameIsRequired')),
        url: validateUrl(t('urlIsRequired'), t('urlIsInvalid')),
        secretKey: validateMinLengthOptional(8, t('secretKeyLengthAtLeast8')),
        events: create().min(1, t('eventsIsRequired')),
    }), [t]);
    const formikProps = {
        onSubmit: ({ name, url, secretKey, events }) => new Promise((resolve, reject) => {
            cleanError();
            const callback = callbackToPromise(resolve, reject, onClose);
            const eventsToRemove = getCategoriesEventsArray(categories, events);
            const eventsToSend = events.filter(e => !eventsToRemove.includes(e));
            postDataAction({
                platform: 'webhook',
                data: { displayName: name, url, secret: !!secretKey ? secretKey : null, eventKeys: eventsToSend, description: '', isActive: false },
                callback,
            });
        }),
        initialValues,
        validationSchema,
    };
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(Grid, { container: true, spacing: 4, mb: 4 },
                    React.createElement(Grid, { item: true, xs: 12, sm: 12 },
                        React.createElement(NameField, null)),
                    React.createElement(Grid, { item: true, xs: 12, sm: 12 },
                        React.createElement(UrlField, null))),
                React.createElement(SecretKeyField, null),
                React.createElement(EventsField, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancel-btn", color: "inherit", variant: "text", type: "reset", onClick: onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": "form-add-webhook-btn", disabled: !canSubmit, loading: isSubmitting, color: "primary", type: "submit" }, t('create')))));
    }));
};
const AddWebhookDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('webhooks_AddEditWebhook');
    return (React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('addTitle') }),
        React.createElement(AddWebhookForm, { onClose: props.onClose })));
};

const EditWebhookForm = ({ onClose, webhook }) => {
    const t = useT('webhooks_AddEditWebhook');
    const { cleanError, postDataAction } = useConnectivityActions();
    const { categories } = useConnectivityState();
    const initialValues = react.exports.useMemo(() => {
        var _a, _b, _c, _d;
        const eventKeys = (_a = webhook === null || webhook === void 0 ? void 0 : webhook.eventKeys) !== null && _a !== void 0 ? _a : [];
        const eventsToAdd = getCategoriesEventsArray(categories, eventKeys);
        const initEventsValue = [...eventKeys, ...eventsToAdd];
        return {
            name: (_b = webhook === null || webhook === void 0 ? void 0 : webhook.displayName) !== null && _b !== void 0 ? _b : '',
            url: (_c = webhook === null || webhook === void 0 ? void 0 : webhook.url) !== null && _c !== void 0 ? _c : '',
            secretKey: (_d = webhook === null || webhook === void 0 ? void 0 : webhook.secret) !== null && _d !== void 0 ? _d : '',
            events: initEventsValue !== null && initEventsValue !== void 0 ? initEventsValue : [],
        };
    }, [categories, webhook]);
    const validationSchema = react.exports.useMemo(() => validateSchema({
        name: validateNotEmpty(t('nameIsRequired')),
        url: validateUrl(t('urlIsRequired'), t('urlIsInvalid')),
        secretKey: validateMinLengthOptional(8, t('secretKeyLengthAtLeast8')),
        events: create().min(1, t('eventsIsRequired')),
    }), [t]);
    const formikProps = {
        onSubmit: ({ name, url, secretKey = null, events }) => new Promise((resolve, reject) => {
            cleanError();
            const callback = callbackToPromise(resolve, reject, onClose);
            const eventsToRemove = getCategoriesEventsArray(categories, events);
            const eventsToSend = events.filter(e => !eventsToRemove.includes(e));
            postDataAction({
                platform: 'webhook',
                data: {
                    _id: webhook._id,
                    displayName: name,
                    url,
                    secret: !!secretKey ? secretKey : null,
                    eventKeys: eventsToSend,
                    description: webhook.description,
                    isActive: webhook.isActive,
                },
                callback,
            });
        }),
        initialValues,
        validationSchema,
    };
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(Grid, { container: true, spacing: 4, mb: 4 },
                    React.createElement(Grid, { item: true, xs: 12, sm: 12 },
                        React.createElement(NameField, null)),
                    React.createElement(Grid, { item: true, xs: 12, sm: 12 },
                        React.createElement(UrlField, null))),
                React.createElement(SecretKeyField, null),
                React.createElement(EventsField, null),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": "cancel-btn", color: "inherit", variant: "text", type: "reset", onClick: onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": 'edit-btn', disabled: !canSubmit, loading: isSubmitting, color: "primary", type: "submit" }, t('edit')))));
    }));
};
const EditWebhookDialog = (props) => {
    const { injector } = useShadowDom();
    const t = useT('webhooks_AddEditWebhook');
    return (React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { title: t('editTitle') }),
        React.createElement(EditWebhookForm, Object.assign({}, props))));
};

const DeleteWebhookDialog = ({ open, webhook, onClose }) => {
    const t = useT('webhooks_DeleteWebhook');
    const [loading, setLoading] = react.exports.useState(false);
    const [error, setError] = react.exports.useState(null);
    const { deleteWebhookConfigAction } = useConnectivityActions();
    const callback = react.exports.useCallback((success, error) => {
        if (error) {
            setLoading(false);
            setError(error);
        }
        else {
            setLoading(false);
            onClose();
        }
    }, [setLoading, setError, onClose]);
    const handleDeleteWebhook = react.exports.useCallback(() => {
        setLoading(true);
        setError(null);
        deleteWebhookConfigAction({ webhookId: webhook === null || webhook === void 0 ? void 0 : webhook._id, callback });
    }, [callback, deleteWebhookConfigAction, webhook === null || webhook === void 0 ? void 0 : webhook._id]);
    return (React.createElement(DeleteDialog, { title: t('title'), cancelButtonText: t('cancel'), deleteButtonText: t('delete'), description: React.createElement(React.Fragment, null,
            t('areYouSureDeleteWebhook1'),
            " ",
            React.createElement("strong", null, webhook === null || webhook === void 0 ? void 0 : webhook.displayName),
            " ",
            t('areYouSureDeleteWebhook2')), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleDeleteWebhook }));
};

const useWebhooksTableRowActions = ({ container, handleOpenDeleteWebhook, handleOpenEditWebhook, hasWritePermission, hasDeletePermission, }) => {
    const t = useT('webhooks');
    return react.exports.useMemo(() => (row) => {
        const items = [];
        const handleEditWebhook = () => {
            handleOpenEditWebhook(row);
        };
        const handleDeleteWebhook = () => {
            handleOpenDeleteWebhook(row);
        };
        //TODO change data test id from editBtn to action-edit-btn
        if (hasWritePermission) {
            items.push({
                text: t('editWebhook'),
                onClick: handleEditWebhook,
                icon: React.createElement(EditIcon, { "data-test-id": 'action-edit-btn' }),
            });
        }
        //TODO change data test id from deleteBtn to delete-btn
        if (hasDeletePermission) {
            items.push({
                negative: true,
                text: t('deleteWebhook'),
                onClick: handleDeleteWebhook,
                icon: React.createElement(DeleteIcon, { "data-test-id": 'action-delete-btn' }),
            });
        }
        return { items, container };
    }, [container, handleOpenDeleteWebhook, handleOpenEditWebhook, hasDeletePermission, hasWritePermission, t]);
};
const webhooksColumns = ({ onChangeStatus, t }) => [
    {
        accessor: ({ url, displayName }) => ({ title: displayName, description: url }),
        Header: t('nameHeader'),
        Cell: TableTextCell,
    },
    {
        accessor: (webhook) => {
            var _a;
            return ({
                checked: (_a = webhook === null || webhook === void 0 ? void 0 : webhook.isActive) !== null && _a !== void 0 ? _a : false,
                onChange: () => webhook && onChangeStatus(webhook),
            });
        },
        Header: t('statusHeader'),
        Cell: TableSwitchCellLeft,
        maxWidth: 100,
        minWidth: 100,
    },
].filter(notNull);

const WebhooksTable = () => {
    var _a;
    const t = useT('webhooks');
    const { searchQuery } = useTableSearch();
    const { injector } = useShadowDom();
    const container = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl;
    const [editWebhookDialog, handleCloseEditWebhook, handleOpenEditWebhook, editWebhookData] = useDialogState();
    const [deleteWebhookDialog, handleCloseDeleteWebhook, handleOpenDeleteWebhook, deleteWebhookData] = useDialogState();
    const { postDataAction } = useConnectivityActions();
    const { webhook: webhookState, categories, channelMap, isLoading, totalPages } = useConnectivityState();
    const cleanCategories = filterCategories(categories, channelMap && channelMap.webhook);
    const hasWritePermission = usePermission('fe.connectivity.write.webhook');
    const hasDeletePermission = usePermission('fe.connectivity.delete.webhook');
    const getRowActions = useWebhooksTableRowActions({
        container,
        handleOpenEditWebhook,
        handleOpenDeleteWebhook,
        hasWritePermission,
        hasDeletePermission,
    });
    const preparedWebhookState = (_a = webhookState === null || webhookState === void 0 ? void 0 : webhookState.data) !== null && _a !== void 0 ? _a : webhookState;
    const webhooks = react.exports.useMemo(() => preparedWebhookState === null || preparedWebhookState === void 0 ? void 0 : preparedWebhookState.map((elm) => {
        var _a;
        const eventObject = selectedEvents(elm.eventKeys);
        const data = cleanCategories === null || cleanCategories === void 0 ? void 0 : cleanCategories.reduce((acc, cur) => {
            var _a, _b, _c;
            if (eventObject === null || eventObject === void 0 ? void 0 : eventObject.names.includes(cur.name)) {
                return [...acc, { name: cur.name, count: (_b = (_a = cur.events) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0 }];
            }
            else {
                const evs = (_c = cur.events) === null || _c === void 0 ? void 0 : _c.filter(({ key }) => eventObject === null || eventObject === void 0 ? void 0 : eventObject.eventKeys.includes(key));
                if (evs === null || evs === void 0 ? void 0 : evs.length) {
                    return [...acc, { name: cur.name, count: evs.length }];
                }
            }
            return acc;
        }, []);
        return Object.assign(Object.assign({}, elm), { groupEvents: data !== null && data !== void 0 ? data : [], totalEvents: (_a = data === null || data === void 0 ? void 0 : data.reduce((acc, cur) => acc + (cur.count || 0), 0)) !== null && _a !== void 0 ? _a : 0 });
    }), [preparedWebhookState, cleanCategories]);
    const filteredWebhooks = react.exports.useMemo(() => {
        const query = searchQuery.toLocaleLowerCase();
        return webhooks
            ? webhooks.filter((w) => {
                const webhookUrl = w.url.toLocaleLowerCase();
                const webhookName = w.displayName.toLocaleLowerCase();
                return webhookName.includes(query) || webhookUrl.includes(query);
            })
            : [];
    }, [searchQuery, webhooks]);
    const tablePlaceholderProps = react.exports.useMemo(() => {
        const webhooksLength = webhooks ? webhooks.length : 0;
        if (isLoading) {
            return null;
        }
        if (!webhooksLength) {
            return {
                show: true,
                icon: React.createElement(WebhooksIcon, null),
                title: t('noWebhooksYet'),
                description: t('noWebhooksYetDescription'),
                testId: 'webhooks-table-empty-placeholder'
            };
        }
        if (filteredWebhooks.length === 0) {
            return {
                show: true,
                icon: React.createElement(SearchBigIcon, null),
                title: t('noResultFound'),
                description: t('noResultFoundDescription'),
                testId: 'webhooks-table-no-results-placeholder'
            };
        }
        return null;
    }, [isLoading, webhooks, filteredWebhooks.length, t]);
    const onChangeStatus = react.exports.useCallback((data) => {
        postDataAction({ platform: 'webhook', data: Object.assign(Object.assign({}, data), { isActive: !data.isActive }) });
    }, [postDataAction]);
    const columns = react.exports.useMemo(() => webhooksColumns({ onChangeStatus, t }), [onChangeStatus, t]);
    return (React.createElement(React.Fragment, null,
        React.createElement(Table, { forwardedKey: "webhooks-table", columns: columns, loading: isLoading, totalPages: totalPages, data: filteredWebhooks !== null && filteredWebhooks !== void 0 ? filteredWebhooks : [], getRowActions: getRowActions }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))),
        React.createElement(EditWebhookDialog, { open: editWebhookDialog, onClose: handleCloseEditWebhook, webhook: editWebhookData }),
        React.createElement(DeleteWebhookDialog, { open: deleteWebhookDialog, onClose: handleCloseDeleteWebhook, webhook: deleteWebhookData })));
};

const WebhooksPage$1 = () => {
    const [searchQuery, onSearch] = react.exports.useState("");
    const [searching, setSearching] = react.exports.useState(false);
    const { loadDataAction } = useConnectivityActions();
    const [addWebhookDialog, handleCloseAddWebhook, handleOpenAddWebhook] = useDialogState();
    react.exports.useEffect(() => {
        loadDataAction();
    }, [loadDataAction]);
    return (React.createElement(PageWrapper, { flex: 1, display: "flex", flexDirection: "column" },
        React.createElement(TableSearchContext.Provider, { value: { searching, searchQuery, onSearch, setSearching } },
            React.createElement(WebhooksHeader, { handleOpenInviteUser: handleOpenAddWebhook }),
            React.createElement(Box, { mt: 6, flex: 1, display: "flex", flexDirection: "column" },
                React.createElement(WebhooksTable, null)),
            React.createElement(AddWebhookDialog, { open: addWebhookDialog, onClose: handleCloseAddWebhook }))));
};
var WebhooksPage$2 = WebhooksPage$1;

var WebhooksPage = wrapPage(WebhooksPage$2, 'webhooks');

const LoginPage = () => {
    const { closeAdminBox } = react.exports.useContext(AppDialogContext);
    const { basename = '' } = useShadowDom();
    const { loginUrl } = useAuthRoutes();
    const onRedirectTo = useOnRedirectTo();
    react.exports.useEffect(() => {
        closeAdminBox();
        const calculatedBasename = basename.endsWith('/') ? basename.substring(0, basename.length - 1) : '';
        window.location.href = calculatedBasename + loginUrl;
    }, [onRedirectTo, closeAdminBox]);
    return null;
};
var LoginPage$1 = LoginPage;

const AllUsersHeader = ({ handleOpenInviteUser }) => {
    const t = useT('allUsers');
    const { onSearch } = useTableSearch();
    const [search, setSearch] = react.exports.useState('');
    const debounceSearch = useDebounce(search);
    const canInviteUser = usePermission('fe.secure.write.users');
    useAsyncEffect(() => onSearch(debounceSearch), [debounceSearch]);
    return (React.createElement(Grid, { container: true, spacing: 4 },
        React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4 },
            React.createElement(Box, null,
                React.createElement(Input$1$1, { "data-test-id": 'searchBox', endAdornment: React.createElement(SearchIcon, null), onChange: (e) => setSearch(e.target.value), placeholder: t('searchInputPlaceholder') }))),
        React.createElement(Grid, { item: true, xs: true }),
        canInviteUser && (React.createElement(Grid, { item: true },
            React.createElement(Button$1, { "data-test-id": 'invite-user-btn', onClick: handleOpenInviteUser }, t('inviteUserButton'))))));
};

const useUsersTableRowActions = ({ container, resendActivationLink, resendInvitationLink, handleOpenDeleteUser, handleOpenLockUser, handleOpenInviteUser, revokeUserSessions, currentTenantId, subTenants, }) => {
    const t = useT('allUsers');
    const user = useAuthUserOrNull();
    const canEditRoles = usePermission('fe.secure.write.users');
    const canDeleteUser = usePermission('fe.secure.delete.users');
    const canRevokeUserSessions = usePermission('fe.secure.delete.sessions');
    //TODO: add virified type to ITeamUser
    return react.exports.useMemo(() => (row) => {
        const items = [];
        const handleManageUser = () => {
            handleOpenInviteUser(row);
        };
        const handleSendActivationLink = () => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            resendActivationLink({ userId: row.id, callback });
        });
        const handleSendInvitationLink = () => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            const invitationData = __rest(row, ["id"]);
            resendInvitationLink(Object.assign(Object.assign({}, invitationData), { callback }));
        });
        const handleDeleteUser = () => {
            handleOpenDeleteUser(row);
        };
        const handleRevokeUserSessions = () => new Promise((resolve, reject) => {
            const callback = callbackToPromise(resolve, reject);
            revokeUserSessions({ userId: row.id, callback });
        });
        const isMe = row.id === (user === null || user === void 0 ? void 0 : user.id);
        if (!row.verified) {
            items.push({
                icon: React.createElement(ResendIcon, { "data-test-id": 'resendBtn' }),
                onClick: handleSendActivationLink,
                text: t('resendActivationAction'),
            });
        }
        else {
            items.push({
                icon: React.createElement(ResendIcon, { "data-test-id": 'resendInvitationBtn' }),
                onClick: handleSendInvitationLink,
                text: t('resendInvitationAction'),
            });
        }
        if (!isMe) {
            if (canEditRoles) {
                items.push({
                    icon: React.createElement(TuneRounded, { "data-test-id": 'manageBtn' }),
                    onClick: handleManageUser,
                    text: t('manageAction'),
                });
            }
            if (canDeleteUser) {
                items.push({
                    icon: React.createElement(DeleteIcon, { "data-test-id": 'deleteBtn' }),
                    onClick: handleDeleteUser,
                    text: t('deleteUserAction'),
                });
            }
            if (canRevokeUserSessions && row.activatedForTenant) {
                items.push({
                    icon: React.createElement(CloseIcon, { "data-test-id": "revokeBtn" }),
                    onClick: handleRevokeUserSessions,
                    text: t('logOutUserSessionsActions'),
                });
            }
        }
        return { items, container };
    }, [
        t,
        user,
        container,
        canEditRoles,
        canDeleteUser,
        canRevokeUserSessions,
        resendActivationLink,
        resendInvitationLink,
        handleOpenDeleteUser,
        handleOpenLockUser,
        handleOpenInviteUser,
        subTenants,
        currentTenantId,
    ]);
};
const allUsersTableColumnsOrganization = ({ t, user, subTenants, forcePermissions, container, currentTenantName, currentTenantId, }) => [
    {
        Header: () => React.createElement(Box, { width: '2rem' }),
        accessor: ({ name, profileImageUrl, profilePictureUrl }) => ({
            name,
            picture: profilePictureUrl !== null && profilePictureUrl !== void 0 ? profilePictureUrl : profileImageUrl,
        }),
        width: '2rem',
        id: 'id',
        Cell: TableAvatarCell,
    },
    Object.assign(Object.assign({ Header: t('userHeader'), accessor: ({ id, name, email }) => ({
            title: `${name} ${id === user.id ? `(${t('meTooltip')})` : ''}`,
            description: email,
        }) }, (forcePermissions ? { width: 260, maxWidth: 260 } : { minWidth: 260 })), { Cell: TableTextCell }),
    {
        Header: t('accountsHeader'),
        accessor: ({ tenants }) => {
            var _a;
            const items = (_a = tenants === null || tenants === void 0 ? void 0 : tenants.map((tenant) => {
                var _a;
                let text = (_a = subTenants.find((subTenant) => subTenant.tenantId === tenant.tenantId)) === null || _a === void 0 ? void 0 : _a.tenantName;
                if (!text && tenant.tenantId === currentTenantId) {
                    text = currentTenantName;
                }
                return { text };
            })) !== null && _a !== void 0 ? _a : [];
            return { items: items.filter((item) => item.text), max: 2, container };
        },
        minWidth: 300,
        Cell: TableChipsCell,
    },
    {
        Header: t('joinedHeader'),
        accessor: ({ createdAt, tenants }) => ({
            date: createdAt,
            tenants,
        }),
        width: 160,
        maxWidth: 160,
        Cell: (props) => {
            const hasOneActivatedTenant = !!(props.value.tenants || []).find((tenant) => tenant.activated);
            return !hasOneActivatedTenant ? (React.createElement(Chip, { color: 'secondary', label: t('pendingActivationStatus') })) : (React.createElement(TableDateCell, Object.assign({}, props)));
        },
    },
    {
        Header: t('lastSeenHeader'),
        accessor: ({ tenants, tenantId }) => {
            var _a;
            return ({
                date: (_a = tenants === null || tenants === void 0 ? void 0 : tenants.find((tenant) => tenant.tenantId === tenantId)) === null || _a === void 0 ? void 0 : _a.lastLogin,
            });
        },
        width: 160,
        maxWidth: 160,
        Cell: TableDateCell,
    },
].filter(notNull);

const DeleteUserDialog = ({ onClose, open, user }) => {
    const t = useT('allUsers_DeleteUser');
    const [loading, setLoading] = react.exports.useState(false);
    const [error, setError] = react.exports.useState(null);
    const { deleteUserFromSubTenants } = useAuthTeamActions();
    const callback = react.exports.useCallback((success, error) => {
        if (error) {
            setError(error);
        }
        else {
            onClose();
        }
        setLoading(false);
    }, [setLoading, setError, onClose]);
    const handleDeleteUser = react.exports.useCallback(() => {
        setLoading(true);
        setError(null);
        deleteUserFromSubTenants({
            callback,
            userId: user.id,
            subTenants: user.tenants.map((tenant) => ({ tenantId: tenant.tenantId })),
        });
    }, [user === null || user === void 0 ? void 0 : user.id, user === null || user === void 0 ? void 0 : user.tenants, setLoading, setError, deleteUserFromSubTenants, callback]);
    return (React.createElement(DeleteDialog, { dataTestId: 'deleteUserBtn', title: t('title', { name: user === null || user === void 0 ? void 0 : user.name }), cancelButtonText: t('cancel'), deleteButtonText: t('delete'), description: React.createElement(React.Fragment, null,
            t('areYouSureDeleteUser1', { name: user === null || user === void 0 ? void 0 : user.name }),
            " ",
            t('areYouSureDeleteUser2')), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleDeleteUser }));
};

const LockUserDialog = ({ onClose, open, user }) => {
    const t = useT('allUsers_LockUser');
    const [loading, setLoading] = react.exports.useState(false);
    const [error, setError] = react.exports.useState(null);
    const { lockUser } = useAuthTeamActions();
    const callback = react.exports.useCallback((success, error) => {
        if (error) {
            setError(error);
        }
        else {
            onClose();
        }
        setLoading(false);
    }, [setLoading, setError, onClose]);
    const handleLockUser = react.exports.useCallback(() => {
        setLoading(true);
        setError(null);
        lockUser({ userId: user === null || user === void 0 ? void 0 : user.id, callback });
    }, [user === null || user === void 0 ? void 0 : user.id, callback, setLoading, setError, lockUser]);
    return (React.createElement(DeleteDialog, { dataTestId: 'lockUserBtn', title: t('title', { name: user === null || user === void 0 ? void 0 : user.name }), cancelButtonText: t('cancel'), deleteButtonText: t('lock'), description: React.createElement(React.Fragment, null, t('areYouSureLockUser1', { name: user === null || user === void 0 ? void 0 : user.name })), open: open, error: error, onClose: onClose, loading: !!loading, onDelete: handleLockUser }));
};

const AllUsersTable = ({ handleOpenInviteUser }) => {
    const t = useT('allUsers');
    const { injector } = useShadowDom();
    const container = injector === null || injector === void 0 ? void 0 : injector.adminPortalEl;
    const user = useAuthUser();
    const { revokeUserSessions } = useSessionsActions();
    const { loaders, allUsers, roles, permissions, totalPages, pageOffset, filter } = useAuthTeamState();
    const { resendActivationLink, loadAllSubTenantsUsers, resendInvitationLinkToAllSubTenants } = useAuthTeamActions();
    const [deleteUserDialog, handleCloseDeleteUser, handleOpenDeleteUser, deleteUserData] = useDialogState();
    const [lockUserDialog, handleCloseLockUser, handleOpenLockUser, lockUserData] = useDialogState();
    const { policy, loading: loadingPolicy } = usePublicPolicySettings();
    const rolesUse = useRolesMap(roles);
    const rolesMap = react.exports.useMemo(() => (!loadingPolicy && (policy === null || policy === void 0 ? void 0 : policy.forcePermissions) ? rolesUse : undefined), [
        policy,
        rolesUse,
        loadingPolicy,
    ]);
    const { tenants, subTenants } = useTenantsState();
    const tenantName = react.exports.useMemo(() => {
        var _a, _b;
        return (_b = (_a = tenants.find(({ tenantId }) => tenantId === user.tenantId)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';
    }, [tenants, user.tenantId]);
    const isPermissionsAndRolesEnabled = react.exports.useMemo(() => !loadingPolicy && (policy === null || policy === void 0 ? void 0 : policy.forcePermissions), [
        loadingPolicy,
        policy,
    ]);
    const columns = react.exports.useMemo(() => {
        return allUsersTableColumnsOrganization({
            t,
            user,
            subTenants,
            forcePermissions: isPermissionsAndRolesEnabled,
            container,
            currentTenantName: tenantName,
            currentTenantId: user.tenantId,
        });
    }, [t, user, subTenants, isPermissionsAndRolesEnabled, container, rolesMap, tenantName, user.tenantId]);
    const { searching } = useTableSearch();
    const getRowActions = useUsersTableRowActions({
        roles,
        subTenants,
        permissions,
        container,
        resendActivationLink,
        resendInvitationLink: resendInvitationLinkToAllSubTenants,
        handleOpenDeleteUser,
        handleOpenLockUser,
        revokeUserSessions,
        handleOpenInviteUser,
        currentTenantId: user.tenantId,
    });
    const onPageChange = react.exports.useCallback((event, page) => {
        loadAllSubTenantsUsers({ _offset: page - 1 });
    }, [loadAllSubTenantsUsers]);
    const onSortChange = react.exports.useCallback((sortBy = []) => {
        var _a, _b;
        loadAllSubTenantsUsers({
            _offset: 0,
            _sortBy: ((_a = sortBy[0]) === null || _a === void 0 ? void 0 : _a.id) || 'name',
            _order: ((_b = sortBy[0]) === null || _b === void 0 ? void 0 : _b.desc) ? 'DESC' : 'ASC',
        });
    }, [loadAllSubTenantsUsers]);
    const loading = !!loaders.USERS;
    const tablePlaceholderProps = react.exports.useMemo(() => {
        if (loading || searching) {
            return null;
        }
        else if (filter.length === 0 && allUsers.length === 0) {
            return {
                show: true,
                icon: React.createElement(GroupUsersIcon, null),
                title: t('noUsersYet'),
                description: t('noUsersYetDescription'),
            };
        }
        else if (filter.length > 0 && allUsers.length === 0) {
            return {
                show: true,
                icon: React.createElement(SearchBigIcon, null),
                title: t('noResultFound'),
                description: t('noResultFoundDescription'),
            };
        }
        return null;
    }, [t, loading, searching, filter.length, allUsers.length]);
    return (React.createElement(React.Fragment, null,
        React.createElement(Table, { forwardedKey: 'all-users-table', columns: columns, data: allUsers, getRowActions: getRowActions, loading: loading, searching: searching, onSortChange: onSortChange, loadingText: searching ? t('searchingPlaceholder') : undefined, totalPages: totalPages, pageOffset: pageOffset, onPageChange: onPageChange }, tablePlaceholderProps && React.createElement(TablePlaceholder, Object.assign({}, tablePlaceholderProps))),
        React.createElement(DeleteUserDialog, { open: deleteUserDialog, onClose: handleCloseDeleteUser, user: deleteUserData }),
        React.createElement(LockUserDialog, { open: lockUserDialog, onClose: handleCloseLockUser, user: lockUserData })));
};

const TreeHeader = styled(Grid) `
  height: 56px;
  background: #f5f6f8;
  border: 1px solid #e5eaf3;
  border-radius: 3px 3px 0 0;
  flex-direction: row;
  align-items: center;
  display: flex;
  border-bottom-width: 0;
`;
const FirstNameField = () => {
    const t = useT('allUsers_InviteUser');
    const [fieldProps, { error, touched }] = useField('fullName');
    return (React.createElement(Input$1$1, Object.assign({ label: t('fullNameInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": 'nameBox', autoComplete: 'given-name' })));
};
const EmailField = ({ disabled }) => {
    const t = useT('allUsers_InviteUser');
    const [fieldProps, { error, touched }] = useField('email');
    return (React.createElement(Input$1$1, Object.assign({ label: t('emailInputLabel') }, fieldProps, { error: !!error && touched, errorMessage: error, "data-test-id": 'emailBox', autoComplete: 'email', disabled: disabled })));
};
const RolesField = ({ roles, id }) => {
    const t = useT('allUsers_InviteUser');
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue, setTouched }] = useField(`roleIds-${id}`);
    const options = react.exports.useMemo(() => (roles !== null && roles !== void 0 ? roles : []).map((role) => ({ label: role.name, value: role.id, withCheckbox: true })), [roles]);
    return (React.createElement(Select$1$1, { name: `roleIds-${id}`, placeholder: t('rolesInputPlaceholder'), value: fieldProps.value, multi: true, oneLineMulti: true, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options, onChange: (value) => {
            setValue(value, true);
            setTouched(true);
        }, error: !!error && touched, errorMessage: error, onClick: (e) => e.stopPropagation(), sx: { margin: '0 0 0 auto', width: 210 } }));
};
const AssignRolesToAll = ({ roles, selectedTenantIds }) => {
    const t = useT('allUsers_InviteUser');
    const { injector } = useShadowDom();
    const [fieldProps, { error, touched }, { setValue, setTouched }] = useField('rolesForAllTenants');
    const options = react.exports.useMemo(() => (roles !== null && roles !== void 0 ? roles : []).map((role) => ({ label: role.name, value: role.id, withCheckbox: true })), [roles]);
    const formikContext = useFormikContext();
    const onChange = (value) => {
        setValue(value, true);
        setTouched(true);
        selectedTenantIds.forEach((id) => {
            formikContext.setFieldValue(`roleIds-${id}`, value);
        });
    };
    return (React.createElement(Select$1$1, { name: 'rolesForAllTenants', placeholder: t('rolesInputPlaceholder'), value: fieldProps.value, multi: true, oneLineMulti: true, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, options: options, onChange: onChange, error: !!error && touched, errorMessage: error, onClick: (e) => e.stopPropagation(), sx: { marginBottom: 0 }, customContent: React.createElement(Button$1, { "data-test-id": 'assignRolesToAllBtn', size: 'small', color: 'inherit', onClick: (e) => e.stopPropagation(), type: 'button' },
            React.createElement(ManageAccounts, null),
            " ",
            t('assignRole')), minPopperWidth: 240 }));
};
const InviteUserForm = (_a) => {
    var props = __rest(_a, []);
    const t = useT('allUsers_InviteUser');
    const { addUserToSubTenants, setUserRolesForSubTenants, deleteUserFromSubTenants } = useAuthTeamActions();
    const { tenantTree } = useTenantsState();
    const userData = react.exports.useMemo(() => props.teamUser, [props.teamUser]);
    const treeData = react.exports.useMemo(() => {
        const mapTree = (node, level = 1) => ({
            id: node.tenantId,
            name: node.tenantName || '',
            level,
            children: node.children.map((child) => mapTree(child, level + 1)),
        });
        return tenantTree && mapTree(tenantTree);
    }, [tenantTree]);
    const allTenantIds = react.exports.useMemo(() => {
        const getTenantsIds = (node) => [
            node.tenantId,
            ...node.children.map((child) => getTenantsIds(child)).flat(),
        ];
        return tenantTree ? getTenantsIds(tenantTree) : [];
    }, [tenantTree]);
    const initialValues = react.exports.useMemo(() => {
        const mapTreeInitialValues = (node, acc = {}) => {
            var _a;
            if (!node) {
                return {};
            }
            if (userData && userData.tenants) {
                acc[`roleIds-${node.id}`] =
                    ((_a = userData.tenants.find((tenant) => tenant.tenantId === node.id)) === null || _a === void 0 ? void 0 : _a.roles.map((role) => role.id)) || [];
            }
            else {
                acc[`roleIds-${node.id}`] = [];
            }
            (node.children || []).forEach((child) => mapTreeInitialValues(child, acc));
            return acc;
        };
        const tenantsRoles = mapTreeInitialValues(treeData);
        return Object.assign(Object.assign({}, tenantsRoles), { fullName: (userData === null || userData === void 0 ? void 0 : userData.name) || '', email: (userData === null || userData === void 0 ? void 0 : userData.email) || '', rolesForAllTenants: [] });
    }, [treeData, userData]);
    const [selectedTenants, setSelectedTenants] = react.exports.useState(((userData === null || userData === void 0 ? void 0 : userData.tenants) || []).map((tenant) => tenant.tenantId) || []);
    const accountsCount = react.exports.useMemo(() => t('accountsCount_one', { count: selectedTenants.length }), [
        selectedTenants.length,
        t,
    ]);
    const validationSchema = react.exports.useMemo(() => validateSchema(Object.assign({ fullName: validateNotEmpty(t('fullNameIsRequired')), email: validateEmail(t('emailMustBeValid'), t('emailIsRequired')) }, selectedTenants.reduce((previousValue, currentValue) => {
        return Object.assign(Object.assign({}, previousValue), { [`roleIds-${currentValue}`]: create().min(1, t('rolesIsRequired')) });
    }, {}))), [t, selectedTenants]);
    const handleSelectedChange = react.exports.useCallback((ids) => setSelectedTenants(ids), [setSelectedTenants]);
    const cachedRoles = react.exports.useMemo(() => props.roles, [props.roles]);
    const itemProps = react.exports.useMemo(() => ({ roles: cachedRoles }), [cachedRoles]);
    const checked = react.exports.useMemo(() => selectedTenants.length === (allTenantIds === null || allTenantIds === void 0 ? void 0 : allTenantIds.length), [selectedTenants, allTenantIds]);
    const indeterminate = react.exports.useMemo(() => !checked && selectedTenants.length > 0, [selectedTenants, checked]);
    const handleSelectAll = react.exports.useCallback(() => setSelectedTenants(!checked ? allTenantIds : []), [allTenantIds, checked]);
    const formikProps = react.exports.useMemo(() => ({
        onSubmit: (_a) => {
            var { fullName, email } = _a, rest = __rest(_a, ["fullName", "email"]);
            return new Promise((resolve, reject) => {
                const callback = callbackToPromise(resolve, reject, props.onClose);
                if (userData && userData.tenantIds) {
                    const addedTenants = selectedTenants.filter((x) => !userData.tenantIds.includes(x));
                    const removedTenants = userData.tenantIds.filter((x) => !selectedTenants.includes(x));
                    if (addedTenants.length) {
                        addUserToSubTenants({
                            user: { name: userData.name, email: userData.email },
                            subTenants: addedTenants.map((id) => ({
                                tenantId: id,
                                roleIds: [...new Set(rest[`roleIds-${id}`])],
                            })),
                        });
                    }
                    if (removedTenants.length) {
                        deleteUserFromSubTenants({
                            userId: userData.id,
                            subTenants: removedTenants.map((id) => ({ tenantId: id })),
                        });
                    }
                    setUserRolesForSubTenants({
                        callback,
                        userId: userData.id,
                        subTenantsRoles: selectedTenants
                            .filter((id) => !removedTenants.includes(id))
                            .map((id) => ({
                            tenantId: id,
                            roleIds: [...new Set(rest[`roleIds-${id}`])],
                        })),
                    });
                }
                else {
                    addUserToSubTenants({
                        callback,
                        user: { name: fullName, email },
                        subTenants: selectedTenants.map((id) => ({
                            tenantId: id,
                            roleIds: [...new Set(rest[`roleIds-${id}`])],
                        })),
                    });
                }
            });
        },
        initialValues,
        validationSchema,
    }), [
        addUserToSubTenants,
        deleteUserFromSubTenants,
        initialValues,
        props.onClose,
        selectedTenants,
        setUserRolesForSubTenants,
        userData,
        validationSchema,
    ]);
    return (React.createElement(FormDialogBody, Object.assign({}, formikProps), ({ isSubmitting, canSubmit, formError }) => {
        return (React.createElement(React.Fragment, null,
            React.createElement(Dialog$1.Body, null,
                React.createElement(Grid, { container: true, spacing: 4 },
                    React.createElement(Grid, { item: true, xs: 12, sm: 6 },
                        React.createElement(FirstNameField, null)),
                    React.createElement(Grid, { item: true, xs: 12, sm: 6 },
                        React.createElement(EmailField, { disabled: !!(userData === null || userData === void 0 ? void 0 : userData.email) }))),
                React.createElement(Grid, { container: true, spacing: 4, style: { marginBottom: '8px' }, alignItems: 'center' },
                    React.createElement(Grid, { item: true, xs: 6 },
                        React.createElement(Typography$1, { component: 'div', display: 'inline-flex', marginRight: '1em' }, t('selected')),
                        React.createElement(Chip$1, { label: accountsCount })),
                    React.createElement(Grid, { item: true, xs: 6, sx: { display: 'flex', justifyContent: 'end' } },
                        React.createElement(AssignRolesToAll, { roles: cachedRoles, selectedTenantIds: selectedTenants }))),
                treeData && (React.createElement(React.Fragment, null,
                    React.createElement(TreeHeader, null,
                        React.createElement(Grid, { item: true, xs: 6 },
                            React.createElement(Typography$1, { component: 'div', display: 'flex', marginLeft: '3.5em', fontWeight: 'bold', alignItems: 'center' },
                                React.createElement(Checkbox$1, { edge: 'start', checked: checked, onChange: handleSelectAll, tabIndex: -1, indeterminate: indeterminate, disableRipple: true, onClick: (e) => e.stopPropagation(), size: 'small', sx: { padding: '3px 8px 3px 1em' } }),
                                t('accounts'))),
                        React.createElement(Grid, { item: true, xs: 6 },
                            React.createElement(Typography$1, { component: 'div', display: 'inline-flex', marginLeft: '3.5em', fontWeight: 'bold' }, t('role')))),
                    React.createElement(Tree, { data: treeData, selected: selectedTenants, handleSelectedChange: handleSelectedChange, ItemContent: RolesField, itemProps: itemProps }))),
                React.createElement(FormErrorDialogMessage, { message: formError })),
            React.createElement(Dialog$1.Footer, null,
                React.createElement(Box, { flex: 1 }),
                React.createElement(Button$1, { "data-test-id": 'cancelBtn', color: 'inherit', variant: 'text', type: 'reset', onClick: props.onClose }, t('cancel')),
                React.createElement(Button$1, { "data-test-id": 'inviteBtn', disabled: !canSubmit, loading: isSubmitting, color: 'primary', type: 'submit' }, !userData ? t('invite') : t('save')))));
    }));
};
const InviteUserDialog = (_a) => {
    var { onClose } = _a, props = __rest(_a, ["onClose"]);
    const t = useT('allUsers_InviteUser');
    const { injector } = useShadowDom();
    const handleClose = react.exports.useCallback(() => {
        onClose();
    }, [onClose]);
    return (React.createElement(Dialog$1, Object.assign({ container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl }, props, { onClose: handleClose, title: t('title') }),
        React.createElement(InviteUserForm, Object.assign({}, props, { onClose: handleClose }))));
};

const AllUsersPage$1 = () => {
    const [searching, setSearching] = react.exports.useState(false);
    const [searchQuery, onSearch] = react.exports.useState('');
    const { allUsers, roles } = useAuthTeamState();
    const { loadAllSubTenantsUsers } = useAuthTeamActions();
    const { loadSubTenants, loadSubTenantsTree } = useTenantsActions();
    const [inviteUserDialog, handleCloseInviteUser, handleOpenInviteUser, inviteUserData] = useDialogState();
    react.exports.useEffect(() => {
        loadSubTenants();
        loadSubTenantsTree();
        const queryObject = {
            _filter: '',
            _offset: 0,
            _limit: 20,
            _order: 'DESC',
            _sortBy: 'name',
            silentLoading: allUsers.length > 0,
        };
        loadAllSubTenantsUsers(queryObject);
        return () => loadAllSubTenantsUsers(queryObject);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadAllSubTenantsUsers]);
    useEffectAfterMount(() => {
        loadAllSubTenantsUsers({
            _filter: searchQuery,
            _offset: 0,
            _limit: 20,
            _order: 'DESC',
            _sortBy: 'name',
            callback: () => setSearching(false),
        });
    }, [searchQuery, loadAllSubTenantsUsers]);
    return (React.createElement(PageWrapper, { flex: 1, display: 'flex', flexDirection: 'column' },
        React.createElement(TableSearchContext.Provider, { value: { searching, searchQuery, onSearch, setSearching } },
            React.createElement(AllUsersHeader, { handleOpenInviteUser: handleOpenInviteUser }),
            React.createElement(Box, { mt: 6, flex: 1, display: 'flex', flexDirection: 'column' },
                React.createElement(AllUsersTable, { handleOpenInviteUser: handleOpenInviteUser })),
            React.createElement(InviteUserDialog, { open: inviteUserDialog, onClose: handleCloseInviteUser, roles: roles, teamUser: inviteUserData }))));
};
var AllUsersPage$2 = AllUsersPage$1;

var AllUsersPage = wrapPage(AllUsersPage$2, 'allUsers');

const usePreloadRoutes = () => {
    const { loadProfile, loadAccountSettings, loadSSOConfigurationsV2, loadSecurityPolicy, loadVendorPasswordConfig, } = useAuthActions();
    const { injector } = useShadowDom();
    const isAuthenticated = useIsAuthenticated();
    const { policy, loading: loadingPolicy } = usePublicPolicySettings();
    const shouldLoad = react.exports.useCallback((page) => {
        var _a;
        const metadata = Metadata.getInstance(injector.name).navigation[page];
        if (!metadata) {
            return false;
        }
        if (metadata.visibility === 'hidden') {
            return false;
        }
        if (metadata.featureFlag) {
            return false;
        }
        if ((policy === null || policy === void 0 ? void 0 : policy.forcePermissions) && metadata.visibility === 'byPermissions') {
            return hasPermission(...((_a = metadata.permissions) !== null && _a !== void 0 ? _a : []));
        }
        return true;
    }, [policy === null || policy === void 0 ? void 0 : policy.forcePermissions]);
    react.exports.useEffect(() => {
        if (isAuthenticated && !loadingPolicy) {
            if (shouldLoad('profile')) {
                loadProfile();
            }
            if (shouldLoad('privacy')) {
                loadVendorPasswordConfig();
            }
            if (shouldLoad('account')) {
                loadAccountSettings();
            }
            if (shouldLoad('security')) {
                loadSecurityPolicy();
            }
            if (shouldLoad('sso')) {
                loadSSOConfigurationsV2();
            }
        }
    }, [isAuthenticated, shouldLoad, loadingPolicy]);
};
const getRoutes = (appName, user, vendorConfig) => {
    return [
        { type: 'nav-header', id: 'profile', path: '/', icon: { xl: React.createElement(ProfileIcon, null), default: React.createElement(UserAvatar, null) }, component: ProfilePage },
        { type: 'nav-header', id: 'privacy', path: '/privacy', icon: React.createElement(PrivacyIcon, null), component: PrivacyPage },
        { type: 'nav-header', id: 'personalApiTokens', path: '/personal-tokens', icon: React.createElement(PersonalTokensIcon, null), component: PersonalTokensPage },
        { type: 'nav-body', id: 'usage', path: '/usage', icon: React.createElement(UsageIcon, null), component: ProfilePage },
        { type: 'nav-body', id: 'account', path: '/account', icon: React.createElement(AccountDetailsIcon, null), component: AccountDetailsPage },
        { type: 'nav-body', id: 'users', path: '/users', icon: React.createElement(UsersIcon, null), component: UsersPage },
        { type: 'nav-body', id: 'allUsers', path: '/all-users', icon: React.createElement(UsersIcon, null), component: AllUsersPage },
        { type: 'nav-body', id: 'roles', path: '/roles', icon: React.createElement(RolesIcon, null), component: RolesPage },
        { type: 'nav-body', id: 'security', path: '/security', icon: React.createElement(SecurityIcon, null), component: SecurityPage },
        { type: 'nav-body', id: 'sso', path: '/sso', icon: React.createElement(SSOIcon, null), component: MultipleSsoPage },
        { type: 'nav-body', id: 'audits', path: '/audits', icon: React.createElement(AuditLogsIcon, null), component: AuditLogsPage },
        { type: 'nav-body', id: 'webhooks', path: '/webhooks', icon: React.createElement(WebhooksIcon, null), component: WebhooksPage },
        { type: 'nav-body', id: 'apiTokens', path: '/api-tokens', icon: React.createElement(APITokenIcon, null), component: ApiTokensPage },
        { type: 'nav-body', id: 'subscriptions', path: '/subscriptions', icon: React.createElement(SubscriptionIcon, null), component: SubscriptionPage },
        { type: 'app-route', id: 'login', path: '/account/login', component: LoginPage$1, publicRoute: true },
    ].filter((route) => {
        var _a;
        if (route.type === 'app-route') {
            return true;
        }
        const allMetadata = Metadata.getInstance(appName).navigation;
        const metadata = allMetadata[route.id];
        if (!metadata) {
            return false;
        }
        if (metadata.visibility === 'hidden') {
            return false;
        }
        if (metadata.featureFlag) {
            return false;
        }
        if ((vendorConfig === null || vendorConfig === void 0 ? void 0 : vendorConfig.forcePermissions) && metadata.visibility === 'byPermissions') {
            return hasPermission(...((_a = metadata.permissions) !== null && _a !== void 0 ? _a : []));
        }
        return true;
    });
};
const getPreviewModeRoutes = (appName) => {
    return [
        { type: 'nav-header', id: 'profile', path: '/', icon: { xl: React.createElement(ProfileIcon, null), default: React.createElement(UserAvatar, null) }, component: ProfilePage },
        { type: 'nav-header', id: 'privacy', path: '/privacy', icon: React.createElement(PrivacyIcon, null), component: PrivacyPage },
        { type: 'nav-header', id: 'personalApiTokens', path: '/personal-tokens', icon: React.createElement(PersonalTokensIcon, null), component: PersonalTokensPage },
        { type: 'nav-body', id: 'usage', path: '/usage', icon: React.createElement(UsageIcon, null), component: ProfilePage },
        { type: 'nav-body', id: 'account', path: '/account', icon: React.createElement(AccountDetailsIcon, null), component: AccountDetailsPage },
        { type: 'nav-body', id: 'users', path: '/users', icon: React.createElement(UsersIcon, null), component: UsersPage },
        { type: 'nav-body', id: 'allUsers', path: '/all-users', icon: React.createElement(UsersIcon, null), component: AllUsersPage },
        { type: 'nav-body', id: 'roles', path: '/roles', icon: React.createElement(RolesIcon, null), component: RolesPage },
        { type: 'nav-body', id: 'security', path: '/security', icon: React.createElement(SecurityIcon, null), component: SecurityPage },
        { type: 'nav-body', id: 'sso', path: '/sso', icon: React.createElement(SSOIcon, null), component: MultipleSsoPage },
        { type: 'nav-body', id: 'audits', path: '/audits', icon: React.createElement(AuditLogsIcon, null), component: AuditLogsPage },
        { type: 'nav-body', id: 'webhooks', path: '/webhooks', icon: React.createElement(WebhooksIcon, null), component: WebhooksPage },
        { type: 'nav-body', id: 'apiTokens', path: '/api-tokens', icon: React.createElement(APITokenIcon, null), component: ApiTokensPage },
        { type: 'nav-body', id: 'subscriptions', path: '/subscriptions', icon: React.createElement(SubscriptionIcon, null), component: SubscriptionPage },
        { type: 'app-route', id: 'login', path: '/account/login', component: LoginPage$1, publicRoute: true },
    ]
        .filter((route) => {
        const allMetadata = Metadata.getInstance(appName).navigation;
        const metadata = allMetadata[route.id];
        if (!metadata) {
            return false;
        }
        if (metadata.featureFlag) {
            return false;
        }
        return true;
    })
        .map((route) => {
        const allMetadata = Metadata.getInstance(appName).navigation;
        const metadata = allMetadata[route.id];
        if (metadata.visibility === 'hidden') {
            return Object.assign(Object.assign({}, route), { visibility: 'hidden' });
        }
        return route;
    });
};

const AppNavigation = () => {
    const user = useAuthUserOrNull();
    const t = useT('navigation');
    const history = useHistory();
    const { close } = react.exports.useContext(DrawerContext);
    const location = useLocation();
    const activeRoute = useRouteMatch(location.pathname);
    const { policy } = usePublicPolicySettings();
    const { tenants } = useTenantsState();
    const { injector } = useShadowDom();
    const isTenantReseller = react.exports.useMemo(() => {
        var _a, _b;
        return (_b = (_a = tenants.find(({ tenantId }) => tenantId === (user === null || user === void 0 ? void 0 : user.tenantId))) === null || _a === void 0 ? void 0 : _a.isReseller) !== null && _b !== void 0 ? _b : false;
    }, [tenants, user]);
    const routes = react.exports.useMemo(() => {
        return getRoutes(injector.name, user, policy);
    }, [injector.name, policy, user]);
    const isRouteActive = react.exports.useCallback((route) => {
        return route.path === (activeRoute === null || activeRoute === void 0 ? void 0 : activeRoute.path);
    }, [activeRoute]);
    const { events } = useShadowDom();
    const { email } = useAuthUser();
    const onNavigationClicked = react.exports.useCallback((routePath) => {
        var _a, _b;
        const routeId = (_a = routes.find(({ path }) => {
            return path === routePath;
        })) === null || _a === void 0 ? void 0 : _a.id;
        if (routeId && AdminPortalPages[routeId]) {
            (_b = events === null || events === void 0 ? void 0 : events.adminBoxMenuClicked) === null || _b === void 0 ? void 0 : _b.call(events, { email, tab: AdminPortalPages[routeId] });
        }
        history.push(routePath);
        close();
    }, [history, close]);
    const userInfo = react.exports.useMemo(() => user
        ? {
            name: getUserFullName(user),
            email: user.email,
            profilePictureUrl: user.profilePictureUrl,
        }
        : null, [user]);
    const tenantRoutes = routes.filter((route) => route.type === 'nav-body');
    const workspaceRoutes = tenantRoutes.filter((route) => route.id !== 'allUsers');
    const allAccountsRoutes = tenantRoutes.filter((route) => route.id === 'allUsers');
    const items = react.exports.useMemo(() => {
        return [
            {
                items: routes
                    .filter((route) => route.type === 'nav-header')
                    .map((route) => (Object.assign(Object.assign({}, route), { title: t(route.id), selected: isRouteActive(route), id: route.id }))),
            },
            ...(tenantRoutes.length > 0
                ? [
                    {
                        title: t('workspace'),
                        items: workspaceRoutes.map((route) => (Object.assign(Object.assign({}, route), { title: t(route.id), selected: isRouteActive(route), id: route.id }))),
                    },
                    ...(isTenantReseller
                        ? [
                            {
                                title: t('allAccounts'),
                                items: allAccountsRoutes.map((route) => (Object.assign(Object.assign({}, route), { title: t(route.id), selected: isRouteActive(route), id: route.id }))),
                            },
                        ]
                        : []),
                ]
                : []),
        ];
    }, [routes, tenantRoutes, workspaceRoutes, allAccountsRoutes, t, isRouteActive, isTenantReseller]);
    return React.createElement(Navigation, { user: userInfo, items: items, onRedirectTo: onNavigationClicked });
};
var AppNavigation$1 = AppNavigation;

const AppNavigationPreviewMode = () => {
    const user = useAuthUserOrNull();
    const t = useT('navigation');
    const history = useHistory();
    const { close } = react.exports.useContext(DrawerContext);
    const location = useLocation();
    const activeRoute = useRouteMatch(location.pathname);
    const { injector } = useShadowDom();
    const { tenants } = useTenantsState();
    const isTenantReseller = react.exports.useMemo(() => {
        var _a, _b;
        return (_b = (_a = tenants.find(({ tenantId }) => tenantId === (user === null || user === void 0 ? void 0 : user.tenantId))) === null || _a === void 0 ? void 0 : _a.isReseller) !== null && _b !== void 0 ? _b : false;
    }, [tenants, user]);
    const previewRoutes = getPreviewModeRoutes(injector.name);
    const isRouteActive = react.exports.useCallback((route) => {
        return route.path === (activeRoute === null || activeRoute === void 0 ? void 0 : activeRoute.path);
    }, [activeRoute]);
    const onNavigationClicked = react.exports.useCallback((path) => {
        history.push(path);
        close();
    }, [history, close]);
    const userInfo = react.exports.useMemo(() => user
        ? {
            name: getUserFullName(user),
            email: user.email,
            profilePictureUrl: user.profilePictureUrl,
        }
        : null, [user]);
    const tenantPreviewRoutes = previewRoutes.filter((route) => route.type === 'nav-body');
    const workspaceRoutes = tenantPreviewRoutes.filter((route) => route.id !== 'allUsers');
    const allAccountsRoutes = tenantPreviewRoutes.filter((route) => route.id === 'allUsers');
    const isAllWorkspaceRouteHidden = tenantPreviewRoutes.every((item) => (item === null || item === void 0 ? void 0 : item.visibility) === 'hidden');
    const items = react.exports.useMemo(() => {
        return [
            {
                items: previewRoutes
                    .filter((route) => route.type === 'nav-header')
                    .map((route) => (Object.assign(Object.assign({}, route), { title: t(route.id), selected: isRouteActive(route), id: route.id }))),
            },
            ...(tenantPreviewRoutes.length > 0 && !isAllWorkspaceRouteHidden
                ? [
                    {
                        title: t('workspace'),
                        items: workspaceRoutes.map((route) => (Object.assign(Object.assign({}, route), { title: t(route.id), selected: isRouteActive(route), id: route.id }))),
                    },
                    ...(isTenantReseller
                        ? [
                            {
                                title: t('allAccounts'),
                                items: allAccountsRoutes.map((route) => (Object.assign(Object.assign({}, route), { title: t(route.id), selected: isRouteActive(route), id: route.id }))),
                            },
                        ]
                        : []),
                ]
                : []),
        ];
    }, [previewRoutes, tenantPreviewRoutes, workspaceRoutes, allAccountsRoutes, t, isRouteActive]);
    return React.createElement(Navigation, { user: userInfo, items: items, onRedirectTo: onNavigationClicked });
};
var AppNavigationPreviewMode$1 = AppNavigationPreviewMode;

const ProtectedRoute = (props) => {
    const isAuthenticated = useIsAuthenticated();
    if (isAuthenticated) {
        return React.createElement(Route, Object.assign({}, props));
    }
    return React.createElement(Redirect, { to: '/account/login' });
};
const RoutesLayout = () => {
    const user = useAuthUserOrNull();
    const { injector } = useShadowDom();
    const { policy } = usePublicPolicySettings();
    const routes = react.exports.useMemo(() => getRoutes(injector.name, user, policy), [user, policy, injector.name]);
    usePreloadRoutes();
    const routesComponents = react.exports.useMemo(() => routes.map(({ path, exact, component, id, publicRoute }) => {
        const routeProps = { path, exact: exact !== null && exact !== void 0 ? exact : true, component };
        return publicRoute ? React.createElement(Route, Object.assign({ key: id }, routeProps)) : React.createElement(ProtectedRoute, Object.assign({ key: id }, routeProps));
    }), [routes]);
    return React.createElement(Switch, null,
        routesComponents,
        React.createElement(Redirect, { path: '*', to: routes[0].path }));
};
const RoutesLayoutPreviewMode = () => {
    const { injector } = useShadowDom();
    const routes = getPreviewModeRoutes(injector.name);
    usePreloadRoutes();
    const routesComponents = react.exports.useMemo(() => routes.map(({ path, exact, component, id, publicRoute }) => {
        const routeProps = { path, exact: exact !== null && exact !== void 0 ? exact : true, component };
        return publicRoute ? React.createElement(Route, Object.assign({ key: id }, routeProps)) : React.createElement(ProtectedRoute, Object.assign({ key: id }, routeProps));
    }), [routes]);
    return React.createElement(Switch, null,
        routesComponents,
        React.createElement(Redirect, { path: '*', to: routes[0].path }));
};

const PageLayout = () => {
    const theme = useTheme();
    const { isLoading } = useAuth(({ isLoading }) => ({ isLoading }));
    const { previewMode } = useShadowDom();
    const displayAsDrawer = useMuiMediaQuery(theme.breakpoints.down('sm'));
    const { open } = react.exports.useContext(DrawerContext);
    const { closeAdminBox } = react.exports.useContext(AppDialogContext);
    const routesLayout = previewMode ? React.createElement(RoutesLayoutPreviewMode, null) : React.createElement(RoutesLayout, null);
    return React.createElement(Box, { height: '100%', overflow: 'auto', display: 'flex', flexDirection: 'column' },
        React.createElement(PageHeaderProvider, null,
            !isLoading && React.createElement(PageHeader, { onClose: closeAdminBox, openDrawer: displayAsDrawer ? open : undefined }),
            !isLoading && routesLayout));
};
var PageLayout$1 = PageLayout;

const LogoContainer = styled('div')(({ theme }) => ({
    position: 'absolute',
    padding: '1.5rem 0',
    boxSizing: 'border-box',
    bottom: 0,
    left: 0,
    right: 0,
    color: theme.palette.grey[700],
    fontSize: '0.75rem',
    display: 'flex',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
    background: theme.navigation.background,
    '& svg': {
        width: '4.625rem',
        marginLeft: '.5rem',
    },
}));
const PoweredByLogo = () => {
    const t = useT('navigation');
    return React.createElement(LogoContainer, null,
        React.createElement("span", null, t('poweredBy')),
        React.createElement(SvgIcon, { viewBox: '0 0 74 14' },
            React.createElement("mask", { id: "mask0", mask: "alpha", maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "74", height: "14" },
                React.createElement("path", { d: "M74 0H0V14H74V0Z", fill: "white" })),
            React.createElement("g", { mask: "url(#mask0)" },
                React.createElement("path", { d: "M16.516 11.0457V6.73371H15.6987V5.50009H16.516V4.72148C16.4789 4.05463 16.6813 3.39642 17.0869 2.86486C17.4628 2.41167 18.0293 2.15935 18.6188 2.18263C19.1567 2.18869 19.6864 2.3155 20.1684 2.55363L19.8444 3.76356C19.7087 3.69388 19.5655 3.6397 19.4176 3.60202C19.271 3.5608 19.1195 3.53872 18.9672 3.53633C18.4065 3.53633 18.1261 3.91163 18.1261 4.66225V5.50063H19.6612V6.73425H18.1261V11.0462L16.516 11.0457Z", fill: "#8B9DB8" }),
                React.createElement("path", { d: "M25.6353 6.15842C25.1836 6.15833 24.737 6.25434 24.3255 6.44003C23.9604 6.60051 23.666 6.88746 23.4969 7.24772V11.045H21.8867V4.76919H23.3646V6.11049C23.5618 5.7023 23.8518 5.34556 24.2115 5.06857C24.5232 4.81796 24.9103 4.6788 25.3107 4.67334C25.3993 4.67334 25.4652 4.67334 25.5089 4.67926C25.5513 4.68307 25.5935 4.689 25.6353 4.69703V6.15842Z", fill: "#8B9DB8" }),
                React.createElement("path", { d: "M30.4891 11.1653C30.0155 11.1727 29.5454 11.0829 29.108 10.9015C28.716 10.7377 28.3621 10.4952 28.0682 10.1891C27.7842 9.89014 27.5618 9.53853 27.4136 9.15419C27.1102 8.35625 27.1102 7.47522 27.4136 6.67727C27.5617 6.2924 27.7841 5.94023 28.0682 5.64073C28.3624 5.33496 28.7162 5.09251 29.108 4.92835C29.5454 4.74718 30.0155 4.65755 30.4891 4.66504C30.9612 4.65706 31.4299 4.74672 31.8654 4.92835C32.6437 5.25767 33.2533 5.88936 33.5534 6.67727C33.8575 7.47508 33.8575 8.35638 33.5534 9.15419C33.4061 9.53785 33.1861 9.8896 32.9052 10.1902C32.6135 10.4971 32.2604 10.7394 31.8687 10.9015C31.4311 11.0829 30.9608 11.1727 30.487 11.1653H30.4891ZM28.8439 7.9195C28.8404 8.17841 28.8832 8.43586 28.9703 8.67981C29.0485 8.89711 29.1666 9.09797 29.3187 9.27212C29.4636 9.4367 29.6415 9.56915 29.841 9.66089C30.2535 9.84417 30.7248 9.84417 31.1373 9.66089C31.3368 9.56915 31.5147 9.4367 31.6596 9.27212C31.8128 9.09617 31.9311 8.89279 32.008 8.67281C32.0948 8.42673 32.1375 8.16739 32.1344 7.90658C32.1367 7.64987 32.0939 7.39475 32.008 7.15273C31.9312 6.93287 31.8129 6.72965 31.6596 6.55396C31.5149 6.3891 31.3369 6.25646 31.1373 6.16466C30.9339 6.07232 30.7127 6.02528 30.4891 6.02681C30.265 6.02515 30.0433 6.07432 29.841 6.17058C29.6419 6.26581 29.4642 6.40026 29.3187 6.56581C29.1655 6.74181 29.0473 6.94518 28.9703 7.16512C28.8843 7.4071 28.8415 7.66225 28.8439 7.91896", fill: "#8B9DB8" }),
                React.createElement("path", { d: "M41.8919 11.0458H40.2818V7.52423C40.3123 7.13836 40.2197 6.75274 40.0171 6.42254C39.8456 6.19311 39.5714 6.06309 39.2846 6.07523C39.1159 6.07673 38.9489 6.10922 38.792 6.17108C38.6209 6.23617 38.4608 6.32696 38.3172 6.44031C38.1654 6.55965 38.0301 6.69853 37.9148 6.85331C37.7953 7.01157 37.7056 7.1902 37.6502 7.38047V11.0458H36.0405V4.76947H37.4946V5.93147C37.7311 5.52762 38.0821 5.20256 38.5036 4.99723C38.9662 4.76857 39.477 4.65355 39.9933 4.66177C40.3272 4.64801 40.6589 4.72231 40.9548 4.87716C41.1927 5.01105 41.3914 5.20466 41.5311 5.43877C41.6721 5.68322 41.7678 5.95098 41.8136 6.22923C41.8657 6.52579 41.8919 6.82631 41.8919 7.12739V11.0458Z", fill: "#8B9DB8" }),
                React.createElement("path", { d: "M48.2354 10.7221C47.9751 10.8336 47.7084 10.9295 47.4365 11.0091C47.1152 11.106 46.7811 11.1547 46.4454 11.1534C46.2322 11.1546 46.0199 11.1263 45.8145 11.0694C45.6252 11.0171 45.4491 10.9254 45.2981 10.8001C45.1443 10.6699 45.0228 10.5058 44.9432 10.3209C44.849 10.0953 44.8039 9.85228 44.8109 9.60799V6.00029H43.9937V4.76937H44.8109V2.73291H46.4211V4.76937H47.7547V6.00299H46.4211V9.06899C46.402 9.24641 46.4691 9.42223 46.6015 9.54229C46.7259 9.63527 46.8782 9.68365 47.0336 9.6796C47.2015 9.67986 47.3683 9.65164 47.5267 9.59614C47.6861 9.54229 47.8152 9.49222 47.9108 9.45237L48.2354 10.7221Z", fill: "#8B9DB8" }),
                React.createElement("path", { d: "M53.1735 11.1651C52.704 11.1717 52.238 11.0842 51.8032 10.9077C51.4111 10.7468 51.0556 10.5087 50.758 10.2077C50.4692 9.91194 50.2426 9.56175 50.0914 9.17759C49.9347 8.78517 49.8551 8.36636 49.857 7.94398C49.8542 7.51244 49.9317 7.08413 50.0855 6.68075C50.2329 6.29252 50.4574 5.93795 50.7455 5.63829C51.0442 5.3324 51.402 5.09006 51.7972 4.9259C52.237 4.74503 52.7092 4.65544 53.1848 4.66259C53.6568 4.65466 54.1252 4.74431 54.5606 4.9259C54.9488 5.09036 55.3002 5.33056 55.5939 5.63236C55.8782 5.92827 56.0987 6.27899 56.2421 6.66298C56.3904 7.05311 56.4658 7.46701 56.4646 7.88421C56.4646 7.98813 56.4646 8.08775 56.4587 8.18359C56.4565 8.26426 56.4464 8.34452 56.4284 8.42321H51.5628C51.5817 8.65193 51.6429 8.87519 51.7432 9.08175C51.9257 9.45269 52.2439 9.73981 52.6323 9.88406C52.8243 9.956 53.0278 9.99249 53.2329 9.99175C53.5505 9.99243 53.8629 9.91197 54.1404 9.75806C54.4013 9.62723 54.6077 9.40894 54.7232 9.14152L56.1043 9.52436C55.8588 10.0184 55.4723 10.4291 54.9933 10.7047C54.4411 11.0231 53.8112 11.1827 53.1735 11.1656V11.1651ZM54.8069 7.38075C54.7859 6.9506 54.5985 6.5453 54.284 6.24998C53.9796 5.96781 53.5767 5.8152 53.1611 5.82459C52.9533 5.8232 52.7471 5.86177 52.554 5.93821C52.3692 6.01193 52.2001 6.11971 52.0554 6.2559C51.9081 6.39653 51.7879 6.563 51.7011 6.74698C51.6067 6.94629 51.5517 7.16181 51.539 7.38182L54.8069 7.38075Z", fill: "#ADBCD2" }),
                React.createElement("path", { d: "M61.1155 11.0814C60.7188 11.086 60.3264 11 59.9682 10.8299C59.6243 10.6663 59.3192 10.4315 59.0732 10.1412C58.82 9.84216 58.6246 9.49893 58.4969 9.1289C58.3586 8.73642 58.2891 8.32312 58.2916 7.90713C58.288 7.47451 58.3611 7.04465 58.5077 6.63744C58.6441 6.26089 58.8478 5.91208 59.1089 5.6079C59.6336 4.99625 60.4044 4.64946 61.2117 4.66182C61.6658 4.65112 62.1143 4.76492 62.508 4.99082C62.8756 5.20775 63.186 5.50902 63.4133 5.86959V4.76952H64.8177V10.7464C64.8249 11.1754 64.7369 11.6007 64.56 11.9919C64.3903 12.353 64.1413 12.6713 63.8314 12.9234C63.5032 13.187 63.1278 13.3862 62.7252 13.5104C62.2742 13.6496 61.8042 13.718 61.3321 13.7134C60.7311 13.7329 60.1335 13.6164 59.5842 13.3725C59.1148 13.1444 58.7022 12.815 58.3764 12.4081L59.2536 11.5579C59.4978 11.8562 59.8081 12.094 60.16 12.2525C60.5276 12.4208 60.9277 12.5066 61.3321 12.504C61.5738 12.505 61.8144 12.4707 62.0462 12.4022C62.2663 12.339 62.4709 12.2308 62.6468 12.0845C62.824 11.9351 62.9639 11.7467 63.0557 11.5342C63.1615 11.2841 63.2131 11.0146 63.207 10.7432V9.95544C63.0014 10.3116 62.6967 10.6007 62.3298 10.7879C61.955 10.9828 61.5382 11.0835 61.1155 11.0814ZM61.6686 9.79983C61.8404 9.8005 62.0109 9.77209 62.1731 9.71582C62.3295 9.66179 62.4771 9.58523 62.6112 9.48859C62.7434 9.39258 62.8625 9.27981 62.9655 9.15313C63.0666 9.03049 63.1481 8.89299 63.207 8.74552V7.24859C63.0722 6.89493 62.8385 6.5873 62.5334 6.36229C62.2584 6.14889 61.9209 6.03108 61.5725 6.02682C61.3361 6.0239 61.1026 6.0794 60.893 6.18836C60.6912 6.2947 60.5136 6.44134 60.3712 6.61913C60.2245 6.80318 60.1124 7.01227 60.0406 7.23621C59.9639 7.46795 59.9251 7.71048 59.9256 7.95452C59.9235 8.20039 59.9686 8.44439 60.0585 8.67336C60.1423 8.89028 60.2666 9.08942 60.4247 9.26028C60.5804 9.42765 60.7683 9.56206 60.9772 9.65552C61.1946 9.75247 61.4305 9.80151 61.6686 9.79929", fill: "#ADBCD2" }),
                React.createElement("path", { d: "M69.9231 11.0814C69.5265 11.086 69.134 11 68.7759 10.8299C68.4317 10.6663 68.1264 10.4315 67.8803 10.1412C67.6275 9.84191 67.4321 9.49875 67.304 9.12891C67.1658 8.73639 67.0966 8.32309 67.0993 7.90714C67.0956 7.47452 67.1687 7.04466 67.3153 6.63745C67.4515 6.2608 67.6552 5.91195 67.9165 5.60791C68.4411 4.99634 69.2117 4.64955 70.0187 4.66183C70.4729 4.65107 70.9213 4.76488 71.3151 4.99083C71.6819 5.20803 71.9915 5.50928 72.2182 5.8696V4.76952H73.6226V10.7464C73.6296 11.1755 73.5415 11.6008 73.3644 11.9919C73.1956 12.3528 72.9475 12.6712 72.6384 12.9234C72.3105 13.1872 71.9353 13.3863 71.5328 13.5104C71.0816 13.6496 70.6115 13.7181 70.1392 13.7134C69.5382 13.7328 68.9406 13.6163 68.3913 13.3725C67.922 13.1443 67.5094 12.8149 67.1835 12.4081L68.0591 11.5606C68.3035 11.8589 68.6139 12.0967 68.966 12.2552C69.3334 12.4234 69.7333 12.5093 70.1376 12.5067C70.3795 12.5076 70.6202 12.4733 70.8522 12.4049C71.0723 12.3417 71.2769 12.2335 71.4528 12.0872C71.63 11.9378 71.7699 11.7494 71.8617 11.5369C71.9673 11.2868 72.0187 11.0172 72.0124 10.7459V9.95545C71.8068 10.3116 71.5022 10.6007 71.1352 10.7879C70.7607 10.9829 70.344 11.0836 69.9215 11.0814H69.9231ZM70.4741 9.79984C70.646 9.80054 70.8168 9.77214 70.9791 9.71583C71.1354 9.66168 71.283 9.58514 71.4172 9.4886C71.5493 9.39244 71.6684 9.27969 71.7715 9.15314C71.8726 9.03061 71.9539 8.89308 72.0124 8.74552V7.2486C71.8781 6.89488 71.6444 6.58718 71.3394 6.36229C71.0642 6.14886 70.7266 6.03104 70.3779 6.02683C70.1417 6.02391 69.9084 6.07941 69.699 6.18837C69.4971 6.2947 69.3193 6.44133 69.1767 6.61914C69.0301 6.80332 68.9181 7.01237 68.8461 7.23621C68.7698 7.46805 68.7311 7.71054 68.7316 7.95452C68.7295 8.20039 68.7746 8.4444 68.8644 8.67337C68.9481 8.89026 69.0722 9.08941 69.2301 9.26029C69.3861 9.42767 69.5742 9.56207 69.7832 9.65552C70.0004 9.75248 70.2361 9.80153 70.4741 9.79929", fill: "#ADBCD2" }),
                React.createElement("path", { d: "M7.44386 1.49391C6.1648 0.107906 4.78202 -0.194171 3.39925 0.790137C2.41553 1.54874 1.64 2.54281 1.14468 3.68006C0.845721 4.30682 0.618683 4.96522 0.467877 5.64275C0.301835 6.38025 0.246138 7.13817 0.302592 7.89191C0.374127 9.24676 0.988291 10.5163 2.00729 11.4156C2.14052 11.5254 2.28051 11.6269 2.42645 11.7193C3.57731 12.3987 4.95184 12.5943 6.24744 12.2631C7.41559 11.9902 8.42156 11.2542 9.03297 10.2251C9.34465 9.67961 9.55507 9.08259 9.65414 8.46268C10.1403 5.5916 8.72293 2.88368 7.44386 1.49606V1.49391ZM4.35153 1.66406C3.03303 2.48844 2.47452 4.12752 2.31626 4.69021C2.28566 4.79969 2.17501 4.86663 2.06347 4.84314C2.00468 4.83116 1.95354 4.79535 1.92229 4.74428C1.89104 4.69322 1.88251 4.6315 1.89872 4.57391C2.01392 4.16654 2.16503 3.77012 2.35029 3.38929C2.73396 2.5402 3.34867 1.8153 4.12467 1.29683C4.19047 1.25643 4.2729 1.2541 4.34089 1.29071C4.40889 1.32732 4.45213 1.39731 4.45432 1.47432C4.45652 1.55133 4.41733 1.62366 4.35153 1.66406Z", fill: "#8B9DB8" }),
                React.createElement("path", { d: "M6.06104 13.2896C7.697 14.037 9.61721 13.7896 11.0088 12.6521C13.3508 10.7017 13.9996 6.71767 13.9996 6.71767C13.9996 6.71767 14.4133 4.65375 13.6517 3.46267C12.8901 2.27159 11.0088 2.28183 9.28733 2.87036C10.0566 4.43482 10.4802 6.1456 10.5297 7.88721C10.5079 10.5137 8.64445 12.7664 6.06212 13.288", fill: "#ADBCD2" }))));
};

const AppContent = () => {
    const { isLoading, isAuthenticated } = useAuth(({ isLoading, isAuthenticated, tenantsState: { loading, tenants } }) => ({
        isLoading: isLoading || (loading && tenants.length === 0),
        isAuthenticated,
    }));
    const { showPoweredByLogo } = useVendorState(({ whiteLabelMode }) => ({ showPoweredByLogo: !whiteLabelMode }));
    const { injector, basename = '', urlStrategy, setStaticRouteSetter, staticRoute, previewMode } = useShadowDom();
    const theme = useTheme();
    const displayAsDrawer = useMuiMediaQuery(theme.breakpoints.down('sm'));
    const history = useHistory();
    const [route, setRoute] = react.exports.useState(staticRoute);
    setStaticRouteSetter === null || setStaticRouteSetter === void 0 ? void 0 : setStaticRouteSetter(setRoute);
    react.exports.useEffect(() => {
        if (route) {
            history.push(route);
        }
    }, [route, history]);
    const { closeAdminBox } = react.exports.useContext(AppDialogContext);
    const { loading: loadingPolicy } = usePublicPolicySettings();
    const [drawerOpened, setDrawerOpened] = react.exports.useState(false);
    const drawerContextValue = react.exports.useMemo(() => ({
        opened: drawerOpened,
        close: () => setDrawerOpened(false),
        open: () => setDrawerOpened(true),
    }), [drawerOpened, setDrawerOpened]);
    const routes = useAuthRoutes();
    react.exports.useEffect(() => {
        if (!isLoading && !isAuthenticated) {
            const calculatedBasename = basename.endsWith('/') ? basename.substring(0, basename.length - 1) : '';
            if (injector) {
                closeAdminBox();
            }
            const path = calculatedBasename + routes.loginUrl;
            if (urlStrategy === 'path' && injector) {
                window.location.href = path;
            }
            else {
                window.location.hash = `#${path}`;
            }
        }
    }, [isLoading, isAuthenticated, routes, injector, urlStrategy, basename, closeAdminBox]);
    const appNavigation = previewMode ? React.createElement(AppNavigationPreviewMode$1, null) : React.createElement(AppNavigation$1, null);
    let navigationComponent = React.createElement(Fade, { in: !isLoading },
        React.createElement(NavigationGridItem, { withPoweredBy: showPoweredByLogo },
            appNavigation,
            showPoweredByLogo && React.createElement(PoweredByLogo, null)));
    if (displayAsDrawer) {
        navigationComponent = React.createElement(Drawer$1, { sx: { zIndex: '1300' }, open: drawerOpened, container: injector === null || injector === void 0 ? void 0 : injector.adminPortalEl, onBackdropClick: drawerContextValue.close },
            React.createElement(Grid, { height: "100%", container: true, alignItems: "stretch", wrap: "nowrap", position: "relative" },
                React.createElement(NavigationGridItem, null,
                    React.createElement(DrawerContext.Provider, { value: drawerContextValue }, appNavigation),
                    showPoweredByLogo && React.createElement(PoweredByLogo, null))));
    }
    return React.createElement(React.Fragment, null,
        (isLoading || loadingPolicy) && React.createElement(AppSkeleton, { absolute: true }),
        React.createElement(Grid, { height: "100%", container: true, alignItems: "stretch", wrap: "nowrap" },
            navigationComponent,
            React.createElement(PageGridItem, { item: true, xs: true },
                React.createElement(DrawerContext.Provider, { value: drawerContextValue },
                    React.createElement(PageLayout$1, null)))));
};
const AppLayout = () => {
    const { injector } = useShadowDom();
    return React.createElement(Provider, { context: FronteggStoreContext, store: injector.store },
        React.createElement(HashRouter, { basename: "admin-box" },
            React.createElement(AppContent, null)));
};
var AppLayout$1 = AppLayout;

const App = () => {
    const { isShadowDom } = useShadowDom();
    react.exports.useEffect(() => {
        document.addEventListener('focus', shadowFocusHandler, true);
        const oldDocumentBodyOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        return () => {
            document.removeEventListener('focus', shadowFocusHandler, true);
            document.body.style.overflow = oldDocumentBodyOverflow;
            window.history.pushState('', document.title, window.location.pathname);
        };
    }, []);
    const { calculatedTheme, theme, overrides } = initGlobalTheme(true);
    return React.createElement(I18nProvider$1, null,
        React.createElement(GlobalThemeProvider, { theme: calculatedTheme, isShadowDom: isShadowDom, module: FronteggModules.adminPortal },
            React.createElement(ThemeContext.Provider, { value: { theme, overrides } },
                React.createElement(InnerThemeProvider, { themeOptionKey: 'adminPortal' },
                    React.createElement(AppDialog, null,
                        React.createElement(AppLayout$1, null))))));
};
var App$1 = App;

const defaultTheme = 'modern';
const AdminPortal = ({ injector, options }) => {
    var _a, _b;
    return (React.createElement(ShadowDomContext.Provider, { value: Object.assign(Object.assign({ iframeRendering: false }, options), { themeOptions: enhanceAdminBoxTheme((_a = options.metadata) !== null && _a !== void 0 ? _a : {}, (_b = options.themeOptions) !== null && _b !== void 0 ? _b : {}), injector, slotsContainer: injector.adminPortalContainer, rootEl: injector.adminPortalEl }) },
        React.createElement(App$1, null)));
};
const AdminPortalPage = ({ injector, options, setThemeSetter, staticRoute, setStaticRouteSetter, }) => {
    var _a, _b;
    const [themeOptions, setThemeOptions] = react.exports.useState(enhanceAdminBoxTheme((_a = options === null || options === void 0 ? void 0 : options.metadata) !== null && _a !== void 0 ? _a : {}, (_b = options.themeOptions) !== null && _b !== void 0 ? _b : {}));
    const setTheme = (theme) => {
        var _a;
        const enhancedTheme = enhanceAdminBoxTheme((_a = options === null || options === void 0 ? void 0 : options.metadata) !== null && _a !== void 0 ? _a : {}, theme !== null && theme !== void 0 ? theme : {});
        setThemeOptions(enhancedTheme);
    };
    setThemeSetter === null || setThemeSetter === void 0 ? void 0 : setThemeSetter(setTheme);
    return (React.createElement(ShadowDomContext.Provider, { value: Object.assign(Object.assign({ iframeRendering: false }, options), { injector,
            themeOptions, slotsContainer: injector.adminPortalContainer, rootEl: injector.adminPortalEl, staticRoute,
            setStaticRouteSetter }) },
        React.createElement(App$1, null)));
};

export { AdminPortal, AdminPortalPage, CheckoutDialog$1 as CheckoutDialog, AdminPortal as default, defaultTheme };
