'use strict';

var reduxStore = require('@frontegg/redux-store');
var React = require('react');
var reactRedux = require('react-redux');
var FronteggStoreContext = require('./FronteggStoreContext-6cfac56c.js');
var restApi = require('@frontegg/rest-api');
var tslib = require('tslib');

const ShadowDomContext = React.createContext({});
const useShadowDom = () => {
    const context = React.useContext(ShadowDomContext);
    const { urlStrategy = 'path', onRedirectTo = urlStrategy === 'path'
        ? (path) => window.history.pushState(null, '', path)
        : (path) => window.history.pushState(null, '', `#${path}`), renderByRoute = false, customLoader = false, customStyles, contextOptions } = context, rest = tslib.__rest(context, ["urlStrategy", "onRedirectTo", "renderByRoute", "customLoader", "customStyles", "contextOptions"]);
    return Object.assign({ isShadowDom: true, onRedirectTo,
        renderByRoute,
        customLoader,
        customStyles,
        urlStrategy, contextOptions: Object.assign({ requestCredentials: 'include' }, contextOptions) }, rest);
};

const defaultMapper = {
    state: (state) => state,
    actions: (actions) => actions,
};
const useAuth = (stateMapper = defaultMapper.state) => {
    return FronteggStoreContext.useSelector((state) => stateMapper(state[reduxStore.authStoreName]), reactRedux.shallowEqual);
};
/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const { isAuthenticated, user } = useAuth();
 *   const loginWithRedirect = useLoginWithRedirect();
 *
 *   if (!isAuthenticated) {
 *     loginWithRedirect();
 *     return <></>;
 *   }
 *
 *   return (<div>Hello User {user.name}</div>);
 * }
 * ```
 *
 * use this frontegg hook function to get if user is "Authenticated"
 */
const useLoginWithRedirect = () => {
    const dispatch = FronteggStoreContext.useDispatch();
    return React.useMemo(() => reduxStore.bindActionCreators(reduxStore.authActions.requestHostedLoginAuthorize, dispatch), [reduxStore.authActions.requestHostedLoginAuthorize]);
};
const useAuthActions = () => {
    const dispatch = FronteggStoreContext.useDispatch();
    return React.useMemo(() => reduxStore.bindActionCreators(reduxStore.authActions, dispatch), [reduxStore.authActions]);
};
const useOnRedirectTo = () => {
    var _a;
    const context = React.useContext(ShadowDomContext);
    return (_a = context === null || context === void 0 ? void 0 : context.onRedirectTo) !== null && _a !== void 0 ? _a : restApi.ContextHolder.onRedirectTo;
};
const useAuthRoutes = () => useAuth((state) => (Object.assign({}, state.routes)));
/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const isAuthenticated  = useIsAuthenticated();
 *   return isAuthenticated ? <div>Hello User</div> : <Redirect to={'/login'}/>
 * }
 * ```
 *
 * use this frontegg hook function to get if user is "Authenticated"
 */
const useIsAuthenticated = () => FronteggStoreContext.useSelector(({ [reduxStore.authStoreName]: { isAuthenticated } }) => isAuthenticated, reactRedux.shallowEqual);
/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const user = useAuthUser();
 *   return user ? <div>Hello {user.name}!</div> : <div>Hello Guest!</div>
 * }
 * ```
 *
 * use this frontegg hook function to get the authenticated user
 * the return user is null if not authenticated
 */
const useAuthUser = () => {
    const routes = useAuthRoutes();
    const onRedirectTo = useOnRedirectTo();
    const user = useAuthUserOrNull();
    if (user == null) {
        onRedirectTo(routes.loginUrl, { refresh: true });
        return {};
    }
    return user;
};
const useAuthUserOrNull = () => {
    const { user } = FronteggStoreContext.useSelector(({ [reduxStore.authStoreName]: { user } }) => ({ user }), reactRedux.shallowEqual);
    return user || null;
};
/**
 * hooks helpers
 */
const sliceReducerActionsBy = (reducer) => {
    const reducerKeys = Object.keys(reducer);
    const reducerActions = reducerKeys.map((key) => ({ [key]: reduxStore.authActions[key] }));
    return reducerActions.reduce((p, n) => (Object.assign(Object.assign({}, p), n)), {});
};
const stateHookGenerator = (stateMapper, subState) => {
    return FronteggStoreContext.useSelector((state) => { var _a; return (_a = stateMapper === null || stateMapper === void 0 ? void 0 : stateMapper(state[reduxStore.authStoreName][subState])) !== null && _a !== void 0 ? _a : state[reduxStore.authStoreName][subState]; }, reactRedux.shallowEqual);
};
const reducerActionsGenerator = (actions, reducers) => {
    const dispatch = FronteggStoreContext.useDispatch();
    return React.useMemo(() => reduxStore.bindActionCreators(Object.assign(Object.assign({}, actions), sliceReducerActionsBy(reducers)), dispatch), [dispatch]);
};

const useAcceptInvitationState = (stateMapper) => stateHookGenerator(stateMapper, 'acceptInvitationState');
const useAcceptInvitationActions = () => reducerActionsGenerator(reduxStore.acceptInvitationActions, reduxStore.acceptInvitationReducers);

const useActivateAccountState = (stateMapper) => stateHookGenerator(stateMapper, 'activateState');
const useActivateAccountActions = () => reducerActionsGenerator(reduxStore.activateAccountActions, reduxStore.activateAccountReducers);

const useApiTokensState = (stateMapper) => stateHookGenerator(stateMapper, 'apiTokensState');
const useApiTokensActions = () => reducerActionsGenerator(reduxStore.apiTokensActions, reduxStore.apiTokensReducers);

const useForgotPasswordState = (stateMapper) => stateHookGenerator(stateMapper, 'forgotPasswordState');
const useForgotPasswordActions = () => reducerActionsGenerator(reduxStore.forgotPasswordActions, reduxStore.forgotPasswordReducers);

const useResetPhoneNumberState = (stateMapper) => stateHookGenerator(stateMapper, 'resetPhoneNumberState');
const useResetPhoneNumberActions = () => reducerActionsGenerator(reduxStore.resetPhoneNumberActions, reduxStore.resetPhoneNumberReducers);

const useLoginState = (stateMapper) => stateHookGenerator(stateMapper, 'loginState');
const useLoginActions = () => reducerActionsGenerator(reduxStore.loginActions, reduxStore.loginReducers);

const useMfaState = (stateMapper) => stateHookGenerator(stateMapper, 'mfaState');
const useMfaActions = () => reducerActionsGenerator(reduxStore.mfaActions, reduxStore.mfaReducers);

const reloadProfileIfNeeded = () => {
    const { loading } = useProfileState();
    const { loadProfile } = useProfileActions();
    React.useEffect(() => {
        !loading && loadProfile();
    }, []);
};
const useProfileState = (stateMapper) => stateHookGenerator(stateMapper, 'profileState');
const useProfileActions = () => reducerActionsGenerator(reduxStore.profileActions, reduxStore.profileReducers);

const useSignUpState = (stateMapper) => stateHookGenerator(stateMapper, 'signUpState');
const useSignUpActions = () => reducerActionsGenerator(reduxStore.signUpActions, reduxStore.signUpReducers);

const useSocialLoginState = (stateMapper) => stateHookGenerator(stateMapper, 'socialLoginState');
const useSocialLoginActions = () => reducerActionsGenerator(reduxStore.socialLoginsActions, reduxStore.socialLoginsReducer);

const useAuthTeamState = (stateMapper) => stateHookGenerator(stateMapper, 'teamState');
const useAuthTeamActions = () => reducerActionsGenerator(reduxStore.teamActions, reduxStore.teamReducers);

const useSSOState = (stateMapper) => stateHookGenerator(stateMapper, 'ssoState');
const useSSOActions = () => reducerActionsGenerator(reduxStore.ssoActions, reduxStore.ssoReducers);

const useSecurityPolicyState = (stateMapper) => stateHookGenerator(stateMapper, 'securityPolicyState');
const useSecurityPolicyActions = () => reducerActionsGenerator(reduxStore.securityPolicyActions, reduxStore.securityPolicyReducers);
const usePublicPolicySettings = (loadOnMount = false) => {
    const { loading, policy, saving, error } = useSecurityPolicyState(state => state.publicPolicy);
    const { loadPublicSecurityPolicy } = useSecurityPolicyActions();
    React.useEffect(() => {
        (loadOnMount || !policy) && loadPublicSecurityPolicy();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadPublicSecurityPolicy]);
    return { loading, saving, error, policy };
};
const usePublicAuthStrategiesPolicySettings = (loadOnMount = false) => {
    const { loading, policy, saving, error } = useSecurityPolicyState(state => state.publicAuthStrategyPolicy);
    const { loadPublicAuthStrategiesPolicy } = useSecurityPolicyActions();
    React.useEffect(() => {
        (loadOnMount || !policy) && loadPublicAuthStrategiesPolicy();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loadOnMount, loadPublicAuthStrategiesPolicy]);
    return { loading, saving, error, policy };
};

const useTenantsState = (stateMapper) => stateHookGenerator(stateMapper, 'tenantsState');
const useTenantsActions = () => reducerActionsGenerator(reduxStore.tenantsActions, reduxStore.tenantsReducers);

const useRolesState = (stateMapper) => stateHookGenerator(stateMapper, 'rolesState');
const useRolesActions = () => reducerActionsGenerator(reduxStore.rolesActions, reduxStore.rolesReducers);

const useSessionsState = (stateMapper) => stateHookGenerator(stateMapper, 'sessionsState');
const useSessionsActions = () => reducerActionsGenerator(reduxStore.sessionsActions, reduxStore.sessionsReducers);

const useSessionsPolicyState = (stateMapper) => stateHookGenerator(stateMapper, 'sessionsPolicyState');
const useSessionsPolicyActions = () => reducerActionsGenerator(reduxStore.sessionsPolicyActions, reduxStore.sessionsPolicyReducers);

exports.ShadowDomContext = ShadowDomContext;
exports.reloadProfileIfNeeded = reloadProfileIfNeeded;
exports.useAcceptInvitationActions = useAcceptInvitationActions;
exports.useAcceptInvitationState = useAcceptInvitationState;
exports.useActivateAccountActions = useActivateAccountActions;
exports.useActivateAccountState = useActivateAccountState;
exports.useApiTokensActions = useApiTokensActions;
exports.useApiTokensState = useApiTokensState;
exports.useAuth = useAuth;
exports.useAuthActions = useAuthActions;
exports.useAuthRoutes = useAuthRoutes;
exports.useAuthTeamActions = useAuthTeamActions;
exports.useAuthTeamState = useAuthTeamState;
exports.useAuthUser = useAuthUser;
exports.useAuthUserOrNull = useAuthUserOrNull;
exports.useForgotPasswordActions = useForgotPasswordActions;
exports.useForgotPasswordState = useForgotPasswordState;
exports.useIsAuthenticated = useIsAuthenticated;
exports.useLoginActions = useLoginActions;
exports.useLoginState = useLoginState;
exports.useLoginWithRedirect = useLoginWithRedirect;
exports.useMfaActions = useMfaActions;
exports.useMfaState = useMfaState;
exports.useOnRedirectTo = useOnRedirectTo;
exports.useProfileActions = useProfileActions;
exports.useProfileState = useProfileState;
exports.usePublicAuthStrategiesPolicySettings = usePublicAuthStrategiesPolicySettings;
exports.usePublicPolicySettings = usePublicPolicySettings;
exports.useResetPhoneNumberActions = useResetPhoneNumberActions;
exports.useResetPhoneNumberState = useResetPhoneNumberState;
exports.useRolesActions = useRolesActions;
exports.useRolesState = useRolesState;
exports.useSSOActions = useSSOActions;
exports.useSSOState = useSSOState;
exports.useSecurityPolicyActions = useSecurityPolicyActions;
exports.useSecurityPolicyState = useSecurityPolicyState;
exports.useSessionsActions = useSessionsActions;
exports.useSessionsPolicyActions = useSessionsPolicyActions;
exports.useSessionsPolicyState = useSessionsPolicyState;
exports.useSessionsState = useSessionsState;
exports.useShadowDom = useShadowDom;
exports.useSignUpActions = useSignUpActions;
exports.useSignUpState = useSignUpState;
exports.useSocialLoginActions = useSocialLoginActions;
exports.useSocialLoginState = useSocialLoginState;
exports.useTenantsActions = useTenantsActions;
exports.useTenantsState = useTenantsState;
