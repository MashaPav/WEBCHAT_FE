var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

var cjs = deepmerge_1;

var deepMerge = cjs;

/**
 * Returns a number whose value is limited to the given range.
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */
function clamp(value, min = 0, max = 1) {
    return Math.min(Math.max(min, value), max);
}
/**
 * Converts a color from CSS hex format to CSS rgb format.
 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
 * @returns {string} A CSS rgb color string
 */
function hexToRgb(color) {
    color = color.substr(1);
    const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
    let colors = color.match(re);
    if (colors && colors[0].length === 1) {
        colors = colors.map((n) => n + n);
    }
    return colors
        ? `rgb${colors.length === 4 ? 'a' : ''}(${colors
            .map((n, index) => {
            return index < 3 ? parseInt(n, 16) : Math.round((parseInt(n, 16) / 255) * 1000) / 1000;
        })
            .join(', ')})`
        : '';
}
function intToHex(int) {
    const hex = int.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
}
/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 */
function decomposeColor(color) {
    // Idempotent
    if (color.type) {
        return color;
    }
    if (color.charAt(0) === '#') {
        return decomposeColor(hexToRgb(color));
    }
    const marker = color.indexOf('(');
    const type = color.substring(0, marker);
    if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(type) === -1) {
        throw new Error('MUI: Unsupported `%s` color.\n' +
            'The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color(). ' + color);
    }
    let values = color.substring(marker + 1, color.length - 1);
    let colorSpace;
    if (type === 'color') {
        values = values.split(' ');
        colorSpace = values.shift();
        if (values.length === 4 && values[3].charAt(0) === '/') {
            values[3] = values[3].substr(1);
        }
        if (['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(colorSpace) === -1) {
            throw new Error('MUI: unsupported `%s` color space.\n' +
                'The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.' + colorSpace);
        }
    }
    else {
        values = values.split(',');
    }
    values = values.map((value) => parseFloat(value));
    return { type, values, colorSpace };
}
/**
 * Converts a color object with type and values to a string.
 * @param {object} color - Decomposed color
 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns {string} A CSS color string
 */
function recomposeColor(color) {
    const { type, colorSpace } = color;
    let { values } = color;
    if (type.indexOf('rgb') !== -1) {
        // Only convert the first 3 values to int (i.e. not alpha)
        values = values.map((n, i) => (i < 3 ? parseInt(n, 10) : n));
    }
    else if (type.indexOf('hsl') !== -1) {
        values[1] = `${values[1]}%`;
        values[2] = `${values[2]}%`;
    }
    if (type.indexOf('color') !== -1) {
        values = `${colorSpace} ${values.join(' ')}`;
    }
    else {
        values = `${values.join(', ')}`;
    }
    return `${type}(${values})`;
}
/**
 * Converts a color from CSS rgb format to CSS hex format.
 * @param {string} color - RGB color, i.e. rgb(n, n, n)
 * @returns {string} A CSS rgb color string, i.e. #nnnnnn
 */
function rgbToHex(color) {
    // Idempotent
    if (color.indexOf('#') === 0) {
        return color;
    }
    const { values } = decomposeColor(color);
    return `#${values.map((n, i) => intToHex(i === 3 ? Math.round(255 * n) : n)).join('')}`;
}
/**
 * Darkens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function darken(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);
    if (color.type.indexOf('hsl') !== -1) {
        color.values[2] *= 1 - coefficient;
    }
    else if (color.type.indexOf('rgb') !== -1 || color.type.indexOf('color') !== -1) {
        for (let i = 0; i < 3; i += 1) {
            color.values[i] *= 1 - coefficient;
        }
    }
    return recomposeColor(color);
}
/**
 * Lightens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function lighten(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);
    if (color.type.indexOf('hsl') !== -1) {
        color.values[2] += (100 - color.values[2]) * coefficient;
    }
    else if (color.type.indexOf('rgb') !== -1) {
        for (let i = 0; i < 3; i += 1) {
            color.values[i] += (255 - color.values[i]) * coefficient;
        }
    }
    else if (color.type.indexOf('color') !== -1) {
        for (let i = 0; i < 3; i += 1) {
            color.values[i] += (1 - color.values[i]) * coefficient;
        }
    }
    return recomposeColor(color);
}

const generateMainColorObject = (color) => {
    if (!!color) {
        return {
            main: color,
            light: rgbToHex(lighten(color, 0.4)),
            dark: rgbToHex(darken(color, 0.15)),
            hover: rgbToHex(darken(color, 0.15)),
            active: rgbToHex(darken(color, 0.20)),
        };
    }
};
const generateSubColorObject = (color) => {
    if (!!color) {
        return {
            main: color,
            light: lighten(color, 0.7),
            dark: darken(color, 0.2),
        };
    }
};
const getPalette = (theme, defaultTheme) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (!(theme === null || theme === void 0 ? void 0 : theme.palette) || typeof ((_a = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _a === void 0 ? void 0 : _a.primary) !== 'string') {
        return {};
    }
    return Object.assign(Object.assign({}, defaultTheme), { palette: {
            primary: Object.assign(Object.assign({}, generateMainColorObject((_b = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _b === void 0 ? void 0 : _b.primary)), { contrastText: (_d = (_c = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _c === void 0 ? void 0 : _c.primaryText) !== null && _d !== void 0 ? _d : '#000000' }),
            secondary: Object.assign(Object.assign({}, generateMainColorObject((_e = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _e === void 0 ? void 0 : _e.secondary)), { contrastText: (_g = (_f = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _f === void 0 ? void 0 : _f.secondaryText) !== null && _g !== void 0 ? _g : '#000000' }),
            danger: Object.assign(Object.assign({}, generateMainColorObject((_h = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _h === void 0 ? void 0 : _h.error)), { contrastText: '#FFF' }),
            success: Object.assign(Object.assign({}, generateSubColorObject((_j = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _j === void 0 ? void 0 : _j.success)), { contrastText: '#FFF' }),
            error: Object.assign(Object.assign({}, generateSubColorObject((_k = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _k === void 0 ? void 0 : _k.error)), { contrastText: '#FFF' }),
            warning: Object.assign(Object.assign({}, generateSubColorObject((_l = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _l === void 0 ? void 0 : _l.warning)), { contrastText: '#FFF' }),
            info: Object.assign(Object.assign({}, generateSubColorObject((_m = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _m === void 0 ? void 0 : _m.info)), { contrastText: '#FFF' }),
        } });
};

const defaultMetadata = {
    theme: {},
    themeV2: {},
    localizations: {},
    navigation: {
        usage: {
            visibility: 'hidden',
            permissions: ['fe.usage.read'],
            featureFlag: 'fe-usage-page',
        },
        webhooks: {
            visibility: 'hidden',
            permissions: ['fe.connectivity.read.webhooks'],
        },
        roles: {
            visibility: 'hidden',
            featureFlag: 'fe-roles-page',
            permissions: ['fe.secure.read.roles'],
        },
        users: {
            visibility: 'always',
            permissions: ['fe.secure.read.users'],
            inviteDialog: {
                phoneNumberField: 'optional',
            },
        },
        personalApiTokens: {
            visibility: 'hidden',
        },
        apiTokens: {
            visibility: 'hidden',
            permissions: ['fe.secure.read.tenantApiTokens'],
        },
        profile: {
            visibility: 'always',
        },
        privacy: {
            visibility: 'always',
        },
        account: {
            visibility: 'always',
        },
        security: {
            visibility: 'always',
            permissions: ['fe.secure.read.securityPolicy'],
        },
        sso: {
            visibility: 'hidden',
        },
        multipleSSO: {
            visibility: 'hidden',
            permissions: ['fe.secure.read.samlConfiguration'],
        },
        audits: {
            visibility: 'always',
            permissions: ['fe.secure.read.audits'],
        },
        subscriptions: {
            visibility: 'hidden',
            permissions: ['fe.subscriptions.*'],
        },
    },
};
class Metadata {
    constructor() {
        this._theme = defaultMetadata.theme;
        this._themeV2 = defaultMetadata.themeV2;
        this._navigation = defaultMetadata.navigation;
        this._localizations = defaultMetadata.localizations;
    }
    static getInstance(name = 'default') {
        return this._instances[name];
    }
    static set(metadata, name = 'default') {
        const metadataInstance = new Metadata();
        metadataInstance.set(metadata);
        Metadata._instances[name] = metadataInstance;
        return metadataInstance;
    }
    get theme() {
        var _a;
        return (_a = this._theme) !== null && _a !== void 0 ? _a : {};
    }
    get themeV2() {
        var _a;
        return (_a = this._themeV2) !== null && _a !== void 0 ? _a : {};
    }
    get navigation() {
        var _a;
        return (_a = this._navigation) !== null && _a !== void 0 ? _a : {};
    }
    get localizations() {
        var _a;
        return (_a = this._localizations) !== null && _a !== void 0 ? _a : {};
    }
    set(metadata) {
        var _a, _b, _c, _d, _e, _f, _g;
        try {
            this._navigation = deepMerge.all([(_a = defaultMetadata.navigation) !== null && _a !== void 0 ? _a : {}, (_b = metadata === null || metadata === void 0 ? void 0 : metadata.navigation) !== null && _b !== void 0 ? _b : {}]);
            this._theme = deepMerge.all([
                (_c = defaultMetadata.theme) !== null && _c !== void 0 ? _c : {},
                getPalette(metadata === null || metadata === void 0 ? void 0 : metadata.theme, defaultMetadata.theme),
            ]);
            this._themeV2 = deepMerge.all([(_d = defaultMetadata.themeV2) !== null && _d !== void 0 ? _d : {}, (_e = metadata === null || metadata === void 0 ? void 0 : metadata.themeV2) !== null && _e !== void 0 ? _e : {}]);
            this._localizations = deepMerge.all([(_f = defaultMetadata.localizations) !== null && _f !== void 0 ? _f : {}, (_g = metadata === null || metadata === void 0 ? void 0 : metadata.localizations) !== null && _g !== void 0 ? _g : {}]);
        }
        catch (e) {
            this._navigation = defaultMetadata.navigation;
            this._theme = defaultMetadata.theme;
            this._themeV2 = defaultMetadata.themeV2;
            this._localizations = defaultMetadata.localizations;
        }
    }
}
Metadata._instances = {};

export { Metadata };
